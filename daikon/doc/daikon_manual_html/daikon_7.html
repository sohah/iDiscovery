<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on June, 23 2010 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>The Daikon Invariant Detector User Manual: 7. Front ends (instrumentation)</title>

<meta name="description" content="The Daikon Invariant Detector User Manual: 7. Front ends (instrumentation)">
<meta name="keywords" content="The Daikon Invariant Detector User Manual: 7. Front ends (instrumentation)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="NOD69"></a>
<a name="SEC68"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="daikon_6.html#SEC67" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC69" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon_6.html#SEC45" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 7. Front ends (instrumentation) </h1>


<p>The Daikon invariant detector is a machine learning tool that finds
patterns (invariants) in data.  That data can come from any source, but
Daikon is typically used to find invariants over variable values in
running programs.  A front end is a tool that converts data from some
other format into Daikon's input format.  The most common type of front
end is an instrumenter, which causes your program to output a
&lsquo;<tt>.dtrace</tt>&rsquo; file that Daikon can process.
</p>
<p>This chapter describes several front ends (instrumenters) that are part
of Daikon.  It
is relatively easy to build your own front end, if these do not serve
your purpose; we are aware of a number of users who have done so.  For
more information about building a new front end, see <a href="..//New-front-ends.html#New-front-ends">(./developer)New front ends</a> section `New front ends' in <cite>Daikon Developer Manual</cite>.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC69">7.1 Java front end Chicory</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC75">7.2 DynComp dynamic comparability (abstract type) analysis for Java</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC80">7.3 C/C++ front end Kvasir</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC94">7.4 Source-based C/C++ front end Mangel-Wurzel</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC107">7.5 Perl front end dfepl</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC109">7.6 Comma-separated-value front end convertcsv.pl</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC110">7.7 Other front ends</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            
</td></tr>
</table>

<hr size="6">
<a name="Chicory"></a>
<a name="SEC69"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC68" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.1 Java front end Chicory </h2>


<p>The Daikon front end for Java, named Chicory, executes Java programs,
creates data trace (&lsquo;<tt>.dtrace</tt>&rsquo;) files, and optionally runs Daikon on
them.  Chicory is named after the chicory plant, whose root is sometimes
used as a coffee substitute or flavor enhancer.
</p>
<p>To use Chicory, run your program as you normally would, but
replace the <code>java</code> command with <code>java daikon.Chicory</code>.  For
instance, if you usually run
</p><table><tr><td>&nbsp;</td><td><pre class="example">java mypackage.MyClass arg1 arg2 arg3
</pre></td></tr></table>
<p>then instead you would run
</p><table><tr><td>&nbsp;</td><td><pre class="example">java daikon.Chicory mypackage.MyClass arg1 arg2 arg3
</pre></td></tr></table>
<p>This runs your program and creates file &lsquo;<tt>MyClass.dtrace</tt>&rsquo;
in the current directory.
Furthermore, a single command can both create a trace file and run Daikon:
</p><table><tr><td>&nbsp;</td><td><pre class="example">java daikon.Chicory --daikon mypackage.MyClass arg1 arg2 arg3
</pre></td></tr></table>
<p>See below for more options.
</p>
<p>That's all there is to it!  Since Chicory instruments class files
directly as they are loaded into Java,
you do not need to perform separate instrumentation and recompilation steps.
However, you should compile your program with debugging information
enabled (the &lsquo;<samp>-g</samp>&rsquo; command-line switch to <code>javac</code>);
otherwise, Chicory uses the names <code>arg0</code>, <code>arg1</code>, &hellip; as
the names of method arguments.
</p>
<p>Chicory must be run in a version 5.0 JVM, but it is backward-compatible
with older versions of Java code.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC70">7.1.1 Chicory options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC74">7.1.2 Static fields (global variables)</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Chicory-options"></a>
<a name="SEC70"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC69" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC71" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC69" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.1.1 Chicory options </h3>

<p>Chicory is invoked as follows:
</p><table><tr><td>&nbsp;</td><td><pre class="example">java daikon.Chicory <var>chicory-args</var> <var>classname</var> <var>args</var>
</pre></td></tr></table>
<p>where
</p><table><tr><td>&nbsp;</td><td><pre class="example">java <var>classname</var> <var>args</var>
</pre></td></tr></table>
<p>is a valid invocation of Java.
</p>
<p>This section lists the optional command-line arguments to Chicory, which
appear before the <var>classname</var> on the Chicory command line.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC71">7.1.1.1 Program points in Chicory output</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC72">7.1.1.2 Variables in Chicory output</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC73">7.1.1.3 Chicory miscellaneous options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Program-points-in-Chicory-output"></a>
<a name="SEC71"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC70" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC72" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.1.1.1 Program points in Chicory output </h4>


<p>This section lists options that control which program points appear in
Chicory's output.
</p>


<dl compact="compact">
<dt> &lsquo;<samp>--ppt-select-pattern=<var>regexp</var></samp>&rsquo;</dt>
<dd><p>Only produce trace output for classes/procedures/program points whose
names match the
given regular expression.  This option may be supplied multiple times,
and may be used in conjunction with &lsquo;<samp>--ppt-omit-pattern</samp>&rsquo;.
</p>
<p>When this switch is supplied, filtering occurs in the following way:
for each program point, Chicory checks the fully
qualified class name, the method name, and the
the program point name against each <var>regexp</var> that
was supplied.  If any of these match, then the program point is included
in the instrumentation.
</p>
<p>Suppose that method <code>bar</code> is defined only in class <code>C</code>.  Then to
traces only <code>bar</code>, you could match the method name (in any class)
with regular expression
&lsquo;<samp>bar$</samp>&rsquo;, or you could match the program point name with &lsquo;<samp>C\.bar\(</samp>&rsquo;.
</p>
<p>Using Unix shell syntax, you would execute
</p><table><tr><td>&nbsp;</td><td><pre class="example">java daikon.Chicory --ppt-select-pattern='bar$' ...
java daikon.Chicory --ppt-select-pattern='C\.bar\(' ...
</pre></td></tr></table>

<p>From the Windows command line, you would execute
</p><table><tr><td>&nbsp;</td><td><pre class="example">java daikon.Chicory --ppt-select-pattern='bar$' ...
java daikon.Chicory --ppt-select-pattern='C\.bar\(' ...
</pre></td></tr></table>


</dd>
<dt> &lsquo;<samp>--ppt-omit-pattern=<var>regexp</var></samp>&rsquo;</dt>
<dd><p>Do not produce data trace output for classes/procedures/program points
whose names match the given regular expression.  This
reduces the size of the data trace file and also may make the
instrumented program run faster, since it need not output those variables.
</p>
<p>This option works just like &lsquo;<samp>--ppt-select-pattern</samp>&rsquo; does, except
that matching program points are excluded, not included.
</p>
<p>The &lsquo;<samp>--ppt-omit-pattern</samp>&rsquo; argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its fully qualified class, procedure name, or
complete program point name matches one of the omitting criteria.
</p>

<p>The &lsquo;<samp>--ppt-omit-pattern</samp>&rsquo; argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its fully qualified class, fully qualified procedure name, or
complete program point name exactly matches one of the omitting criteria.
A regular expression matches if it matches any portion of the program
point name.  Note that currently only classes are matched, not each full
program point name.  Thus, either all of a class's methods are traced,
or none of
them are.
</p>
<p>Here are examples of how to avoid detecting invariants over various
parts of your program.
</p>
<ul class="toc">
<li> omit a whole package:
<table><tr><td>&nbsp;</td><td><pre class="smallexample">java daikon.Chicory '--ppt-omit-pattern=^junit\.' ...
</pre></td></tr></table>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">java daikon.Chicory '--ppt-omit-pattern=^daikon\.util\..*' ...
</pre></td></tr></table>

</li><li> omit a single class:
<table><tr><td>&nbsp;</td><td><pre class="smallexample">java daikon.Chicory '--ppt-omit-pattern=HashSetLinear\$HslIterator' ...
</pre></td></tr></table>

</li><li> omit a single method:
<table><tr><td>&nbsp;</td><td><pre class="smallexample">java daikon.Chicory '--ppt-omit-pattern=StackAr.topAndPop()' ...
</pre></td></tr></table>

</li><li> omit a single program point:
<table><tr><td>&nbsp;</td><td><pre class="smallexample">java daikon.Chicory '--ppt-omit-pattern=StackAr.&lt;init&gt;(int):::EXIT33' ...
</pre></td></tr></table>

</li></ul>

</dd>
<dt> &lsquo;<samp>--sample-start=<var>sample-cnt</var></samp>&rsquo;</dt>
<dd><a name="IDX81"></a>
<p>When this option is chosen, Chicory will record each program point until
that program point has been executed <var>sample-cnt</var> times.  Chicory will
then begin sampling.  Sampling starts at 10% and decreases by a factor
of 10 each time another <var>sample-cnt</var> samples have been recorded.  If
<var>sample-cnt</var> is 0, then all calls will be recorded.
</p>
</dd>
<dt> &lsquo;<samp>--boot-classes=<var>regex</var></samp>&rsquo;</dt>
<dd><p>Chicory treats  classes that match the <var>regex</var> as boot classes.
Such classes are not instrumented.
</p>
</dd>
</dl>


<hr size="6">
<a name="Variables-in-Chicory-output"></a>
<a name="SEC72"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC71" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC73" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.1.1.2 Variables in Chicory output </h4>


<p>This section lists options that control which variables appear in
Chicory's output.
</p>


<dl compact="compact">
<dt> &lsquo;<samp>--nesting-depth=<var>n</var></samp>&rsquo;</dt>
<dd><p>Depth to which to examine structure components (default 2).
This parameter determines which variables the front end causes to be output at
runtime.  For instance, suppose that a program contained the following
data structures and variables:
</p><table><tr><td>&nbsp;</td><td><pre class="example">class A {
  int x;
  B b;
}
class B {
  int y;
  int z;
}
A myA;

class Link {
  int val;
  Link next;
}
Link myList;
</pre></td></tr></table>
<ul>
<li>
If depth=0, only the identities (hashcodes) of <code>myA</code> and
<code>myList</code> would be examined; those variables could be determined to
be equal or not equal to other variables.
</li><li>
If depth=1, then also <code>MyA.b</code>, <code>myList.next</code>, and the integers
<code>myA.x</code> and <code>myList.val</code> would be examined.
</li><li>
If depth=2, then also <code>MyA.b.y</code>, <code>MyA.b.y</code>,
<code>myList.next.next</code>, and <code>myList.next.val</code> would be examined.
</li></ul>

<p>Values whose value is undefined are not examined.  For instance, if <code>myA</code>
is <code>null</code> on a particular execution of a program point, then
<code>myA.b</code> is not accessed on that execution regardless of the depth
parameter.  That variable appears in the &lsquo;<tt>.dtrace</tt>&rsquo; file, but its
value is marked as nonsensical.
</p>
</dd>
<dt> &lsquo;<samp>--omit-var=<var>regex</var></samp>&rsquo;</dt>
<dd><a name="IDX82"></a>
<p>Do not include variables whose name matches the regular expression.  Variables
will be omitted from each program point in which they appear.
</p>
</dd>
<dt> &lsquo;<samp>--std-visibility</samp>&rsquo;</dt>
<dd><a name="IDX83"></a>
<a name="IDX84"></a>
<p>When this switch is on, Chicory will traverse exactly those fields that are
visible from a given program point.  For instance, only the public
fields of class <code>pack1.B</code> will be included at a program point for
class <code>pack2.A</code> whether or not <code>pack1.B</code> is instrumented.
By default, Chicory outputs all fields in instrumented classes (even
those that would not be accessible in Java code at the given program point)
and outputs no fields from uninstrumented classes (even those that are
accessible).  When you supply
&lsquo;<samp>--std-visibility</samp>&rsquo;, consider also supplying &lsquo;<samp>--purity-file</samp>&rsquo; to
enrich the set of expressions in Daikon's output.
</p>
</dd>
<dt> &lsquo;<samp>--purity-file=<var>pure-methods-file</var></samp>&rsquo;</dt>
<dd><a name="IDX85"></a>
<a name="IDX86"></a>
<p>File <var>pure-methods-file</var> lists the pure methods (sometimes called
observer methods) in a Java program.  Pure methods have no externally
side effects, such as setting variables or producing output.  For
example, most implementations of the <code>hashCode()</code>,
<code>toString()</code>, and <code>equals()</code> methods are pure.
</p>
<p>For each variable, Chicory adds to the trace new &ldquo;fields&rdquo; that
represent invoking each pure method on the variable.  (Currently,
Chicory does so only for pure methods that take no parameters, and
obviously this mechanism is only useful for methods that return a value:
a pure method that returns no value does nothing!)
</p>
<p>Here is an example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">class Point {
  private int x, y;
  public int radiusSquared() {
    return x*x + y*y;
  }
}
</pre></td></tr></table>

<p>I <code>radiusSquared()</code> has been specified as pure, then for each point
<var>p</var>, Chicory will output the variables <code><var>p</var>.x</code>,
<code><var>p</var>.y</code>, and <code><var>p</var>.radiusSquared()</code>.  Use of pure
methods can improve the Daikon output, since they represent information
that the programmer considered important but that is not necessarily
stored in a variable.
</p>
<p>Invoking a pure method at any time in an application should not change
the application's behavior.  If a non-pure method is listed in a purity
file, then application behavior can change.  Chicory does not verify the
purity of methods listed in the purity file.
</p>
<p>The purity file lists a set of methods, one per line.  The format of
each method is given by the Sun JDK API:
</p><blockquote><p>The string is formatted as the method access modifiers, if any, followed
by the method return type, followed by a space, followed by the class
declaring the method, followed by a period, followed by the method name,
followed by a parenthesized, comma-separated list of the method's formal
parameter types.  If the method throws checked exceptions, the parameter
list is followed by a space, followed by the word throws followed by a
comma-separated list of the thrown exception types.  For example:
</p><table><tr><td>&nbsp;</td><td><pre class="example">public boolean java.lang.Object.equals(java.lang.Object)
</pre></td></tr></table>
<p>The access modifiers are placed in canonical order as specified by &quot;The
Java Language Specification&quot;.  This is public, protected or private
first, and then other modifiers in the following order: abstract,
static, final, synchronized native.
</p></blockquote>

<p>By convention, <var>pure-methods-file</var> has the suffix &lsquo;<tt>.pure</tt>&rsquo;.  If
<var>pure-methods-file</var> is specified as a relative (not absolute) file
name, it is searched for in the configuration directory specified via
&lsquo;<samp>--configs=<var>directory</var></samp>&rsquo;, or in the current directory if no
configuration directory is specified.
</p>
<p>One way to create a &lsquo;<tt>.pure</tt>&rsquo; file is to run the Purity Analysis Kit
(<a href="http://jppa.sourceforge.net/">http://jppa.sourceforge.net/</a>).  If you supply
the &lsquo;<samp>--daikon-purity-file</samp>&rsquo; when running the Purity Analysis Kit,
it writes a file that can be supplied to Chicory.
</p>
</dd>
<dt> &lsquo;<samp>--linked-lists</samp>&rsquo;</dt>
<dd><a name="IDX87"></a>
<p>This boolean option (default: true) causes user-defined linked lists to
be output as sequences, much like Java &lsquo;<samp>List</samp>&rsquo;s and arrays are.
A user-defined data structure is considered to be a linked list if it
has one instance field that is of its own type.
</p>
</dd>
</dl>


<hr size="6">
<a name="Chicory-miscellaneous-options"></a>
<a name="SEC73"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC72" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC74" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC70" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.1.1.3 Chicory miscellaneous options </h4>

<p>This section lists all other Chicory options &mdash; that is, all options
that do not control which program points and variables appear in
Chicory's output.
</p>
<dl compact="compact">
<dt> &lsquo;<samp>--help</samp>&rsquo;</dt>
<dd><p>Print a help message.
</p>
</dd>
<dt> &lsquo;<samp>--debug</samp>&rsquo;</dt>
<dd><p>Produce debugging information.  For other debugging options, run Chicory
with the &lsquo;<samp>--help</samp>&rsquo; option.
</p>
</dd>
<dt> &lsquo;<samp>--default-bcel</samp>&rsquo;</dt>
<dd><p>Chicory uses the Byte Code Engineering Library (BCEL) to instrument
classfiles.  Errors can occur if the application uses an incompatible
version of BCEL.  By default, Chicory identifies and loads its 
copy of BCEL when multiple copies of BCEL are in the classpath.  It will
also issue a warning if multiple copies of BCEL are in the classpath and
the application version is not the first one.  When this option is
chosen, Chicory will simply use whatever version of BCEL is found on
the classpath.
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-file=<var>filename</var></samp>&rsquo;</dt>
<dd><a name="IDX88"></a>
<a name="IDX89"></a>
<a name="IDX90"></a>
<a name="IDX91"></a>
<a name="IDX92"></a>
<a name="IDX93"></a>
<a name="IDX94"></a>
<p>Specifies the default name for the trace output (&lsquo;<tt>.dtrace</tt>&rsquo;) file.
If this is not specified, then the value of the <code>DTRACEFILE</code>
environment variable (at the time the instrumented program runs) is
used.  If that environment variable is not used, then the default is
&lsquo;<tt>./<var>CLASSNAME</var>.dtrace</tt>&rsquo;.
</p>
<p>If the <code>DTRACEAPPEND</code> environment
variable is set to any value, the dtrace file will be appended to
instead of overwritten.  Compressed data trace files may not be appended
to.  In some cases you may find a single large data trace file more
convenient; in other cases, a collection of smaller data trace files may
give you more control over which subsets of runs to invoke Daikon on.
</p>
</dd>
<dt> &lsquo;<samp>--comparability-file=<var>filename</var></samp>&rsquo;</dt>
<dd><p>This option specifies a declaration file (see <a href="..//Declarations.html#Declarations">(./developer)Declarations</a> section `Declarations' in <cite>Daikon Developer Manual</cite>)
that contains comparability information.  This information will be
incorporated in the output of Chicory.  Any variables not included in
the comparability file will have their comparability set so that they
are comparable to all other variables of the same type.
</p>
</dd>
<dt> &lsquo;<samp>--output-dir=<var>directory</var></samp>&rsquo;</dt>
<dd><p>Write the &lsquo;<tt>.dtrace</tt>&rsquo; trace output file to the specified directory.
The default is the current directory.
</p>
</dd>
<dt> &lsquo;<samp>--config-dir=<var>directory</var></samp>&rsquo;</dt>
<dd><p>Chicory will use this location to search for configuration files.
Currently, this only includes &lsquo;<tt>*.pure</tt>&rsquo; files.
</p>
</dd>
<dt> &lsquo;<samp>--daikon</samp>&rsquo;</dt>
<dd><p>After creating a data trace (&lsquo;<tt>.dtrace</tt>&rsquo;) file, run Daikon on it.
To specify arguments to Daikon use the &lsquo;<samp>--daikon-args</samp>&rsquo; option.
Also see the
&lsquo;<samp>--daikon-online</samp>&rsquo; option.
</p>
<p>This option supplies Daikon with a single trace from one execution of
your program.  By contrast to this option (and
&lsquo;<samp>--daikon-online</samp>&rsquo;), if you invoke Daikon from the command line,
you can supply Daikon with as many trace files as you wish.
</p>
</dd>
<dt> &lsquo;<samp>--daikon-online</samp>&rsquo;</dt>
<dd><p>This option is like &lsquo;<samp>--daikon</samp>&rsquo;, except that no &lsquo;<tt>.dtrace</tt>&rsquo;
data trace file is produced.  Instead, Chicory sends trace information
over a socket to Daikon, which processes the information incrementally
(&ldquo;online&rdquo;), as Chicory produces it.
</p>
<p>Just like with the &lsquo;<samp>--daikon</samp>&rsquo; option, Daikon is only given a
single trace from one execution of your program.
</p>
<p>The Kvasir front end also supports online execution, via use of (normal or
named) Unix pipes (see section <a href="#SEC90">Online execution</a>).
</p>
</dd>
<dt> &lsquo;<samp>--daikon-args=<var>arguments</var></samp>&rsquo;</dt>
<dd><p>Specifies arguments to be passed to Daikon if the &lsquo;<samp>--daikon</samp>&rsquo; or
&lsquo;<samp>--daikon-online</samp>&rsquo; options are used.
</p>
</dd>
<dt> &lsquo;<samp>--premain=<var>path</var></samp>&rsquo;</dt>
<dd><p>Specifies the absolute pathname to the &lsquo;<tt>ChicoryPremain.jar</tt>&rsquo; file.
Chicory requires this jar file in order to execute.  By default Chicory
looks for the jar file in the classpath and in &lsquo;<tt>$(DAIKONDIR)/java</tt>&rsquo;
(where <code>DAIKONDIR</code> is an environment variable that points to the
complete installation of Daikon).
</p>
<p>Chicory can also use the &lsquo;<tt>daikon.jar</tt>&rsquo; file for this purpose.  If it
doesn't find &lsquo;<tt>ChicoryPremain.jar</tt>&rsquo; above, it will use &lsquo;<tt>daikon.jar</tt>&rsquo;
itself (if a file named &lsquo;<tt>daikon.jar</tt>&rsquo; appears in the classpath).  If
the Daikon jar file is not named &lsquo;<tt>daikon.jar</tt>&rsquo;, you can use this
switch to specify its name.  For example:
</p><table><tr><td>&nbsp;</td><td><pre class="example">--premain=C:\lib\daikon-4.1.3.jar
</pre></td></tr></table>

</dd>
<dt> &lsquo;<samp>--heap-size=<var>max_heap</var></samp>&rsquo;</dt>
<dd><p>Specifies the maximum size, in bytes, of the memory allocation pool for
the target program.  The size is specified in the same manner as the
-Xmx switch to java.
</p>
</dd>
</dl>


<hr size="6">
<a name="NOD75"></a>
<a name="SEC74"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC73" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC69" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.1.2 Static fields (global variables) </h3>


<p>Chicory (Daikon's front end for Java) outputs the values of static
fields in the current class, but not in other classes.  That means that
Daikon cannot report properties over static fields in other classes,
because it never sees their values.  (By contrast, Kvasir
(see section <a href="#SEC80">C/C++ front end Kvasir</a>) supplies the values of C/C++ global variables to
Daikon.)
</p>
<p>If you need Daikon to include all static variables when processing each
class, then ask the maintainers to add that feature to
Chicory (or work with them to implement the enhancement).  In the
meanwhile, here are two workarounds.
</p>
<ol>
<li>
Add a static field whose type is the class containing the fields of
interest.  You don't have to ever assign to the new field.  A
disadvantage of this approach is that it gives you properties over the
global variables as observed by each class (which might be different).

</li><li>
At the beginning and end of each method, add a call to a dummy method
that has access to all the globals (via adding the field mentioned above).
This produces a single formula that is valid for all global variables at
all times.
</li></ol>



<hr size="6">
<a name="DynComp-for-Java"></a>
<a name="SEC75"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC74" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC76" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.2 DynComp dynamic comparability (abstract type) analysis for Java </h2>


<p>The DynComp dynamic comparability analysis tool performs dynamic type
inference to group variables at each program point into comparability
sets (see <a href="..//Program-point-declarations.html#Program-point-declarations">(./developer)Program point declarations</a> section `Program point declarations' in <cite>Daikon Developer Manual</cite> for the numeric
representation format of these sets).  All variables in each
comparability set belong to the same &ldquo;abstract type&rdquo; of data that the
programmer likely intended to represent, which is a richer set of types
than the few basic declared types (e.g., int, float) provided by the
language.  Consider the example below:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">public class Year {
    public static void main(String[] args) {
        int year = 2005;
        int winterDays = 58;
        int summerDays = 307;
        compute(year, winterDays, summerDays);
    }

    public static int compute(int yr, int d1, int d2) {
        if (0 != yr % 4)
            return d1 + d2;
        else
            return d1 + d2 + 1;
    }
}
</pre></td></tr></table>

<p>The three variables in <code>main()</code> all have the same Java
representation type, <code>int</code>, but two of them hold related quantities
(numbers of days), as can be determined by the fact that they interact
when the program adds them, whereas the other contains a conceptually
distinct quantity (a year).  The abstract types 'day' and 'year' are
both represented as <code>int</code>, but DynComp can differentiate them with
its dynamic analysis.  For example, DynComp can infer that
<code>winterDays</code> and <code>summerDays</code> are comparable (belong to the
same abstract type) because the program adds their values together
within the compute() function.
</p>
<p>Without comparability information, Daikon attempts to find invariants
over all pairs (and sometimes triples) of variables present at every
program point.  This can lead to two negative consequences: First, it
may take lots of time and memory to infer all of these invariants,
especially when there are many global or derived variables present.
Second, many of those invariants are true but meaningless because they
relate variables which conceptually represent different types (e.g., an
invariant such as <code>winterDays &lt; year</code> is true but meaningless
because days and years are not comparable).
</p>
<p>To use DynComp, run your program as you normally would, but replace the
<code>java</code> command with <code>java daikon.DynComp</code>.  For instance,
if you usually run
</p><table><tr><td>&nbsp;</td><td><pre class="example">java mypackage.MyClass arg1 arg2 arg3
</pre></td></tr></table>
<p>then instead you would run
</p><table><tr><td>&nbsp;</td><td><pre class="example">java daikon.DynComp mypackage.MyClass arg1 arg2 arg3
</pre></td></tr></table>
<p>This runs your program and creates the file &lsquo;<tt>MyClass.decls-DynComp</tt>&rsquo;
in the current directory.  DynComp also creates &lsquo;<tt>MyClass.txt-cset</tt>&rsquo;,
which contains the same information and a further level of detail in an
easier-to-read format.  The &lsquo;<tt>.decls</tt>&rsquo; file may be passed to Chicory,
as described in <a href="daikon_3.html#SEC16">Using DynComp with Java programs</a>.
</p><table><tr><td>&nbsp;</td><td><pre class="example">java daikon.Chicory --comparability-file=MyClass.decls-DynComp \
     mypackage.MyClass arg1 arg2 arg3
</pre></td></tr></table>

<p>See below for more options.
</p>
<p>While you may run DynComp with the standard JDK, using the
&lsquo;<samp>--no-jdk</samp>&rsquo; switch, you can obtain more accurate results by using a
copy of the JDK that has been instrumented with DynComp.  See
<a href="#SEC76">Instrumenting the JDK with DynComp</a>, below, for instructions.
</p>
<p>This is part of a sample &lsquo;<tt>.decls</tt>&rsquo; file generated by running DynComp on the example above:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">DECLARE
Year.compute(int, int, int):::ENTER
yr
int # isParam=true
int
3
d1
int # isParam=true
int
2
d2
int # isParam=true
int
2

DECLARE
Year.compute(int, int, int):::EXIT11
yr
int # isParam=true
int
3
d1
int # isParam=true
int
2
d2
int # isParam=true
int
2
return
int
int
2
</pre></td></tr></table>

<p>The declarations file format is described in <a href="..//Program-point-declarations.html#Program-point-declarations">(./developer)Program point declarations</a> section `Program point declarations' in <cite>Daikon Developer Manual</cite>.
</p>
<p>DynComp creates two representations of the comparability information in
the files &lsquo;<tt>foo.txt-cset</tt>&rsquo; and &lsquo;<tt>foo.txt-trace</tt>&rsquo;.  In the &lsquo;<tt>cset</tt>&rsquo;
file, DynComp outputs comparability sets as sets.  The above &lsquo;<tt>.decls</tt>&rsquo;
output corresponds to the following in &lsquo;<tt>cset</tt>&rsquo;:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">Daikon Variable sets for Year.compute(I yr, I d1, I d2) enter
  [1] [daikon.chicory.ParameterInfo:d1]
  [1] [daikon.chicory.ParameterInfo:d2]
  [1] [daikon.chicory.ParameterInfo:yr]
Daikon Variable sets for Year.compute(I yr, I d1, I d2) exit
  [3] [daikon.chicory.ParameterInfo:d1, daikon.chicory.ParameterInfo:
       d2, daikon.chicory.ReturnInfo:return]
  [1] [daikon.chicory.ParameterInfo:yr]
</pre></td></tr></table>

<p>In the &lsquo;<tt>trace</tt>&rsquo; file, DynComp outputs comparability sets as trees,
structured such that each variable in the tree has interacted with its
children.  The lack of a parent-child relationship between two variables
in a set does not imply anything about whether they interacted.
The above &lsquo;<tt>.decls</tt>&rsquo; output corresponds to the following in
&lsquo;<tt>trace</tt>&rsquo;:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">Daikon Traced Tree for Year.compute(I yr, I d1, I d2) enter

daikon.chicory.ParameterInfo:d1

daikon.chicory.ParameterInfo:d2

daikon.chicory.ParameterInfo:yr


Daikon Traced Tree for Year.compute(I yr, I d1, I d2) exit

daikon.chicory.ParameterInfo:d2
--daikon.chicory.ParameterInfo:d1 ([Year:compute()-11])
--daikon.chicory.ReturnInfo:return ([Year:compute()-11])

daikon.chicory.ParameterInfo yr
</pre></td></tr></table>

<p>The file here shows that <code>d1</code>, <code>d2</code>, and the return value of
the <code>compute</code> method are in the same comparability set; this is
correct, as they are all of the abstract type `days'.  The variable
<code>yr</code> is in its own comparability set; it has abstract type `year',
and so is not comparable to the other variables.  In addition, the structure
of the <code>[d1, d2, return]</code> set shows that at some point, <code>d1</code> interacted
with <code>d2</code>, and that <code>d2</code> interacted with <code>return</code>.  The absence of
a <code>d1 -- return</code> edge does not imply that <code>d1</code> and <code>return</code> never
interacted directly.
</p>
<p>In addition, non-root nodes in the &lsquo;<tt>trace</tt>&rsquo; trees can indicate a list of class names,
method names, and line numbers at which values interacted, resulting in comparability
between the preceding child node and its parent.  In the above example, <code>d1</code>
interacted with <code>d2</code> on line 11 of the <code>compute</code> method of the <code>Year</code>
class.
</p>
<p>Duplicate values in this list represent the results of separate calls to
another method which each of the relevant variables.  For example, if <code>main</code> had calls
<code>compute(year, summerDays, winterDays)</code> and
<code>compute(year,schoolDays,breakDays)</code>, then for <code>main</code> we might see
this output:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">daikon.chicory.FieldInfo:summerDays
--daikon.chicory.FieldInfo:winterDays([Year:compute()-11])
--daikon.chicory.FieldInfo:schoolDays([Year:compute()-11, Year:compute()-11])
----daikon.chicory.FieldInfo:breakDays([Year:compute()-11])
</pre></td></tr></table>

<p>Empty lists indicate that no non-assignment interactions occurred in the series of
interactions connecting the two variables.
</p>
<p>Elements of these lists are essentially parts of stack traces.  The maximum number
of stack trace levels displayed is set by <code>--trace-line-depth</code>, which is equal to 1 by default.
</p>
<p>For these files, DynComp also has a <code>--abridged-vars</code> option that replaces text
like <code>daikon.chicory.ParameterInfo:d2</code> with text like <code>Parameter d2</code> in the &lsquo;<tt>cset</tt>&rsquo;
and &lsquo;<tt>trace</tt>&rsquo; files.  It writes <code>this</code> instead of
<code>daikon.chicory.ThisObjInfo:this</code>; and <code>return</code> instead of
<code>daikon.chicory.ReturnInfo:return</code>.  This option is off by default, but can be
turned on with <code>--abridged-vars</code>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC76">7.2.1 Instrumenting the JDK with DynComp</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC77">7.2.2 DynComp options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC78">7.2.3 Instrumentation of Object methods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC79">7.2.4 Known bugs and limitations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Instrumenting-the-JDK-with-DynComp"></a>
<a name="SEC76"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC75" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC77" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.2.1 Instrumenting the JDK with DynComp </h3>


<p>If you did not already do so when installing Daikon (in
<a href="daikon_2.html#SEC5">Complete installation instructions</a>), follow the instructions here to build an
instrumented copy of the JDK.  Use the following command in
&lsquo;<tt>$DAIKONDIR</tt>&rsquo;:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">make -C java dcomp_rt.jar
</pre></td></tr></table>

<p>Make sure the <code>JAVA_HOME</code> environment variable is set to the directory
containing your JDK.  This command instruments the classes in the
&lsquo;<tt>rt.jar</tt>&rsquo; file of the JDK, and creates a new file,
&lsquo;<tt>dcomp_rt.jar</tt>&rsquo;, in the &lsquo;<tt>java</tt>&rsquo; directory.
</p>
<p>On MacOS, there is not normally a JDK directory.  Instead, the
<code>ORIG_RT</code> variable must be set to specify the location of the input JDK
jar file (<code>classes.jar</code> in MacOS).  Normally the file is found in
<code>/System/Library/Frameworks</code> under the appropriate Java version.
The following example is for the standard install of Java 1.5 on
MacOS:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">  export ORIG_RT=/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/classes.jar
</pre></td></tr></table>

<p>BuildJDK requires 20-40 minutes to complete and uses 1024 MB of
memory.  Regular progress indicators are printed to standard output.
</p>
<p>You can ignore warnings issued during the instrumentation process, so
long as the make target itself completes normally.
</p>
<p>There are a small number of methods in the JDK that DynComp is
currently unable to instrument.  The names of these methods will be
printed at the end of instrumentation.  This is not a problem unless
your application calls these methods (directly or indirectly).  
If one of those methods is called, a NoSuchMethodException will
be generated when the call is attempted.
</p>
<hr size="6">
<a name="DynComp-for-Java-options"></a>
<a name="SEC77"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC76" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC78" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.2.2 DynComp options </h3>

<p>DynComp is invoked as follows:
</p><table><tr><td>&nbsp;</td><td><pre class="example">java daikon.DynComp <var>dyncomp-args</var> <var>classname</var> <var>args</var>
</pre></td></tr></table>
<p>where
</p><table><tr><td>&nbsp;</td><td><pre class="example">java <var>classname</var> <var>args</var>
</pre></td></tr></table>
<p>is a valid invocation of Java.
</p>
<p>This section lists the optional command-line arguments to DynComp, which
appear before the <var>classname</var> on the DynComp command line.
</p>
<dl compact="compact">
<dt> &lsquo;<samp>--verbose</samp>&rsquo;</dt>
<dd><p>Print information about the classes being processed.
</p>
</dd>
<dt> &lsquo;<samp>--debug</samp>&rsquo;</dt>
<dd><p>Dump the instrumented classes to &lsquo;<tt>/tmp/$USER/bin</tt>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--debug-dir</samp>&rsquo;</dt>
<dd><p>The directory in which to dump instrumented class files (only if
&lsquo;<samp>--debug</samp>&rsquo; is specified).  Defaults to &lsquo;<tt>debug</tt>&rsquo; in the current
working directory.
</p>
</dd>
<dt> &lsquo;<samp>--output-dir=<var>dir</var></samp>&rsquo;</dt>
<dd><p>The directory in which to create output files.  Defaults to the current
working directory.
</p>
</dd>
<dt> &lsquo;<samp>--decl-file=<var>file</var></samp>&rsquo;</dt>
<dd><p>Output filename for decl file suitable for input to Daikon.  Defaults to
&lsquo;<tt><var>target_program</var>.decls-DynComp</tt>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--no-cset-file</samp>&rsquo;</dt>
<dd><p>When this switch is on, output of the &lsquo;<tt>cset</tt>&rsquo; file is suppressed.
</p>
</dd>
<dt> &lsquo;<samp>--compare-sets-file=<var>file</var></samp>&rsquo;</dt>
<dd><p>Output filename for a more easily human-readable file summarizing
comparability sets.  The default behavior is to print to standard
output.  This switch has no effect if &lsquo;<samp>--no-cset-file</samp>&rsquo; is specified
on the command line.
</p>
</dd>
<dt> &lsquo;<samp>--trace-sets-file=<var>file</var></samp>&rsquo;</dt>
<dd><p>Output filename for a human-readable file showing some of the interactions
that occurred.  Default behavior is to not create the file.
</p>
</dd>
<dt> &lsquo;<samp>--trace-line-depth=<var>n</var></samp>&rsquo;</dt>
<dd><p>Controls size of the stack displayed in tracing the interactions that
occurred.  Default behavior is to only display one element in the stack &ndash;
that is, display at most the topmost function on the stack when the
interaction occurred.  This switch has no effect if &lsquo;<samp>--trace-sets-file</samp>&rsquo;
is not specified, or is null.
</p>
</dd>
<dt> &lsquo;<samp>--abridged-vars</samp>&rsquo;</dt>
<dd><p>When this switch is on, DynComp abridges the variables printed in the files
specified by &lsquo;<samp>--compare-sets-file</samp>&rsquo; and &lsquo;<samp>--trace-sets-file</samp>&rsquo;.
For example, DynComp with output
&ldquo;Field foo&rdquo; instead of &ldquo;dyncomp.chicory.FieldInfo:MyClass.foo&rdquo;.  In particular,
it replaces &ldquo;dyncomp.chicory.ReturnInfo:return&rdquo; with &ldquo;return&rdquo; and
&ldquo;dyncomp.chicory.ThisObjInfo:this&rdquo; with &ldquo;this&rdquo;.
</p>
</dd>
<dt> &lsquo;<samp>--ppt-select-pattern=<var>regex</var></samp>&rsquo;</dt>
<dd><p>Only emit program points that match <var>regex</var>.  Specifically, a
program point is considered to match <var>regex</var> if the fully qualified
class name, the method name, or the program point name matches
<var>regex</var>.  The behavior of this switch is the same as in Chicory (see
<a href="#SEC71">Program points in Chicory output</a>).
</p>
<p>This option can be specified multiple times, and may be used in
conjunction with &lsquo;<samp>--ppt-omit-pattern</samp>&rsquo;.  If a program point matches
both a select pattern and an omit pattern, it is omitted.
</p>
</dd>
<dt> &lsquo;<samp>--ppt-omit-pattern=<var>regex</var></samp>&rsquo;</dt>
<dd><p>Suppress program points that match <var>regex</var>.  Specifically, a
program point is considered to match <var>regex</var> if the fully qualified
class name, the method name, or the program point name matches
<var>regex</var>.  The behavior of this switch is the same as in Chicory (see
<a href="#SEC71">Program points in Chicory output</a>).
</p>
<p>This option can be specified multiple times, any may be used in
conjunction with &lsquo;<samp>--ppt-select-pattern</samp>&rsquo;.  If a program point
matches both a select pattern and an omit pattern, it is omitted.
</p>
</dd>
<dt> &lsquo;<samp>--no-primitives</samp>&rsquo;</dt>
<dd><p>Don't track primitives.  When this switch is on, DynComp only tracks
the comparability of object references; primitive values are
ignored.  Using this switch can greatly improve DynComp's runtime if
you are not interested in primitive values.
</p>
</dd>
<dt> &lsquo;<samp>--no-jdk</samp>&rsquo;</dt>
<dd><p>When this switch is on, DynComp runs with an uninstrumented JDK, and the
&lsquo;<samp>--rt-file</samp>&rsquo; switch is ignored.
</p>
</dd>
<dt> &lsquo;<samp>--rt-file</samp>&rsquo;</dt>
<dd><p>Specifies the location of the instrumented JDK (see <a href="#SEC76">Instrumenting the JDK with DynComp</a>).  This option is rarely necessary, because
if &lsquo;<samp>--rt-file</samp>&rsquo; is not specified, DynComp
will search for a file named &lsquo;<tt>dcomp_rt.jar</tt>&rsquo; along the classpath,
and in &lsquo;<tt>$DAIKONDIR/java</tt>&rsquo;.  Both this file and the current classpath
are placed on the boot classpath for DynComp's execution.
</p>
</dd>
<dt> &lsquo;<samp>--std-visibility</samp>&rsquo;</dt>
<dd><p>When this switch is on, DynComp traverses exactly those fields that are
visible from a given program point.  For an example, see <a href="#SEC72">Variables in Chicory output</a>.
</p>
</dd>
<dt> &lsquo;<samp>--nesting-depth=<var>n</var></samp>&rsquo;</dt>
<dd><p>Depth to which to examine structure components (default 2).  This
parameter determines which variables the front end causes to be output
at runtime.  For an example, see <a href="#SEC72">Variables in Chicory output</a>.
</p>
</dd>
</dl>


<hr size="6">
<a name="Instrumentation-of-Object-methods"></a>
<a name="SEC78"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC77" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC79" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.2.3 Instrumentation of Object methods </h3>

<p>DynComp is unable to directly instrument methods of the class
<code>Object</code>, such as <code>clone</code> and <code>equals</code>.  DynComp uses a
few tricks, described here in brief, to track comparability in these
methods.
</p>
<p>Calls such as <code>o1.equals(o2)</code> are replaced with calls to a static
method in DynComp, <code>dcomp_equals(o1, o2)</code>.  This static method
dynamically determines whether or not <code>o1</code> is an instance of a
class that has been instrumented by DynComp; every such class
implements the interface <code>DCompInstrumented</code>.  If so, it attempts
to invoke the instrumented version of the <code>equals</code> method for
<code>o1</code>.  If not, or if <code>o1</code> has not overridden the
<code>equals</code> method from <code>Object</code>, then no instrumented version
exists, so the uninstrumented version is invoked.
</p>
<p>In either case, the references <code>o1</code> and <code>o2</code> are considered
to be comparable.  In a future release, we will provide a command-line
switch to customize this behavior.
</p>
<p>The <code>clone</code> method operates in a similar manner, choosing
dynamically to invoke the instrumented method or the uninstrumented
method.  In the case of <code>clone</code>, the methods are invoked via
reflection.  In either case, the object being cloned and the resulting
clone are made comparable to each other.  Again, we will provide a
switch to customize this behavior in a future release.
</p>

<hr size="6">
<a name="DynComp-for-Java-known-bugs"></a>
<a name="SEC79"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC78" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC75" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.2.4 Known bugs and limitations </h3>

<ul class="toc">
<li>
Reflection finds the original, uninstrumented code, and so DynComp may
not accurately instrument code that uses reflection.
</li><li>
Instrumentation of the <code>clone()</code> method may fail on particular
invocations within private classes in the JDK.
</li></ul>


<hr size="6">
<a name="Kvasir"></a>
<a name="SEC80"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC79" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC81" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.3 C/C++ front end Kvasir </h2>


<p>Daikon's front end for C and C++, named Kvasir, executes C and C++
programs and creates
data trace (&lsquo;<tt>.dtrace</tt>&rsquo;) files of variables and their values by
examining the operation of the binary at
runtime.  Kvasir is named after the Norse god of knowledge and beet juice.
It is built upon the Fjalar dynamic analysis framework for C and C++ programs
(available at <a href="http://pag.csail.mit.edu/fjalar/">http://pag.csail.mit.edu/fjalar/</a>, but already
included in the Daikon distribution).
</p>
<p>To use Kvasir, first compile your program using the DWARF-2 debugging
format (e.g., supply the &lsquo;<samp>-gdwarf-2</samp>&rsquo; option to <code>gcc</code>) and
without optimizations (e.g., supply the &lsquo;<samp>-O0</samp>&rsquo; option to <code>gcc</code>).
Then, prefix your command line by <code>kvasir-dtrace</code>.  For example,
if you normally run your program with the command
</p><table><tr><td>&nbsp;</td><td><pre class="example">./program -option input.file
</pre></td></tr></table>
<p>then instead use the command
</p><table><tr><td>&nbsp;</td><td><pre class="example">kvasir-dtrace ./program -option input.file
</pre></td></tr></table>
<p>to run your program and create a data trace file
&lsquo;<tt>daikon-output/program.dtrace</tt>&rsquo;, which can be fed as input into
Daikon.  You can perform this step multiple times to create multiple
data trace files for Daikon.
You can also run Daikon without creating an intermediate data trace
file; see <a href="#SEC90">Online execution</a>.
</p>
<p>For information about installing Kvasir, see <a href="#SEC92">Installing Kvasir</a>.
Kvasir only works under Linux running on an x86 or x86-64 processor; for full
details, see <a href="#SEC93">Kvasir implementation and limitations</a>.
For information about how to create an instrumenter for C that works on
non-Linux or non-x86 platforms, see <a href="..//Instrumenting-C-programs.html#Instrumenting-C-programs">(./developer)Instrumenting C programs</a> section `Instrumenting C programs' in <cite>Daikon Developer Manual</cite>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC81">7.3.1 Using Kvasir</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC82">7.3.2 Kvasir options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC83">7.3.3 DynComp dynamic comparability (abstract type) analysis for C/C++</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC84">7.3.4 Tracing only part of a program</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC85">7.3.5 Pointer type disambiguation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC89">7.3.6 C++ support</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC90">7.3.7 Online execution</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC92">7.3.8 Installing Kvasir</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC93">7.3.9 Kvasir implementation and limitations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          
</td></tr>
</table>

<hr size="6">
<a name="Using-Kvasir"></a>
<a name="SEC81"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC80" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC82" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.3.1 Using Kvasir </h3>

<p>Before using Kvasir, you must compile your program compile and link your
program normally, with two exceptions:
</p><ul class="toc">
<li>
Do not use optimization.  Remove 
any optimization flags, such as &lsquo;<samp>-O</samp>&rsquo; or &lsquo;<samp>-O2</samp>&rsquo;,
and any flags that affect calling conventions, such as
&lsquo;<samp>-fomit-frame-pointer</samp>&rsquo;.
</li><li>
Include debugging information, by supplying the &lsquo;<samp>-g</samp>&rsquo; flag.
The debugging information must be in the DWARF-2 format.
DWARF-2 is the default format for debugging information in GCC 3 and later, and
otherwise is produced by supplying the &lsquo;<samp>-gdwarf-2</samp>&rsquo; command line option.
</li></ul>

<p>In the second step of using Kvasir, run your program as you normally
would, but prepend the command <code>kvasir-dtrace</code> to the beginning.
For instance, if you normally run your program with the command
</p><table><tr><td>&nbsp;</td><td><pre class="example">./myprogram -option input.file
</pre></td></tr></table>
<p>just say
</p><table><tr><td>&nbsp;</td><td><pre class="example">kvasir-dtrace ./myprogram -option input.file
</pre></td></tr></table>
<p>As well as running your program (more slowly than usual), this command
also creates a directory &lsquo;<tt>daikon-output</tt>&rsquo; in the current
directory containing a &lsquo;<tt>program.dtrace</tt>&rsquo; file suitable as input to Daikon.
</p>
<p>Kvasir's first argument, the program name, should be given as a
pathname, as shown above.  If you usually just give a program name that
is not in the current directory but is found in your path, you may need
to modify your command to specify a pathname.  For example:
</p><table><tr><td>&nbsp;</td><td><pre class="example">kvasir-dtrace `which myprogram` -option input.file
</pre></td></tr></table>

<p>You may supply options to Kvasir
before the argument that is the name of your program (see section <a href="#SEC82">Kvasir options</a>).
</p>

<hr size="6">
<a name="Kvasir-options"></a>
<a name="SEC82"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC81" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC83" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.3.2 Kvasir options </h3>

<p>To see a complete list of options, run this command: <code>kvasir-dtrace --help</code>
</p>
<p>Output file format:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>--decls-file=<var>filename</var></samp>&rsquo;</dt>
<dd>
<p>Write the &lsquo;<tt>.decls</tt>&rsquo; file listing the names of functions and
variables (called declarations) to the specified file name.  This forces
Kvasir to generate separate
&lsquo;<tt>.decls</tt>&rsquo; and &lsquo;<tt>.dtrace</tt>&rsquo; files instead of outputting everything to the
&lsquo;<tt>.dtrace</tt>&rsquo; file, which is the default behavior.  If only a &lsquo;<tt>.dtrace</tt>&rsquo; file is
created (default behavior), then it contains both variable declarations and a trace of
values.  If separate &lsquo;<tt>.decls</tt>&rsquo; and &lsquo;<tt>.dtrace</tt>&rsquo; files are created,
then the &lsquo;<tt>.decls</tt>&rsquo; file contains declarations and the &lsquo;<tt>.dtrace</tt>&rsquo;
file contains the trace of values.
</p>
</dd>
<dt> &lsquo;<samp>--decls-only</samp>&rsquo;</dt>
<dd>
<p>Exit after writing the &lsquo;<tt>.decls</tt>&rsquo; file; don't run the program or
generate trace information.  Since the &lsquo;<tt>.decls</tt>&rsquo; file is the same for
any run of a program, it can be generated once and then reused on later
runs, as long as no new program points are added and each program point
has the same set of variables.
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-file=<var>filename</var></samp>&rsquo;</dt>
<dd>
<p>Write the &lsquo;<tt>.dtrace</tt>&rsquo; trace file to the specified file name.  The default is
&lsquo;<tt>daikon-output/<var>programname</var>.dtrace</tt>&rsquo;, where <var>programname</var>
is the name of the program.  A filename of &lsquo;<tt>-</tt>&rsquo; may be used to
specify the standard output; in this case, the regular standard output
of the program will be redirected back to the terminal (&lsquo;<tt>/dev/tty</tt>&rsquo;), to avoid
intermixing it with the trace output.  If the given filename ends in
&lsquo;<tt>.gz</tt>&rsquo;, then &lsquo;<samp>--dtrace-gzip</samp>&rsquo; is enabled and the
&lsquo;<tt>.dtrace</tt>&rsquo; file will be compressed.
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-no-decs</samp>&rsquo;</dt>
<dd>
<p>By default, the &lsquo;<tt>.dtrace</tt>&rsquo; file contains both a list of variable
declarations followed by a trace of variable values (see <a href="..//File-formats.html#File-formats">(./developer)File formats</a> section `File formats' in <cite>Daikon Developer Manual</cite>).  If this option is used, then variable declarations are not
outputted in the .dtrace file.  This option is equivalent to
&lsquo;<samp>--decls-file=/dev/null</samp>&rsquo;, except that it runs faster.  This is
useful when you want to generate one copy of the declarations in the
.decls file using &lsquo;<samp>--decls-only</samp>&rsquo;, generate many
&lsquo;<tt>.dtrace</tt>&rsquo; files from different program runs, and then feed 1
&lsquo;<tt>.decls</tt>&rsquo; and several &lsquo;<tt>.dtrace</tt>&rsquo; files into Daikon.
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-append</samp>&rsquo;</dt>
<dd>
<p>Append new trace information to the end of an existing &lsquo;<tt>.dtrace</tt>&rsquo;
file.  The default is to overwrite a pre-existing &lsquo;<tt>.dtrace</tt>&rsquo; file.
When this option is used, no declaration information is written because
it is assumed that the existing .dtrace file already contains all
declarations (Daikon does not accept duplicate declarations).
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-gzip</samp>&rsquo;</dt>
<dd>
<p>Compress trace information with the gzip program before writing
it to the &lsquo;<tt>.dtrace</tt>&rsquo; file.  You must have the gzip program
available.
</p>
</dd>
<dt> &lsquo;<samp>--output-fifo</samp>&rsquo;</dt>
<dd>
<p>Create the output &lsquo;<tt>.dtrace</tt>&rsquo; file as a FIFO (also
known as a &ldquo;named pipes&rdquo;).  Kvasir will then open first the &lsquo;<tt>.decls</tt>&rsquo;
FIFO and then the &lsquo;<tt>.dtrace</tt>&rsquo; FIFO, blocking until another program
(such as Daikon) reads from them.  Using FIFOs for the output of Kvasir
avoids the need for large trace files, but FIFOs are not supported by
some file systems, including AFS.
</p>
</dd>
<dt> &lsquo;<samp>--program-stdout=<var>filename</var></samp>&rsquo;</dt>
<dt> &lsquo;<samp>--program-stderr=<var>filename</var></samp>&rsquo;</dt>
<dd>
<p>Redirect the standard output (respectively, standard error) stream of the
program being traced to the specified path.  By default, the standard
output and standard error streams will be left pointing to the same
locations specified by the shell, except that if &lsquo;<samp>--dtrace-file=-</samp>&rsquo;
is specified, then the default behavior is as if
&lsquo;<samp>--program-stdout=/dev/tty</samp>&rsquo; were specified, since mixing the
program's output and Kvasir's trace output is not advisable.
If the same filename is given for both options, the streams will be
interleaved in the same way as if by the Bourne shell construction
<code>2&gt;&amp;1</code>.
</p>
<p>Also, as in the shell, <var>filename</var> can be an ampersand followed by an
integer, to redirect to a numbered file descriptor.  For instance, to
redirect the program's standard output and error, and Kvasir's standard
error, to a single file, you can say &lsquo;<samp>--program-stdout='&amp;2'
--program-stderr='&amp;2' 2&gt;<var>filename</var></samp>&rsquo;.
</p>
</dd>
</dl>

<p>Selective program point and variable tracing:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>--ppt-list-file=<var>filename</var></samp>&rsquo;</dt>
<dt> &lsquo;<samp>--var-list-file=<var>filename</var></samp>&rsquo;</dt>
<dd>
<p>Trace only the program points (respectively, variables) listed in the
given file.  Other program points (respectively variables) will be
omitted from the &lsquo;<tt>.decls</tt>&rsquo; and &lsquo;<tt>.dtrace</tt>&rsquo; files.  A convenient
way to produce such files is by editing the output produced by the
&lsquo;<samp>--dump-ppt-file</samp>&rsquo; (respectively, &lsquo;<samp>--dump-var-file</samp>&rsquo;) option
described below.  (see section <a href="#SEC84">Tracing only part of a program</a> section
for detailed instructions on using these options.)
</p>
</dd>
<dt> &lsquo;<samp>--dump-ppt-file=<var>filename</var></samp>&rsquo;</dt>
<dt> &lsquo;<samp>--dump-var-file=<var>filename</var></samp>&rsquo;</dt>
<dd>
<p>Print a list of all the program points (respectively all the variables)
in the program to the specified file.  An edited version of this file can
then be used with the &lsquo;<samp>--ppt-list-file</samp>&rsquo; (respectively
&lsquo;<samp>--var-list-file</samp>&rsquo;) option.
(see section <a href="#SEC84">Tracing only part of a program</a> section
for detailed instructions on using these options.)
Note: Do not use these options with the
&lsquo;<samp>--with-dyncomp</samp>&rsquo; option because the behavior is undefined.
Running Kvasir with these
options will initialize but not actually execute the target program, so
the dynamic comparability analysis cannot be performed in the first
place.
</p>
</dd>
<dt> &lsquo;<samp>--ignore-globals</samp>&rsquo;</dt>
<dd>
<p>Omit any global or static variables from the &lsquo;<tt>.decls</tt>&rsquo; and
&lsquo;<tt>.dtrace</tt>&rsquo; files.  Leaving these out can significantly improve Kvasir
and Daikon's performance, at the expense of missing properties involving
them.  The default is to generate trace information for
global and static variables.
</p>
</dd>
<dt> &lsquo;<samp>--ignore-static-vars</samp>&rsquo;</dt>
<dd>
<p>Omit any static variables but generate trace information for
global variables in the  &lsquo;<tt>.decls</tt>&rsquo; and &lsquo;<tt>.dtrace</tt>&rsquo; files.
</p>
</dd>
<dt> &lsquo;<samp>--all-static-vars</samp>&rsquo;</dt>
<dd>
<p>Output all static variables at all program points in the &lsquo;<tt>.decls</tt>&rsquo; and
&lsquo;<tt>.dtrace</tt>&rsquo; files.  By default, file-static variables are only outputted at
program points for functions that are defined in the same file (compilation unit)
as the
variable, and static variables declared within a particular function are
only outputted at program points for that function.  These heuristics decrease
clutter in the output without greatly reducing precision because functions
have no easy way of modifying variables that are not in-scope, so it is often
not useful to output those variables.  This option turns off these heuristics
and always outputs static variables at all program points.
</p>
</dd>
</dl>

<p>Other options affecting the amount of output Kvasir produces:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>--object-ppts</samp>&rsquo;</dt>
<dd><p>Enables printing of object program points for C/C++ structs and C++
classes. See <a href="daikon_5.html#SEC36">Program points</a> for more information.
</p>
</dd>
<dt> &lsquo;<samp>--flatten-arrays</samp>&rsquo;</dt>
<dd><p>This option forces the flattening of statically-sized arrays into
separate variables, one for each element.  For example, an array
<var>foo</var> of size 3 would be flattened into 3 variables: <var>foo[0]</var>,
<var>foo[1]</var>, <var>foo[2]</var>.  By default, Kvasir flattens
statically-sized arrays only after it has already exhausted the one
level of sequences that Daikon allows in the .dtrace output format
(e.g. an array of structs where each struct contains a statically-sized
array).
</p>
</dd>
<dt> &lsquo;<samp>--array-length-limit=<var>N</var></samp>&rsquo;</dt>
<dd><p>Only visit at most the first <var>N</var> elements of all arrays.  This can
improve performance at the expense of losing coverage; it is often
useful for tracing selected parts of programs that use extremely large
arrays or memory buffers.
</p>
</dd>
<dt> &lsquo;<samp>--output-struct-vars</samp>&rsquo;</dt>
<dd><p>This option forces Kvasir to output .decls and .dtrace entries for
struct variables.  By default, Kvasir ignores struct variables because
there is really no value that can be meaningfully associated with these
variables.  However, some tools require struct variables to be
outputted, so we have included this option.  Struct variables are
denoted by a <code># isStruct=true</code> annotation in their declarations.
</p>
</dd>
<dt> &lsquo;<samp>--nesting-depth=<var>N</var></samp>&rsquo;</dt>
<dd>
<p>For recursively-defined structures (structs or classes with members that
are structs or classes or pointers to structs or classes of <em>any</em> type),
<var>N</var> (an integer between 0 and 100) specifies approximately how many levels
of pointers to dereference.  This is useful for controlling the output
of complex data structures with many references to other structures.
The default is 2.
</p>
</dd>
<dt> &lsquo;<samp>--struct-depth=<var>N</var></samp>&rsquo;</dt>
<dd>
<p>For recursively-defined structures (structs or classes with members that
are pointers to the <em>same</em> type of struct or class),
<var>N</var> (an integer between
0 and 100) specifies approximately how many levels of pointers to dereference.
This is useful for controlling the output of linked lists and trees.
The default is 4.  If you are trying to traverse deep into data
structures, try adjusting the &lsquo;<samp>--struct-depth</samp>&rsquo; and
&lsquo;<samp>--total-depth</samp>&rsquo; options until Kvasir traverses deep enough to
reach the desired variables.
</p>
</dd>
</dl>

<p><a href="#SEC85">Pointer type disambiguation</a>:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>--disambig-file=<var>filename</var></samp>&rsquo;</dt>
<dd><p>Specifies the name of the pointer type disambiguation file
(see section <a href="#SEC85">Pointer type disambiguation</a>).
If this file exists, Kvasir uses it to make decisions about how
to output the referents of pointer variables.  If the file does not exist,
then Kvasir creates it.  This file may then be edited and used on
subsequent runs.  This option initializes but does not fully execute the
target program (unless it is run with the &lsquo;<samp>--smart-disambig</samp>&rsquo;
option).
</p>
</dd>
<dt> &lsquo;<samp>--disambig</samp>&rsquo;</dt>
<dd><p>Tells Kvasir to create or read pointer type disambiguation
(see section <a href="#SEC85">Pointer type disambiguation</a>) with the default filename,
which is &lsquo;<tt><var>myprog</var>.disambig</tt>&rsquo; in the same
directory as the target program, where <var>myprog</var> is the name of the
target program.  This is equivalent to
&lsquo;<samp>--disambig-file=&lsquo;<tt><var>myprog</var>.disambig</tt>&rsquo;</samp>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--smart-disambig</samp>&rsquo;</dt>
<dd><p>This option should be used in addition to either the &lsquo;<samp>--disambig</samp>&rsquo;
or &lsquo;<samp>--disambig-file</samp>&rsquo; options (it does nothing by itself).  If the
.disambig file specified by the option does not exist, then Kvasir
executes the target program, observes whether each pointer refers to
either one element or an array of elements, and creates a disambiguation
file that contains suggestions for the disambiguation types of each
pointer variable.  This potentially provides more accuracy than using
either the &lsquo;<samp>--disambig</samp>&rsquo; or &lsquo;<samp>--disambig-file</samp>&rsquo; options alone,
but at the expense of a longer run time.  (If the .disambig file already
exists, then this option provides no extra functionality.)
</p>
</dd>
<dt> &lsquo;<samp>--func-disambig-ptrs</samp>&rsquo;</dt>
<dd><p>By default, Kvasir treats all pointers as arrays when outputting their
contents.  This option forces Kvasir to treat function parameters and
return values that are pointers as pointing to single values.  However,
all pointers nested inside of data structures pointed-to by parameters
and return values are still treated as arrays.  This is useful for
outputting richer data information for functions that pass parameters or
return values via pointers, which happens often in practice.
</p>
</dd>
<dt> &lsquo;<samp>--disambig-ptrs</samp>&rsquo;</dt>
<dd><p>By default, Kvasir treats all pointers as arrays when outputting their
contents.  This option forces Kvasir to treat all pointers as pointing to
single values.  This is useful when tracing nested structures with lots
of pointer fields which all refer to one element.
</p>
</dd>
</dl>

<p><a href="#SEC83">DynComp dynamic comparability (abstract type) analysis for C/C++</a>:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>--with-dyncomp</samp>&rsquo;</dt>
<dd>
<p>Run Kvasir with the DynComp dynamic
comparability analysis tool to determine which variables have the same
abstract type.
Variable comparability information can
improve the performance of Daikon and allow it to generate a more
focused and relevant set of invariants.
Because it is not available until the end of execution, comparability
information is always written to a separate &lsquo;<tt>.decls</tt>&rsquo; file (in the
format specified in the <a href="..//Program-point-declarations.html#Program-point-declarations">(./developer)Program point declarations</a> section `Program point declarations' in <cite>Daikon Developer Manual</cite> section), as if
the &lsquo;<samp>--decls-file</samp>&rsquo; option had been specified
(&lsquo;<samp>--decls-file</samp>&rsquo; can still be used to control the name of the
file).
This file must be provided to Daikon along with the &lsquo;<tt>.dtrace</tt>&rsquo;
file.
This option may also be used with &lsquo;<samp>--decls-only</samp>&rsquo; to only generate
a &lsquo;<tt>.decls</tt>&rsquo; file without a &lsquo;<tt>.dtrace</tt>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--no-dyncomp-gc</samp>&rsquo;</dt>
<dd>
<p>By default, DynComp runs with a garbage collector for the tag metadata
that it uses, but this can cause your program to slow down if it runs
too often.  This option turns off the garbage collector.  This is not
recommended for long program runs, because without the garbage
collector, it will likely run out of memory.
</p>
</dd>
<dt> &lsquo;<samp>--gc-num-tags=<var>N</var></samp>&rsquo;</dt>
<dd>
<p>The DynComp garbage collector runs once after every 10,000,000 tags have
been assigned.  This option tells the garbage collector to run once
after every <var>N</var> tags have been assigned.  Making the value of
<var>N</var> larger allows your program to run faster (because the garbage
collector runs less frequently), but may cause your program to run out
of memory as well.  Making the value of <var>N</var> too small may cause your
program to never terminate if <var>N</var> is smaller than the total number
of tags that your program uses in steady state.  You will probably need
to experiment with tweaking this value in order to get DynComp to work
properly.
</p>
</dd>
<dt> &lsquo;<samp>--dyncomp-fast-mode</samp>&rsquo;</dt>
<dd>
<p>This option applies an approximation for handling literal values which
greatly speeds up the performance of DynComp and drastically lowers its
memory usage, but at the expense of a slight loss in precision of the
generated comparability sets.  If you cannot get DynComp to successfully
run on a large program, even after tweaking &lsquo;<samp>--gc-num-vars</samp>&rsquo;, try
turning on this option.
</p>
</dd>
<dt> &lsquo;<samp>--dyncomp-detailed-mode</samp>&rsquo;</dt>
<dd>
<p>This option runs a more detailed (but more time- and space-intensive)
algorithm for tracking variable comparability.  It takes O(n^2) time and
space, whereas the default algorithm takes roughly O(n) time and space.
However, it can produce more precise results.  Despite its name, this
mode can be used together with &lsquo;<samp>--dyncomp-fast-mode</samp>&rsquo; to run the
more precise algorithm but still use an approximation for handling
literal values.  (This mode is still experimental and not well-tested
yet.)
</p>
</dd>
<dt> &lsquo;<samp>--separate-entry-exit-comp</samp>&rsquo;</dt>
<dd>
<p>The default behavior for DynComp is to generate the same comparability
numbers for Daikon variables at each pair of function entrance and exit
program points.  If this option is used, then DynComp keeps track of
comparability separately for function entrances and exits, which can
lead to more accurate results, but sometimes generates output .decls
files that Daikon cannot accept.
</p>
</dd>
<dt> &lsquo;<samp>--dyncomp-dataflow-only</samp>&rsquo;</dt>
<dd>
<p>When DynComp is operating in this mode, no binary operations qualify as
interactions between values.  Thus, DynComp only tracks dataflow.
</p>
</dd>
<dt> &lsquo;<samp>--dyncomp-dataflow-comp</samp>&rsquo;</dt>
<dd>
<p>When DynComp is operating in this mode, the only binary operations that
qualify as interactions are comparisons between values (e.g., <code>x &lt;=
y</code> or <code>x != y</code>).
</p>
</dd>
<dt> &lsquo;<samp>--dyncomp-units</samp>&rsquo;</dt>
<dd>
<p>When DynComp is operating in this mode, the only binary operations that
qualify as interactions are comparisons, addition, subtraction.
This ensures that the variables that DynComp groups together into one
set all have the same units (e.g., physics units).
</p>
</dd>
</dl>

<p>Debugging:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>--xml-output-file=<var>filename</var></samp>&rsquo;</dt>
<dd>
<p>Outputs a representation of data structures, functions, and variables in
the target program to an XML file in order to aid in debugging.  These
are all the entities that Kvasir tracks for a particular run of a target
program, so if you do not see an entity in this XML file, then you
should either adjust command-line options or contact us with a bug
report.
</p>
</dd>
<dt> &lsquo;<samp>--with-gdb</samp>&rsquo;</dt>
<dd>
<p>This pauses the program's execution in an infinite loop during
initialization.  You can attach a debugger such as <code>gdb</code> to the
running process by running gdb on &lsquo;<tt>inst/lib/valgrind/x86-linux/fjalar</tt>&rsquo; under
the Kvasir directory and using the <code>attach</code> command.
</p>
</dd>
<dt> &lsquo;<samp>--kvasir-debug</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--fjalar-debug</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--dyncomp-debug</samp>&rsquo;</dt>
<dd>
<p>Enable progress messages meant for debugging problems with Kvasir, Fjalar, or
DynComp.  By default, they are disabled.  This option is intended mainly
for Kvasir's developers.
</p>
</dd>
<dt> &lsquo;<samp>--no-path-compression</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--no-var-leader</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--no-val-leader</samp>&rsquo;</dt>
<dd>
<p>These disable optimizations to Dyncomp's abstract type inference 
implementation. These are disabled by default. These options are
intended mainly for Dyncomp developers.
</p>
</dd>
<dt> &lsquo;<samp>--dyncomp-trace</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--dyncomp-trace-merge</samp>&rsquo;</dt>
<dt> &lsquo;<samp>-- dyncomp-print-inc</samp>&rsquo;</dt>
<dd>
<p>Enables trace messages to be output to stderr. These are disabled by
default. These options are intended mainly for Dyncomp developers.
</p>
</dd>
<dt> &lsquo;<samp>--gcc3</samp>&rsquo;</dt>
<dd>
<p>Experimental option. This option improves Kvasir's support for GCC 3.x 
created binaries. This option is fairly untested, but may be useful
for anyone attempting to run Kvasir on GCC 3.x created binaries. We
recommend the use of GCC 4.1 for creating binaries for use
with Kvasir. See <a href="#SEC93">Kvasir implementation and limitations</a> for 
more information.
</p>
</dd>
</dl>

<hr size="6">
<a name="DynComp-for-C_002fC_002b_002b"></a>
<a name="SEC83"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC82" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC84" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.3.3 DynComp dynamic comparability (abstract type) analysis for C/C++ </h3>


<p>Kvasir comes with the DynComp dynamic comparability analysis tool, which
performs dynamic type inference to group variables at each program point
into comparability sets (see <a href="..//Program-point-declarations.html#Program-point-declarations">(./developer)Program point declarations</a> section `Program point declarations' in <cite>Daikon Developer Manual</cite> for the
numeric representation format of these sets).  All variables in each
comparability set belong to the same &ldquo;abstract type&rdquo; of data that the
programmer likely intended to represent, which is a richer set of types
than the few basic declared types (e.g., int, float) provided by the
language.  Consider the example below:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">int main() {
  int year = 2005;
  int winterDays = 58;
  int summerDays = 307;
  compute(year, winterDays, summerDays);
}

int compute(int yr, int d1, int d2) {
  if (yr % 4)
    return d1 + d2;
  else
    return d1 + d2 + 1;
}
</pre></td></tr></table>

<p>The three variables in <code>main()</code> all have the same C representation
type, <code>int</code>, but two of them hold related quantities (numbers of
days), as can be determined by the fact that they interact when the
program adds them, whereas the other contains a conceptually distinct
quantity (a year).  The abstract types 'day' and 'year' are both
represented as <code>int</code>, but DynComp can differentiate them with its
dynamic analysis.  For example, DynComp can infer that <code>winterDays</code>
and <code>summerDays</code> are comparable (belong to the same abstract type)
because the program adds their values together within the
<code>compute()</code> function.
</p>
<p>Without comparability information, Daikon attempts to find invariants
over all pairs (and sometimes triples) of variables present at every
program point.  This can lead to two negative consequences: First, it
may take lots of time and memory to infer all of these invariants,
especially when there are many global or derived variables present.
Second, many of those invariants are true but meaningless because they
relate variables which conceptually represent different types (e.g., an
invariant such as <code>winterDays &lt; year</code> is true but meaningless
because days and years are not comparable).
</p>
<p>Use the &lsquo;<samp>--with-dyncomp</samp>&rsquo; option to run Kvasir with DynComp to
generate a &lsquo;<tt>.decls</tt>&rsquo; file with comparability information along with
the usual value trace in the &lsquo;<tt>.dtrace</tt>&rsquo; file.  Using
&lsquo;<samp>--decls-only</samp>&rsquo; will only generate the &lsquo;<tt>.decls</tt>&rsquo; file without
the extra slowdown of writing the &lsquo;<tt>.dtrace</tt>&rsquo; file to disk (however,
because DynComp must execute the entire program to perform its analysis,
the only time saved is I/O time).  Other DynComp options are listed in
the <a href="#SEC82">Kvasir options</a> section.  Running Kvasir with DynComp takes
more memory and longer time than running Kvasir alone, but remember that
DynComp only needs to be run once to generate a &lsquo;<tt>.decls</tt>&rsquo; file with
comparability information.  That one file can be passed into Daikon along
with many different &lsquo;<tt>.dtrace</tt>&rsquo; files generated during subsequent
Kvasir runs without DynComp.
</p>
<p>Here is part of the &lsquo;<tt>.decls</tt>&rsquo; file generated by running Kvasir with
DynComp on the above example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">DECLARE
..compute():::ENTER
yr
int # isParam=true
int
1
d1
int # isParam=true
int
2
d2
int # isParam=true
int
2

DECLARE
..compute():::EXIT0
yr
int # isParam=true
int
1
d1
int # isParam=true
int
2
d2
int # isParam=true
int
2
return
int
int
2
</pre></td></tr></table>

<p>The abstract type of 'year' (and its corresponding comparability set) is
represented by the number 1 while the abstract type of 'day' is
represented by the number 2.  DynComp places two variables in the same
comparability set when their values interact via program operations such
as arithmetic or assignment.  Because the parameters <code>d1</code> and
<code>d2</code> were added together, DynComp inferred that those variables
were somehow related and put them in the same comparability set.  The
return value is also related to <code>d1</code> and <code>d2</code> because it is
the result of the addition operation.  Notice that <code>yr</code> never
interacts with any other variables, so DynComp places it into its own
comparability set.  With this comparability information, Daikon will
never attempt to find invariants between <code>yr</code> and
<code>d1</code>/<code>d2</code>, which both saves time and memory and eliminates
meaningless invariants (the savings are miniscule in this trivial
example, but they can be rather dramatic in larger examples).
</p>
<hr size="6">
<a name="Tracing-only-part-of-a-program"></a>
<a name="SEC84"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC83" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC85" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.3.4 Tracing only part of a program </h3>

<p>When Kvasir is run on a target program of significant size, often times
too much output is generated, which causes an enormous performance
slowdown of both Kvasir outputting the trace file and also Daikon trying
to process the trace file.  It is often desirable to only trace a
specific portion of the target program, program points and variables
that are of interest for a particular invariant detection application.
For instance, one may only be interested in tracking changes in a
particular global data structure during calls to a specific set of
functions (program points), and thus have no need for information about
any other program points or variables in the trace file.  The
&lsquo;<samp>--ppt-list-file</samp>&rsquo; and &lsquo;<samp>--var-list-file</samp>&rsquo; options can be
used to achieve such selective tracing.
</p>
<p>The program point list file (abbreviated as &lsquo;<tt>ppt-list-file</tt>&rsquo;)
consists of a newline-separated list of names of functions that the
user wants Kvasir to trace.  Every name corresponds to both the entrance
(<code>:::ENTER</code>) and exit (<code>:::EXIT</code>) program points for that function
and is printed out in the exact same format that Kvasir
uses for that function in the trace file (see section <a href="#SEC81">Using Kvasir</a>
section for the program point naming scheme).  Here is an
example of a &lsquo;<tt>ppt-list-file</tt>&rsquo;:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">FunctionNamesTest.cpp.staticFoo(int, int)
..firstFileFunction(int)
..main()
second_file.cpp.staticFoo(int, int)
..secondFileFunction()
</pre></td></tr></table>

<p>It is very important to follow this format in the &lsquo;<tt>ppt-list-file</tt>&rsquo;
because Kvasir performs string comparisons to determine which program
points to trace.  Thus, it is often easier to have Kvasir generate a
&lsquo;<tt>ppt-list-file</tt>&rsquo; file that contains a list of all program points in a
target program by using the &lsquo;<samp>--dump-ppt-file</samp>&rsquo; option, and then
either comment out (by using the <code>'#'</code> comment character at the
beginning of the line) or delete lines in that file for program points
not to be traced or create a new &lsquo;<tt>ppt-list-file</tt>&rsquo; using the names in
the Kvasir-generated file.  This prevents typos and the tedium of
manually typing up program point names.  In fact, the &lsquo;<tt>ppt-list-file</tt>&rsquo;
presented in the above example was generated from a C++ test program named
<code>FunctionNamesTest</code> by using the following command:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">kvasir-dtrace --dump-ppt-file=FunctionNamesTest.ppts  ./FunctionNamesTest
</pre></td></tr></table>

<p>That file represents all the program points that Kvasir would
normally trace.  If the user wanted to only trace the <code>main()</code>
function, he could comment out all other lines by placing a single
<code>'#'</code> character at the beginning of each line to be commented out,
as demonstrated here:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">#FunctionNamesTest.cpp.staticFoo(int, int)
#..firstFileFunction(int)
..main()
#second_file.cpp.staticFoo(int, int)
#..secondFileFunction()
</pre></td></tr></table>
<p>When running Kvasir with the &lsquo;<samp>--ppt-list-file</samp>&rsquo; option using this
as the &lsquo;<tt>ppt-list-file</tt>&rsquo;, Kvasir only stops the execution of the target program at the
entrance and exit of <code>main()</code> in order to output values to the
.dtrace file.  In order to reduce the file size, when running Kvasir
with the &lsquo;<samp>--ppt-list-file</samp>&rsquo; option, the .decls file only contains
program point declarations for those listed in the &lsquo;<tt>ppt-list-file</tt>&rsquo;
(<code>..main():::ENTER</code> and <code>..main():::EXIT</code> in this case) because
no other declarations are necessary.
</p>
<p>The variable list file (abbreviated as &lsquo;<tt>var-list-file</tt>&rsquo;) contains
all of the variables that the user wants Kvasir to output.  There is one
section for global variables and a section for variables associated with
each function (formal parameters and return values).  Again, the best way to
create a &lsquo;<tt>var-list-file</tt>&rsquo; is to have Kvasir generate a file with all
variables using the &lsquo;<samp>--dump-var-file</samp>&rsquo; option and then modifying
that file for one's particular needs by either deleting or
commenting out lines (again using the <code>'#'</code> comment character).  For example,
executing
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">kvasir-dtrace --dump-var-file=FunctionNamesTest.vars  ./FunctionNamesTest
</pre></td></tr></table>

<p>will generate the following &lsquo;<tt>var-list-file</tt>&rsquo; named
<code>FunctionNamesTest.vars</code>:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">----SECTION----
globals
/globalIntArray
/globalIntArray[]
/anotherGlobalIntArray
/anotherGlobalIntArray[]


----SECTION----
FunctionNamesTest.cpp.staticFoo()
x
y


----SECTION----
..firstFileFunction(int)
blah


----SECTION----
..main()
argc
argv
argv[]
return


----SECTION----
second_file.cpp.staticFoo()
x
y


----SECTION----
..secondFileFunction()
</pre></td></tr></table>

<p>The file format is straightforward.  Each section is marked by a
special string &ldquo;<code>----SECTION----</code>&rdquo; on a line by itself followed
immediately by a line that either denotes the program point name
(formatted like how it appears in the .decls and .dtrace files) or the
special string &ldquo;<code>globals</code>&rdquo;.  This is followed by a
newline-delimited list of all variables to be outputted for that
particular program point.  Global variables listed in the
<code>globals</code> section are outputted for all program points. Additional global
variables to be outputted for a particular program point can be specified
in the corresponding section entry. For clarity, one or more blank lines 
should separate neighboring sections, although the &ldquo;<code>----SECTION----</code>&rdquo; 
string literal on a line by itself is the only required delimiter.  
If an entire section is missing, then no variables for that program point 
(or no global variables, if it is the special globals section) are traced.
</p>
<p>The variables listed in this file are written exactly as they appear in
the .decls and .dtrace file (see section <a href="#SEC81">Using Kvasir</a> section
for the variable naming scheme).  In the program that generated the
output for the above example, <code>int*
globalIntArray</code> is a global integer pointer variable.  For that
variable, Kvasir generates two Daikon variables: <code>/globalIntArray</code>
to represent the hashcode pointer value, and <code>/globalIntArray[]</code> to
represent the array of integers referred-to by that pointer.  The
latter is a derived-variable that can be thought of as the child of
<code>/globalIntArray</code>.  If the entry for <code>/globalIntArray</code> is
commented-out or missing, then Kvasir will not output any values for
<code>/globalIntArray</code> or for any of its children, which in this case is
<code>/globalIntArray[]</code>.  If a struct or struct pointer variable is
commented-out or missing, then none of its members are traced.  Thus, a
general rule about variable entries in the &lsquo;<tt>var-list-file</tt>&rsquo; is that
if a parent variable is not present, then neither it nor its children
are traced.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
record
record-&gt;entries[1]
record-&gt;entries[1]-&gt;list
record-&gt;entries[1]-&gt;list-&gt;head
record-&gt;entries[1]-&gt;list-&gt;head-&gt;magic

</pre></td></tr></table>

<p>For example, if you wanted to trace the value of the <code>magic</code> field
nested deep within several layers of structs and arrays, it would not be
enough to merely list this variable in the &lsquo;<tt>var-list-file</tt>&rsquo;.  You
would need to list all variables that are the parents of this one, as
indicated by their names.  This can be easily accomplished by creating a
file with &lsquo;<samp>--dump-var-file</samp>&rsquo; and cutting out variable entries,
taking care to not cut out entries that are the parents of entries that
you want to trace.
</p>
<p>In order to limit both the number of program points traced as well as
the variables traced at those program points, the user can run Kvasir
with both the &lsquo;<samp>--ppt-list-file</samp>&rsquo; and &lsquo;<samp>--var-list-file</samp>&rsquo;
options with the appropriate &lsquo;<tt>ppt-list-file</tt>&rsquo; and
&lsquo;<tt>var-list-file</tt>&rsquo;, respectively.  The &lsquo;<tt>var-list-file</tt>&rsquo; only needs
to contain a section for global variables and sections for all program
points to be traced because variable listings for program points not to
be traced are irrelevant (their presence in the &lsquo;<tt>var-list-file</tt>&rsquo;
does not affect correctness but does cause an unnecessary
performance and memory inefficiency).
</p>
<p>If the &lsquo;<samp>--dump-var-file</samp>&rsquo; option is used in conjunction with the
&lsquo;<samp>--ppt-list-file</samp>&rsquo; option, then the only sections generated in the
&lsquo;<tt>var-list-file</tt>&rsquo; will be the global section and sections for all
program points explicitly mentioned in the &lsquo;<tt>ppt-list-file</tt>&rsquo;.  This
is helpful for generating a smaller &lsquo;<tt>var-list-file</tt>&rsquo; for use with an
already-existent &lsquo;<tt>ppt-list-file</tt>&rsquo;.
</p>
<hr size="6">
<a name="Pointer-type-disambiguation"></a>
<a name="SEC85"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC84" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC86" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.3.5 Pointer type disambiguation </h3>


<p>Kvasir permits users (or external analyses) to specify whether pointers
refer to arrays or to single values, and optionally, to specify the type
of a pointer (see section <a href="#SEC86">Pointer type coercion</a>).  For example, in
</p><table><tr><td>&nbsp;</td><td><pre class="example">void sum(int* array, int* result) { ... }  // definition of &quot;sum&quot;
...
int a[40];
int total;
...
sum(a, &amp;total);        // use of &quot;sum&quot;
</pre></td></tr></table>
<p>the first pointer parameter refers to an array while the second refers to
a single value.  Kvasir (and Daikon) should treat these values
differently.  For instance, <code>*array</code> is better printed as <code>array[]</code>,
an array of integers, and <code>result[]</code> isn't a sensible array
at all, even though in C <code>result[0]</code> is semantically identical to
<code>*result</code>.
By default, Kvasir treats all pointers as referencing arrays.  For
instance, it would print <code>result[]</code> rather than <code>result[0]</code>
and would indicate that the length of array <code>result[]</code> is always 1.
In order to improve the formatting of Daikon's output (and to speed it
up), you can indicate to Kvasir that certain pointers refer to single
elements rather than to arrays.
For an example, see <a href="#SEC87">Pointer type disambiguation example</a>).
</p>
<p>Information about whether each pointer refers to an array or a single
element can be specified in a &ldquo;disambig file&rdquo; that resides in the
same directory as the target program (by default).  The &lsquo;<samp>--disambig</samp>&rsquo;
option instructs Kvasir to read this file if it exists.  (If it does not exist,
Kvasir produces the file automatically and, if invoked along with the
&lsquo;<samp>--smart-disambig</samp>&rsquo; option, heuristically infers whether each
pointer variable refers to single or multiple elements.  Thus, users can
edit this file for use on subsequent runs rather than having to create it
from scratch.)  The disambig file lists all the program points and user-defined
types, and under each, lists certain types of variables along with their
custom disambiguation types as shown below.
The list of disambiguation options is:
</p>
<ol>
<li>
For variables of type <code>char</code> and <code>unsigned char</code>:
<ol>
<li>
'I': an integer, signed for <code>char</code> and unsigned for <code>unsigned char</code>. (Default)
</li><li>
'C': a single character, output as a string.
</li></ol>
</li><li>
For pointers to (or arrays of) <code>char</code> and <code>unsigned char</code>:
<ol>
<li>
'S': a string, possibly zero-terminated. (Default)
</li><li>
'C': a single character, output as a string.
</li><li>
'A': an array of integers.
</li><li>
'P': a single integer.
</li></ol>
</li><li>
For pointers to (or arrays of) all other variable types (if invoked
along with &lsquo;<samp>--smart-disambig</samp>&rsquo;, Kvasir automatically infers a default 'A' or 'P' for each variable during the generation of a &lsquo;<tt>.disambig</tt>&rsquo; file):
<ol>
<li>
'A': an array.  (Default) (For an array of structs, an array will be output for each scalar field of the struct.  Aggregate children (arrays, other structs) will not be output.)
</li><li>
'P': a pointer to a single element.  (For a pointer to a struct, each
field will be output as a single instance, and child aggregate types
will be output recursively.  This extra information obtained from struct
pointers is a powerful consequence of pointer type disambiguation.  This
will be the default if the &lsquo;<samp>--disambig-ptrs</samp>&rsquo; option is used.)
</li></ol>
</li></ol>

<p>The disambig file that Kvasir creates contains a section for each
function, which can be used to disambiguate parameter variables visible
at that function's entrance program point and parameter and return
value variables visible at that function's exit program point.  It also contains
a section for every user-defined
struct/class, which can be used to disambiguate member variables of
that struct/class.  Disambiguation information entered here will apply to all
instances of a struct/class of that type, at all program points.
There is also a section called &ldquo;globals&rdquo;, which disambiguates global
variables which are output at every program point.  The entries in the
disambig file may appear in any order, and whole entries or individual
variables within a section may be omitted.  In this case, Kvasir will
retain their default values.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC86">7.3.5.1 Pointer type coercion</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC87">7.3.5.2 Pointer type disambiguation example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC88">7.3.5.3 Using pointer type disambiguation with partial program tracing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Pointer-type-coercion"></a>
<a name="SEC86"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC85" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC87" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC85" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.3.5.1 Pointer type coercion </h4>

<p>In addition to specifying whether a particular pointer refers to one
element or to an array of elements, the user can also specify what type
of data a pointer refers to.  This type coercion acts like an explicit
type cast in C, except that it only works on struct/class types and not
on primitive types.  This feature is useful for traversing inside of
data structures with generic <code>void*</code> pointer fields.  Another use
is to cast a pointer from one that refers to a 'super class' to one that
refers to a 'sub class'.  This structural equivalence pattern is often
found in C programs that emulate object orientation.  To coerce a
pointer to a particular type, simply write the name of the struct type
after the disambiguation letter (e.g., A, P, S, C, I) in the
&lsquo;<tt>.disambig</tt>&rsquo; file:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">----SECTION----
function: ..view_foo_and_bar()
f
P foo
b
P bar
</pre></td></tr></table>

<p>Without the type coercion, Kvasir cannot print out anything except for a
hashcode for the two <code>void*</code> parameters of this function:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">void view_foo_and_bar(void* f, void* b);
</pre></td></tr></table>

<p>With type coercion, though, Kvasir treats <code>f</code> as a <code>foo*</code> and
<code>b</code> as <code>bar*</code> and can traverse inside of them.  Of course, if
those are not the true runtime types of the variables, then Kvasir's
output will be meaningless.
</p>
<p>Due to the use of typedefs, there may be more than one name for a
particular struct type.  The exact name that you need to write in the
&lsquo;<tt>.disambig</tt>&rsquo; file is the one that appears in that file after the
<code>usertype</code> prefix.  Note that if a struct does not have any pointer
fields, then there will be no <code>usertype</code> section for it in the
&lsquo;<tt>.disambig</tt>&rsquo; file.  In that case, try different names for the struct
if necessary until Kvasir accepts the name (names are all one word long;
you will never have to write <code>struct foo</code>).  There should only be
at most a few choices to make.  If the coercion if successful, Kvasir
prints out a message in the following form while it is processing the
&lsquo;<tt>.disambig</tt>&rsquo; file:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  .disambig: Coerced variable f into type 'foo'
  .disambig: Coerced variable b into type 'bar'
</pre></td></tr></table>

<p>One more caveat about type coercion is that you can currently only
coerce pointers into types that at least one variable in the program
(e.g., globals, function parameters, struct fields) belongs to.  It is
not enough to merely declare a struct type in your source code; you must
have a variable of that type somewhere in your program.  This is a
limitation of the current implementation, but it should not matter most
of the time because programs rarely have struct declarations with no
variables that belong to that type.  If you encounter this problem, you
can simply create a global variable of a certain type to make type
coercion work.
</p>
<hr size="6">
<a name="Pointer-type-disambiguation-example"></a>
<a name="SEC87"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC86" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC88" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC85" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.3.5.2 Pointer type disambiguation example </h4>

<p>This example demonstrates the power of pointer type disambiguation in creating
more accurate Daikon output.  Consider this file:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">struct record {
  char* name;     // Initialize to: &quot;Daikon User&quot;
  int numbers[5]; // Initialize to: {5, 4, 3, 2, 1}
};

void foo(struct record* bar) {
  int i;
  for (i = 0; i &lt; 5; i++) {
    bar-&gt;numbers[i] = (5 - i);
  }
}

int main() {
  char* myName = &quot;Daikon User&quot;;
  struct record baz;
  baz.name = myName;
  foo(&amp;baz);
}
</pre></td></tr></table>

<p>In <code>foo()</code>, <code>bar</code> is a pointer to a  <code>record</code> struct.  By inspection, it is
evident that in this program, <code>bar</code> only refers to one element: <code>&amp;baz</code>
within <code>main</code>.  However, by default, Kvasir assumes that <code>bar</code> is an
array of <code>record</code> structs since a C pointer contains no information about
how many elements it refers to.  Because Kvasir must output <code>bar</code> as an
array and <code>bar-&gt;numbers</code> is an array of integers, it &ldquo;flattens&rdquo;
<code>bar-&gt;numbers</code> into 5 separate arrays named <code>bar-&gt;numbers[0]</code>
through <code>bar-&gt;numbers[4]</code>
and creates fairly verbose output.  This is a direct
consequence of the fact that Daikon can only handle one layer of sequences
(it cannot handle arrays within arrays, i.e., multi-dimensional arrays).
</p>
<p>Here is part of the Daikon output for this program:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">======================================================================
..foo():::ENTER
bar has only one value
bar[].name == [Daikon User]
bar[].name elements == &quot;Daikon User&quot;
======================================================================
..foo():::EXIT
size(bar[]).numbers[0] == size(bar[]).numbers[0][0]
size(bar[]).numbers[0] == size(bar[]).numbers[1]
size(bar[]).numbers[0] == size(bar[]).numbers[1][0]
size(bar[]).numbers[0] == size(bar[]).numbers[2]
size(bar[]).numbers[0] == size(bar[]).numbers[2][0]
size(bar[]).numbers[0] == size(bar[]).numbers[3]
size(bar[]).numbers[0] == size(bar[]).numbers[3][0]
size(bar[]).numbers[0] == size(bar[]).numbers[4]
size(bar[]).numbers[0] == size(bar[]).numbers[4][0]
bar[].name == [Daikon User]
bar[].name elements == &quot;Daikon User&quot;
bar[].numbers[0] contains no nulls and has only one value, of length 1
bar[].numbers[0] elements has only one value
bar[].numbers[0][0] == [5]
bar[].numbers[0][0] elements == 5
bar[].numbers[1] contains no nulls and has only one value, of length 1
bar[].numbers[1] elements has only one value
bar[].numbers[1][0] == [4]
bar[].numbers[1][0] elements == 4
bar[].numbers[2] contains no nulls and has only one value, of length 1
bar[].numbers[2] elements has only one value
bar[].numbers[2][0] == [3]
bar[].numbers[2][0] elements == 3
bar[].numbers[3] contains no nulls and has only one value, of length 1
bar[].numbers[3] elements has only one value
bar[].numbers[3][0] == [2]
bar[].numbers[3][0] elements == 2
bar[].numbers[4] contains no nulls and has only one value, of length 1
bar[].numbers[4] elements has only one value
bar[].numbers[4][0] == [1]
bar[].numbers[4][0] elements == 1
size(bar[]).numbers[0] == 1
bar[].numbers[4][0] elements == size(bar[]).numbers[0]
size(bar[]).numbers[0] in bar[].numbers[4][0]
</pre></td></tr></table>

<p>This is a bit verbose due to the fact that Kvasir treats <code>bar</code> like an array
by default when it actually only points to one element.  However, by running
Kvasir with the &lsquo;<samp>--disambig</samp>&rsquo; option, we create the
&lsquo;<tt><var>myprog</var>.disambig</tt>&rsquo; file, which we can then edit and feed back to
Kvasir to change how the pointer is treated.  (We run Kvasir twice on the same
program, but we edit the &lsquo;<tt>.disambig</tt>&rsquo; file in between the runs.)
</p><table><tr><td>&nbsp;</td><td><pre class="example">kvasir-dtrace <var>...options...</var> --disambig --smart-disambig <var>myprog</var>
</pre></td></tr></table>

<p>This creates the &lsquo;<tt><var>myprog</var>.disambig</tt>&rsquo; file.  It contains, at the top:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">----SECTION----
function: ..foo()
bar
P
</pre></td></tr></table>

<p>This means that at the program points corresponding to the entry and
exit of <code>foo()</code>, the variable <code>bar</code> is treated as a
&lsquo;<samp>P</samp>&rsquo;ointer type.
Since we have used the &lsquo;<samp>--smart-disambig</samp>&rsquo; option,
Kvasir automatically inferred Pointer instead of Array for <code>bar</code>
because it observed that <code>bar</code> only pointed to one element during the
execution of the target program which generated the &lsquo;<tt>.disambig</tt>&rsquo; file.
This heuristic allows users to use
&lsquo;<tt>.disambig</tt>&rsquo; files more effectively with less manual editing.
Without &lsquo;<samp>--smart-disambig</samp>&rsquo;, Kvasir does not execute the program
to make such inferences, which allows .disambig files to be generated
faster, but leaves the default disambiguation types for all entries (in
this case, <code>bar</code> would have the default array type of
<code>'A'</code>).
</p>
<p>Then, running Kvasir again with the &lsquo;<samp>--disambig</samp>&rsquo;
option causes Kvasir to open the existing
&lsquo;<tt><var>myprog</var>.disambig</tt>&rsquo; file, read the definitions, and alter
the output accordingly:
</p><table><tr><td>&nbsp;</td><td><pre class="example">kvasir-dtrace <var>...options...</var> --disambig <var>myprog</var>
</pre></td></tr></table>

<p>This tells Kvasir to output <code>bar</code> as a &lsquo;<samp>P</samp>&rsquo;ointer to a single
element, which in turn causes Daikon to generate a much more concise
set of invariants.  Notice that <code>bar-&gt;numbers</code> no longer has to be
&ldquo;flattened&rdquo; because <code>bar</code> is now a pointer to one struct, so
Daikon can recognize <code>bar-&gt;numbers</code> as a single-dimensional
array (Daikon uses a Java-like syntax, replacing the arrow '-&gt;' symbol
with a dot, so it actually outputs <code>bar.numbers</code>).
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">======================================================================
..foo():::ENTER
bar has only one value
bar.name == &quot;Daikon User&quot;
======================================================================
..foo():::EXIT
bar.name == &quot;Daikon User&quot;
bar.numbers has only one value
bar.numbers[] == [5, 4, 3, 2, 1]
size(bar.numbers[]) == 5
bar.name == orig(bar.name)
size(bar.numbers[]) in bar.numbers[]
size(bar.numbers[])-1 in bar.numbers[]
</pre></td></tr></table>


<hr size="6">
<a name="Using-pointer-type-disambiguation-with-partial-program-tracing"></a>
<a name="SEC88"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC87" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC89" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC85" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.3.5.3 Using pointer type disambiguation with partial program tracing </h4>

<p>It is possible to use pointer type disambiguation while only tracing
selected program points and/or variables in a target program, combining
the functionality described in the <a href="#SEC85">Pointer type disambiguation</a> and
<a href="#SEC84">Tracing only part of a program</a> sections.  This section describes
the interaction of the &lsquo;<tt>ppt-list-file</tt>&rsquo;, &lsquo;<tt>var-list-file</tt>&rsquo;, and
.disambig files.
</p>
<p>The interaction between selective program point tracing (via
the &lsquo;<tt>ppt-list-file</tt>&rsquo;) and pointer type disambiguation is fairly
straightforward:  If the user creates a .disambig file while running
Kvasir with a &lsquo;<tt>ppt-list-file</tt>&rsquo; that only specifies certain program
points, the generated .disambig file will only contain sections for
those program points (as well as the global section and sections for
each struct type).  If the user reads in a .disambig file while running
Kvasir with a &lsquo;<tt>ppt-list-file</tt>&rsquo;, then disambiguation information is
applied for all variables at the program points to be traced.  This can
be much faster and generate a much smaller disambiguation file, one that
only contains information about the program points of interest.
</p>
<p>The interaction between selective variable tracing (via the
&lsquo;<tt>var-list-file</tt>&rsquo;) and pointer type disambiguation is a bit more
complicated.  This is because the &lsquo;<tt>var-list-file</tt>&rsquo; lists variables
as they appear in the .decls and .dtrace files, but using a .disambig
file can actually change the way that variable names are printed out in
the .decls and .dtrace files.  For example, consider the test program
from the <a href="#SEC87">Pointer type disambiguation example</a>.  The <code>struct
record* bar</code> parameter of <code>foo()</code> is treated like an array by
default.  Hence, the .decls, .dtrace, and &lsquo;<tt>var-list-file</tt>&rsquo; will list
the following variables derived from this parameter:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">----SECTION----
..foo()
bar
bar[].name
bar[].numbers[0]
bar[].numbers[0][0]
bar[].numbers[1]
bar[].numbers[1][0]
bar[].numbers[2]
bar[].numbers[2][0]
bar[].numbers[3]
bar[].numbers[3][0]
bar[].numbers[4]
bar[].numbers[4][0]
</pre></td></tr></table>

<p>However, if we use a disambiguation file to denote <code>bar</code> as a
pointer to a single element, then the .decls and .dtrace files will
instead list the following variables:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">----SECTION----
..foo()
bar
bar-&gt;name
bar-&gt;numbers
bar-&gt;numbers[]
</pre></td></tr></table>

<p>Notice how the latter variable list is more compact and reflects the
fact that <code>bar</code> is a pointer to a single struct.  Thus, the
flattening of the <code>numbers[5]</code> static array member variable is no
longer necessary (it was necessary without disambiguation because Daikon
does not support nested arrays of arrays, which can occur if <code>bar</code>
were itself an array since <code>numbers[5]</code> is already an array).
</p>
<p>Notice that, with the exception of the base variable <code>bar</code>, all
other variable names differ when running without and with
disambiguation.  Thus, if you used a &lsquo;<tt>var-list-file</tt>&rsquo; generated on a
run without the disambiguation information while running Kvasir with the
disambiguation information, the names will not match up at all, and you
will not get the proper selective variable tracing behavior.
</p>
<p>The suggested way to use selective variable tracing with pointer type
disambiguation is as follows:
</p>
<ol>
<li> First create the proper .disambig file by using either
&lsquo;<samp>--disambig</samp>&rsquo; or &lsquo;<samp>--disambig-file</samp>&rsquo;.
You can use &lsquo;<samp>--ppt-list-file</samp>&rsquo; as well to only create the
.disambig file for certain program points, but do NOT use
&lsquo;<samp>--var-list-file</samp>&rsquo; to try to create a .disambig only for certain
variables; this feature does not work yet.
Modify the variable
entries in the Kvasir-generated .disambig file to suit your needs.
</li><li> Now create a &lsquo;<tt>var-list-file</tt>&rsquo; by using
&lsquo;<samp>--dump-var-file</samp>&rsquo; while running Kvasir with the .disambig file
that you have just created.  This ensures that the variables listed in
&lsquo;<tt>var-list-file</tt>&rsquo; will have the proper names for use with that
particular .disambig file.  Modify the Kvasir-generated
&lsquo;<tt>var-list-file</tt>&rsquo; to suit your needs.
</li><li> Finally, run Kvasir with the &lsquo;<samp>--var-list-file</samp>&rsquo; option using
the &lsquo;<tt>var-list-file</tt>&rsquo; that you have just created and either the
&lsquo;<samp>--disambig</samp>&rsquo; or &lsquo;<samp>--disambig-file</samp>&rsquo; option with the proper
.disambig file.  This will perform the desired function: selective
variable tracing along with disambiguation for all of the traced
variables.
</li></ol>

<p>For maximum control of the output, you can use selective program point
tracing, variable tracing, and disambiguation together all at once.
</p>
<hr size="6">
<a name="C_002b_002b-support"></a>
<a name="SEC89"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC88" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.3.6 C++ support </h3>

<p>Kvasir supports C++, but Kvasir has been tested more on C programs than
on C++ programs, so Kvasir's C++ support is not as mature as its C support.
Here is a partial list of C++ features that Kvasir currently supports:
</p>
<ul>
<li>
Class member functions are traced just like regular functions, except
that their first parameter is a pointer (called <code>this</code>) to a single
instance of the class.  They are printed with the class name as the
prefix, followed by a period and then the full function signature.  For
example, a <code>push()</code> function of a <code>Stack</code> class might be named
<code>Stack.push(char*)</code>.

</li><li>
OBJECT program points (see section <a href="daikon_5.html#SEC36">Program points</a>) are printed out in the
.decls file for each class with at least 1 member variable and 1 member
function.  No extra information besides member function traces are
required in the .dtrace file; Daikon can link together class and
function names to determine when a particular function is a member
function and generate object invariants for that class by observing the
values of the <code>this</code> parameter.

</li><li>
Static member variables are currently treated just like global
variables, because they actually have static global locations.  Another
(not yet implemented) possibility is to only print them at program
points of member functions belonging to the respective variable's own
class.

</li><li>
Inheritance is handled correctly because whenever Kvasir traverses
inside of a class to print out its member variables, it also recursively
traverses inside all superclasses (and inside their superclasses,
etc...) to print out inherited member variables.  The superclass class
names are appended onto the variable names to make them unique.  For
example, if <code>this</code> is an instance of a class that inherits from
another class called <code>fooClass</code> which has a member variable
<code>fooVar</code>, then Kvasir prints out <code>fooVar</code> as
<code>this-&gt;fooClass.fooVar</code>.  This correctly handles the case of
multiple inheritance as well as several layers of inheritance.  Thus,
object invariants capture properties of a class's own member variables
as well as those of its superclasses' member variables.

</li><li>
Inheritance-based polymorphism is handled correctly without any extra
effort because when a function entrance or exit is encountered at run
time, the version that is called has already been resolved.

</li><li>
Overloaded functions are handled correctly because Kvasir prints out the
full function signature as its name in order to prevent conflicts.  For
example, two overloaded versions of a function <code>foo()</code> will be
disambiguated by their signatures, such as <code>foo(int, int)</code> and
<code>foo(double, double)</code>.

</li><li>
Kvasir handles functions that pass parameters by reference as well as
those that pass parameters by value.

</li></ul>

<p>One current C++ limitation is that Kvasir cannot print out the contents
of classes which are defined in external libraries rather than in the
user's program (e.g., it can properly output a C-string represented as
<code>char*</code> but not the contents of the C++ <code>string</code> class).  If
further support for specific C++ features are important to you, please
send email to <a href="mailto:daikon-developers@lists.csail.mit.edu">daikon-developers@lists.csail.mit.edu</a>, so that we
can increase its priority on our to-do list.
</p>
<hr size="6">
<a name="Online-execution"></a>
<a name="SEC90"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC89" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC91" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.3.7 Online execution </h3>


<p>The term &ldquo;online execution&rdquo; refers to running Daikon at the same time
as the target program, without writing any information to a file.  This
can avoid some I/O overhead, prevent filling up your disk with
files, and in the future Daikon may be able to produce partial results
as the target program is executing.  A limitation of online execution is
that, unless FIFOs, or named pipes (see section <a href="#SEC91">Online execution with DynComp for C/C++</a>)
are used, it runs Daikon over only a single execution, as opposed to
generalizing over multiple executions as can be done when writing to files
and supplying all the files to Daikon.
The Chicory front end for Java also supports online execution, via its
&lsquo;<samp>--daikon-online</samp>&rsquo; option (see section <a href="#SEC73">Chicory miscellaneous options</a>).
</p>
<a name="IDX95"></a>

<p>To use regular pipes in lieu of a disk file, simply use &lsquo;<tt>-</tt>&rsquo; as the
name of the &lsquo;<tt>.dtrace</tt>&rsquo; file, and run the target program and Daikon
in a Unix pipeline.
When the &lsquo;<samp>--dtrace-file=-</samp>&rsquo; option is used to redirect
the .dtrace output to stdout, the target program's stdout is redirected
to the terminal (&lsquo;<tt>/dev/tty</tt>&rsquo;) so that it does not intermix with the
.dtrace output.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">kvasir-dtrace --dtrace-file=- ./bzip2 --help | $DAIKON -
</pre></td></tr></table>

<p>Of course, you could also replace &lsquo;<samp>--help</samp>&rsquo; with &lsquo;<samp>-vv1
file.txt</samp>&rsquo; to compress a text file (but start with a small one first).
</p>
<p>(This example assumes that you have compiled the bzip2 example (in
&lsquo;<tt>$DAIKONDIR/examples/c-examples/bzip2</tt>&rsquo; of the distribution) by
saying <code>gcc -gdwarf-2 bzip2.c -o bzip2</code>, and that
<code>$DAIKON</code> stands for the command that invokes Daikon, for
instance <code>java -Xmx512m daikon.Daikon --config_option
daikon.derive.Derivation.disable_derived_variables=true</code>.)
</p>
<a name="IDX96"></a>
<a name="IDX97"></a>

<p>Instead of a regular pipe, you can use a named pipe, also known as a
FIFO, which is a special kind of file supported by most Unix-compatible
systems.  When one process tries to open a FIFO
for reading, it blocks, waiting for another process to open it for
writing (or vice-versa).  When both a reader and a writer are ready, the
FIFO connects the reader to the writer like a regular Unix pipe.
</p>
<p>The &lsquo;<samp>--output-fifo</samp>&rsquo; option causes Kvasir to create its output
&lsquo;<tt>.dtrace</tt>&rsquo; file as a named pipe.  When Kvasir is
run with this option, Daikon needs to be run at the same time to read
from the FIFO, such as from another terminal or using the shell's
<code>&amp;</code> operator.
</p>
<p>For instance, the following two commands have the same effect as the
pipeline above that used ordinary pipes.  The FIFO is named
&lsquo;<tt>bzip2.dtrace</tt>&rsquo;.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">kvasir-dtrace --output-fifo ./bzip2 --help &amp;
$DAIKON bzip2.dtrace
</pre></td></tr></table>

<p>The two commands (before and after the ampersand) could also be run in
two different terminals.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC91">7.3.7.1 Online execution with DynComp for C/C++</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Online-execution-with-DynComp-for-C_002fC_002b_002b"></a>
<a name="SEC91"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC90" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC92" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC90" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.3.7.1 Online execution with DynComp for C/C++ </h4>

<p>When running Kvasir with DynComp (using the &lsquo;<tt>--with-dyncomp</tt>&rsquo;
option), Kvasir generates the .decls file after it generates the .dtrace
file, so it is not possible to perform online execution using one run.
The recommended way to perform online execution with DynComp is to run
it once and only generate a .decls file with comparability information,
then run Kvasir again without DynComp and pipe the .dtrace data directly
into Daikon while using the .decls file generated from the previous run:
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">kvasir-dtrace --with-dyncomp --decls-only ./foo
</pre></td></tr></table>

<p>This should generate a .decls file with comparability information
named &lsquo;<tt>daikon-output/foo.decls</tt>&rsquo;.
</p>
<table><tr><td>&nbsp;</td><td><pre class="smallexample">kvasir-dtrace --dtrace-no-decs --dtrace-file=- ./foo \
    | java daikon.Daikon daikon-output/foo.decls -
</pre></td></tr></table>

<p>When you run Kvasir the second time, you don't need to run DynComp
again since you are only interested in the .dtrace file.  Notice that
the .dtrace output
is directed to standard out (&lsquo;<tt>--dtrace-file=-</tt>&rsquo;) and does not
contain any declarations (&lsquo;<samp>--dtrace-no-decs</samp>&rsquo;) because the .decls
file already contains the declarations.  You can simply
pipe that .dtrace output out to Daikon, which is invoked using the
.decls file (with comparability information) generated during your
previous run.
</p>
<hr size="6">
<a name="Installing-Kvasir"></a>
<a name="SEC92"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC91" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC93" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.3.8 Installing Kvasir </h3>


<p>The source
code for Kvasir is included in the main Daikon distribution, and is
compiled by default on Linux/x86 and Linux/x86-64 systems.
</p>
<p>To compile and install Kvasir, give the command <code>make kvasir</code>
from the top-level Daikon directory:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">cd $DAIKONDIR
make kvasir
</pre></td></tr></table>

<p>This will check that you have the appropriate prerequisites (such as
GCC), configure Kvasir for your machine, compile it, and install
it in the directory &lsquo;<tt>kvasir/inst</tt>&rsquo;.
</p>
<p>You may see warnings about the 'missing' script.  These can be ignored.
</p>
<p>Once Kvasir has been installed, it can be used via the
&lsquo;<tt>kvasir-dtrace</tt>&rsquo; script in the &lsquo;<tt>$DAIKONDIR/bin</tt>&rsquo; directory; if
you have set up the Daikon environment according to the instructions
above, it should already be in your <code>PATH</code>.  For instructions on using
Kvasir, see <a href="#SEC80">C/C++ front end Kvasir</a>.
</p>

<hr size="6">
<a name="Kvasir-limitations"></a>
<a name="SEC93"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC92" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC80" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.3.9 Kvasir implementation and limitations </h3>

<p>Kvasir is based on the Valgrind dynamic program supervision framework
(which is best known for its memory error detection tool).  Using
Valgrind allows Kvasir to interrupt your program's execution, read its
variables, and examine its memory usage, all transparently to the
program.  Also, rather than using your program's source code to find
the names and types of functions and variables, Kvasir obtains them
from debugging information included in the executable in a standard
format (DWARF-2).
</p>
<a name="IDX98"></a>
<a name="IDX99"></a>
<a name="IDX100"></a>
<a name="IDX101"></a>
<a name="IDX102"></a>

<p>However, Kvasir has some limitations of its own.  Because Kvasir uses
Valgrind, it shares Valgrind's processor and operating system limitations.
Furthermore, of the platforms supported by Valgrind, the only ones
currently supported by Kvasir are <code>x86-linux</code> and
<code>amd64-linux</code>.
<code>x86-linux</code> refers to Intel 386-compatible processors
(the so-called IA-32 architecture) such as the Intel Pentium and the
AMD Athlon, running Linux.
<code>amd64-linux</code> refers to the 64-bit extension of the x86
architecture found in many newer Intel and AMD processors, also
variously referred to as x86-64, IA-32e, EM64T, and Intel 64, when
running under a Linux kernel in 64-bit mode.
The Itanium or IA-64 architecture is not supported.
The Kvasir build process will automatically compile a 32-bit version, a
64-bit version, or both, whichever are supported by your system's
default compiler.
</p>
<p>Kvasir requires that your program have debugging
information available in the DWARF-2 format, as produced by GCC version
3 and later.  For the best results, the programs used by Kvasir should be
compiled without optimization.
</p>
<p>This subsection lists some of the known limitations of the
current Kvasir release; if you encounter any problems other than listed
here, please report them as bugs (see section <a href="daikon_9.html#SEC148">Reporting problems</a>).  The
limitations are listed roughly in decreasing order of severity.
</p>
<ul>
<li>
Kvasir-traced programs take a while to start (often a good fraction of a
second).  When tracing short-lived programs, this overhead can
dominate Kvasir's per-instruction runtime overhead.  In order to make Kvasir
run faster, try the &lsquo;<samp>--ignore-globals</samp>&rsquo;
option in order to limit the amount of generated output.
However, please keep in mind that, when running simultaneously with
Daikon using the &lsquo;<samp>--output-fifo</samp>&rsquo; option (see <a href="#SEC90">Online execution</a>), Kvasir can generate
output data much faster than Daikon can process it.  Thus, it is not the
performance bottleneck in the entire invariant detection system.

</li><li>
Kvasir's support for outputting arrays is not yet complete.
It still does not have the functionality to print out multidimensional
arrays with all of their elements or the option to flatten
multidimensional arrays into multiple single-dimensional arrays.

</li><li>
Kvasir behaves somewhat differently with different versions of GCC.
We have had the best results with GCC versions 4.1 and 4.3 (which we use for
testing).  If feasible, we recommend that you use Kvasir with one of
these versions of GCC.  Incompatibilities
between Kvasir and the debugging information produced by older GCC
versions can lead to incorrect output and, in some cases for version
2.95, can cause Kvasir to crash.

</li><li>
Kvasir with Dyncomp will produce different results for x86 and
x86-64 hosts. This is due to a Dyncomp limitation with regards to
how handling the AMD64 ABI. The AMD64 ABI allows structs that are
less than 8-bytes to be passed to a function via register. 
Dyncomp categorizes this as an interaction between all
fields of the struct and will mark all fields of the struct as
comparable to each other.

</li><li>
Kvasir is incompatible with some compiler optimizations.  It is
definitely incompatible with the &lsquo;<samp>-fomit-frame-pointer</samp>&rsquo;
optimization, and it may have trouble with other optimizations as
well.  We recommend that you compile programs for Kvasir without
optimization.

</li><li>
Kvasir always prints the contents of structures according to their
compile-time type.  Programs that use generic pointers and structural
equivalence to simulate object-orientation will have derived-class
fields missing when a structure is passed via a base-class pointer.
This limitation can be worked around by manually coercing a pointer to a
particular type (see section <a href="#SEC86">Pointer type coercion</a>).

</li></ul>



<hr size="6">
<a name="Mangel_002dWurzel"></a>
<a name="SEC94"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC93" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC95" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.4 Source-based C/C++ front end Mangel-Wurzel </h2>


<p>In addition to the binary-based front end Kvasir (<a href="#SEC80">C/C++ front end Kvasir</a>), there
is also a source-based C/C++ front end, Mangel-Wurzel.  Unlike Kvasir, which
runs only on Linux/x86 platforms, Mangel-Wurzel will run on nearly any
Unix platform, as well as on Windows (with the Microsoft Visual C/C++
compiler).  If you have access to a Linux/x86 platform (32 or 64-bit),
we recommend use
of Kvasir.  Mangel-Wurzel is missing a few features of Kvasir; for
instance, Mangel-Wurzel outputs fewer variables and has no abstract type
inference analysis ().  Mangel-Wurzel requires
the source code for your program, and it also requires the Purify
program analysis tool from Rational Software.  You must install Purify
(either a paid or evaluation version) before you can use Mangel-Wurzel.
</p>
<p>Mangel-Wurzel is based on the EDG C/C++ front end, which is also commercial
software.  For this reason, Mangel-Wurzel is distributed in precompiled
binary form only.  See <a href="#SEC106">Installing Mangel-Wurzel</a>, for more information
about installation.  If you have an EDG source license and would like to build
or modify Mangel-Wurzel, we can provide source code on request.
</p>
<p>Mangel-Wurzel is named after a root vegetable grown as cattle fodder.
It &ldquo;mangles&rdquo; the source code into a form that is not fit for human
consumption before compiling it.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC95">7.4.1 Using Mangel-Wurzel</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC96">7.4.2 Mangel options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC101">7.4.3 Pointer/array disambiguation in Mangel-Wurzel</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC102">7.4.4 Mangel-Wurzel usage notes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC105">7.4.5 Interaction with Purify</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC106">7.4.6 Installing Mangel-Wurzel</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    
</td></tr>
</table>

<hr size="6">
<a name="Using-Mangel_002dWurzel"></a>
<a name="SEC95"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC94" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.4.1 Using Mangel-Wurzel </h3>


<p>Mangel-Wurzel consists of three parts: a driver program called
<code>mangel</code>, the preprocessor <code>wurzel</code> which
adds annotations to the source code,
and a small runtime library.  Mangel is a replacement for the
<code>cc</code> command:  it produces an
instrumented executable that behaves like the original program, but that
also produces a &lsquo;<tt>.dtrace</tt>&rsquo; data trace file for Daikon to analyze.
Mangel operates by in turn invoking
the source preprocessor wurzel, the host compiler and linker, and the
object code instrumenter Purify.
</p>

<p>To use Mangel-Wurzel in conjunction with Daikon, follow these steps
(after installing Mangel-Wurzel, see section <a href="#SEC106">Installing Mangel-Wurzel</a>):
</p>
<ol>
<li>
Compile and link the program, using <code>mangel</code> in place of
<code>cc</code>.  This produces both an
instrumented executable and also a &lsquo;<tt>.decls</tt>&rsquo; file
for each compilation unit.

<p>If you use a makefile to compile your program, simply substitute
<code>mangel</code> for <code>cc</code>.
</p>
<p>Alternately, you may issue the compilation commands directly.
For example, suppose you have a program that consists of three input files,
&lsquo;<tt>foo.c</tt>&rsquo;, &lsquo;<tt>bar.c</tt>&rsquo;, and &lsquo;<tt>baz.c</tt>&rsquo;.  You can compile
and link in one step:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">mangel -o foo foo.c bar.c baz.c
</pre></td></tr></table>

<p>Or, you can compile each file individually and then invoke mangel again to
link:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">mangel -c foo.c
mangel -c bar.c
mangel -c baz.c
mangel -o foo foo.o bar.o baz.o
</pre></td></tr></table>

<p>As a side-effect, the wurzel preprocessor invoked by mangel
produces a &lsquo;<tt>.decls</tt>&rsquo; file for each source file
it processes, in this case &lsquo;<tt>foo.decls</tt>&rsquo;, &lsquo;<tt>bar.decls</tt>&rsquo;, and
&lsquo;<tt>baz.decls</tt>&rsquo;.
</p>
</li><li>
Run the instrumented program.

<ul class="toc">
<li>
On Unix, simply run the instrumented program (in this example, &lsquo;<tt>foo</tt>&rsquo;)
created by mangel.

</li><li>
On Windows, Purify needs to be invoked when you run your program, not
at link time.  Mangel creates a &lsquo;<tt>.cmd</tt>&rsquo; file that does this for you;
in this example, run &lsquo;<tt>foo.cmd</tt>&rsquo; instead of &lsquo;<tt>foo.exe</tt>&rsquo;.
You can also run your program from within the Purify GUI
instead of from the command line, if you prefer.
</li></ul>

<p>This creates a single &lsquo;<tt>.dtrace</tt>&rsquo; file
(in addition to anything else the program does).
Assuming &lsquo;<tt>foo.c</tt>&rsquo; contains the <code>main</code> routine, the
trace output for this example will be in &lsquo;<tt>foo.dtrace</tt>&rsquo;.
How to run the instrumented program depends on your operating system.
</p>
</li><li>
Invoke Daikon, passing all of the &lsquo;<tt>.decls</tt>&rsquo; files and the &lsquo;<tt>.dtrace</tt>&rsquo;
file as inputs.

<table><tr><td>&nbsp;</td><td><pre class="example">java daikon.Daikon foo.decls bar.decls baz.decls foo.dtrace
</pre></td></tr></table>


</li><li>
Examine the invariants.  There are
several ways to do this; See section <a href="daikon_3.html#SEC15">StackAr example</a>.

</li></ol>

<hr size="6">
<a name="Mangel-options"></a>
<a name="SEC96"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC95" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC97" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.4.2 Mangel options </h3>

<p>Mangel acts as a replacement for the host <code>cc</code> command.  It
supports most of the common C compiler command-line options
(see section <a href="#SEC97">Standard compiler options for Mangel</a>).  It also has options
that control how the wurzel preprocessor, compiler, and linker programs
are invoked (see section <a href="#SEC98">Mangel configuration options</a>), and options that are
specific to controlling the program annotations added by wurzel
(see section <a href="#SEC99">Mangel annotation options</a>).
</p>
<p>Mangel is invoked as:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">mangel <var>[options] inputfile1 ...</var>
</pre></td></tr></table>

<p>You can specify multiple <var>inputfile</var>s on the command line.  Mangel will
compile source files individually and then link them together (unless you have
specified one of the command-line options that suppresses linking).  You
can also include object and archive files on the command line, which are
passed directly to the linker.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC97">7.4.2.1 Standard compiler options for Mangel</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC98">7.4.2.2 Mangel configuration options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC99">7.4.2.3 Mangel annotation options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC100">7.4.2.4 Options files for Mangel</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    
</td></tr>
</table>

<hr size="6">
<a name="Standard-compiler-options-for-Mangel"></a>
<a name="SEC97"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC96" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC98" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.4.2.1 Standard compiler options for Mangel </h4>

<p>Mangel supports most of the common C compiler command-line options.
</p>
<dl compact="compact">
<dt> &lsquo;<samp>-o <var>filename</var></samp>&rsquo;</dt>
<dd><p>Specify <var>filename</var> as the output file.
</p>
</dd>
<dt> &lsquo;<samp>-c</samp>&rsquo;</dt>
<dd><p>Stop after compilation, producing a &lsquo;<tt>.o</tt>&rsquo; file; do not link.
</p>
</dd>
<dt> &lsquo;<samp>-E</samp>&rsquo;</dt>
<dd><p>Stop after preprocessing with wurzel, producing a &lsquo;<tt>.int.c</tt>&rsquo; file;
do not compile or link.  You might want to use this option for debugging
if you are having problems getting the instrumented code to compile with
the host C/C++ compiler.
</p>
</dd>
<dt> &lsquo;<samp>-D<var>symbol</var></samp>&rsquo;</dt>
<dt> &lsquo;<samp>-D<var>symbol</var>=<var>value</var></samp>&rsquo;</dt>
<dd><p>Define preprocessor symbols.
</p>
</dd>
<dt> &lsquo;<samp>-U<var>symbol</var></samp>&rsquo;</dt>
<dd><p>Undefine preprocessor symbols.
</p>
</dd>
<dt> &lsquo;<samp>-I<var>pathname</var></samp>&rsquo;</dt>
<dd><p>Add <var>pathname</var> to the list of places searched for include files.
</p>
<a name="IDX103"></a>
<p>If the environment variable <code>MANGEL_DIR</code> is set, mangel implicitly
adds its &lsquo;<tt>include</tt>&rsquo; subdirectory to the list of directories searched
for system include
files.  Otherwise you must explicitly use &lsquo;<samp>-I</samp>&rsquo; to specify where to
find Mangel-Wurzel's system include files, or include this information in
the options list passed directly to the wurzel preprocessor.  See the
&lsquo;<samp>--preprocessor_opts</samp>&rsquo; option (see section <a href="#SEC98">Mangel configuration options</a>).
</p>
<a name="IDX104"></a>
<a name="IDX105"></a>
<p>On Windows, mangel implicitly adds &lsquo;<samp>-I</samp>&rsquo; options for all of the
pathnames specified in the environment variable <code>INCLUDE</code>, which is
also used by the Microsoft C compiler to specify the location of its
default system libraries.  On Unix, it uses the path specified in the
environment variable <code>CPATH</code> in addition to the default system libraries
specified in the configuration file, for compatibility with gcc.
</p>
</dd>
<dt> &lsquo;<samp>-O</samp>&rsquo;</dt>
<dt> &lsquo;<samp>-O<var>value</var></samp>&rsquo;</dt>
<dd><p>Enable optimization in the compiler.  This might interact badly with Purify, so
be careful.
</p>
</dd>
<dt> &lsquo;<samp>-g</samp>&rsquo;</dt>
<dd><p>Enable debugging in the compiler.  Since Purify expects code it processes
to be compiled with &lsquo;<samp>-g</samp>&rsquo;, this is typically configured as one of the
default host compiler options (see section <a href="#SEC106">Installing Mangel-Wurzel</a>) and
need not be supplied explicitly on the command line.
</p>
</dd>
<dt> &lsquo;<samp>-L<var>pathname</var></samp>&rsquo;</dt>
<dd><p>Add <var>pathname</var> to the list of places searched for system libraries.
This option is not supported on Windows, since the Microsoft linker uses
a different model for finding libraries.
</p>

</dd>
<dt> &lsquo;<samp>-l<var>name</var></samp>&rsquo;</dt>
<dd><p>Link with system library <var>name</var>.  This option is not supported on
Windows, since the Microsoft linker expects libraries to be specified like
ordinary input files to the linker.
</p>
<p>If the environment variable <code>MANGEL_DIR</code> is set, mangel implicitly
adds &lsquo;<tt>$MANGEL_DIR/lib/libmangelwurzel.a</tt>&rsquo; to the list of libraries to
be linked with.  Otherwise you must explicitly link with this library,
include this information in the options list passed directly to the
linker.  See &lsquo;<samp>--linker_opts</samp>&rsquo; (see section <a href="#SEC98">Mangel configuration options</a>).
</p>
<a name="IDX106"></a>
<p>Also, on Unix, if the environment variable <code>PURIFY_DIR</code> is set, mangel
implicitly adds &lsquo;<tt>$PURIFY_DIR/purify_stubs.a</tt>&rsquo; to the list of libraries to
be linked with.  Similarly, if the environment variable is not set, you have
to specify this library explicitly.  This is not needed on Windows because
Purify uses a different model for resolving link references to its API on
that platform.
</p>

</dd>
<dt> &lsquo;<samp>--c</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--c99</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--c++</samp>&rsquo;</dt>
<dd><p>Interpret the input source file as old standard C (C89), C99, or C++,
respectively.  If none of these options are specified, mangel attempts
to infer the source language from the filename extension.
</p>
</dd>
<dt> &lsquo;<samp>--ansi</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--gcc</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--microsoft</samp>&rsquo;</dt>
<dd><p>Enable strict ANSI, gcc, and Microsoft compatibility modes (respectively)
in the wurzel preprocessor.  If none of these options are specified, wurzel
accepts ANSI C/C++ with a few common extensions and anachronisms.
</p>
</dd>
<dt> &lsquo;<samp>-h</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--help</samp>&rsquo;</dt>
<dd><p>Print a usage message and exit.
</p></dd>
</dl>

<hr size="6">
<a name="Mangel-configuration-options"></a>
<a name="SEC98"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC97" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC99" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.4.2.2 Mangel configuration options </h4>

<p>You can use either command-line options or an options file
to override Mangel's default behavior
regarding how Mangel invokes wurzel, the host
compiler, and the linker.
Options files are discussed in <a href="#SEC100">Options files for Mangel</a>.
</p>
<p>When you use command-line options from the shell or makefile to
specify these configuration parameters, be careful to quote the entire
option value string so that mangel interprets it as a single argument.
</p>
<dl compact="compact">
<dt> &lsquo;<samp>--preprocessor <var>command</var></samp>&rsquo;</dt>
<dd><p>Use <var>command</var> to invoke the wurzel preprocessor.  If this option is not
specified on the command line or in an options file,
it defaults to &lsquo;<samp>wurzel</samp>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--preprocessor_opts <var>option_string</var></samp>&rsquo;</dt>
<dd><p>Use <var>option_string</var> as additional options to the wurzel preprocessor.  If
this option is not specified on the command line or in an options file, it
defaults to a system-specific value.
</p>
</dd>
<dt> &lsquo;<samp>--compiler <var>command</var></samp>&rsquo;</dt>
<dd><p>Use <var>command</var> to invoke the host C/C++ compiler.  If this option is not
specified on the command line or in an options file,
it defaults to &lsquo;<samp>cc</samp>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--compiler_opts <var>option_string</var></samp>&rsquo;</dt>
<dd><p>Use <var>option_string</var> as additional options to the host compiler.  If
this option is not specified on the command line or in an options file,
it defaults to a system-specific value.
</p>
</dd>
<dt> &lsquo;<samp>--linker <var>command</var></samp>&rsquo;</dt>
<dd><p>Use <var>command</var> to invoke the host linker.  If this option is not
specified on the command line or in an options file,
it defaults to &lsquo;<samp>cc</samp>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--linker_opts <var>option_string</var></samp>&rsquo;</dt>
<dd><p>Use <var>option_string</var> as additional options to the host linker.  If
this option is not specified on the command line or in an options file,
it defaults to a system-specific value.
</p>
</dd>
<dt> &lsquo;<samp>--purify <var>command</var></samp>&rsquo;</dt>
<dd><p>Use <var>command</var> to invoke Rational Purify.  If this option is not
specified on the command line or in an options file,
it defaults to &lsquo;<samp>purify</samp>&rsquo;.
See section <a href="#SEC105">Interaction with Purify</a>, for more information about Purify options.
</p>
</dd>
<dt> &lsquo;<samp>--purify-opts <var>option-string</var></samp>&rsquo;</dt>
<dd><p>Use <var>option-string</var> as additional options to Rational Purify.
If this option is not specified on the command line, it defaults to
a system-specific value.
See section <a href="#SEC105">Interaction with Purify</a>, for more information about Purify options.
</p>
</dd>
<dt> &lsquo;<samp>--tmpdir <var>pathname</var></samp>&rsquo;</dt>
<dd><p>Put temporary files (the annotated &lsquo;<tt>.int.c</tt>&rsquo; files and temporary
object files created prior to linking) in the indicated directory.
If this option is not specified on the command line or in an options file,
it defaults to a system-specific default, &lsquo;<tt>/tmp/</tt>&rsquo; on Unix platforms or the
directory specified by the <code>TMP</code> or <code>TEMP</code> environment variables on
Windows.  The directory must exist and be writable.
</p>
</dd>
<dt> &lsquo;<samp>-v</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--verbose</samp>&rsquo;</dt>
<dd><p>Print commands (to <code>stderr</code>) before executing them.
</p>
</dd>
<dt> &lsquo;<samp>-n</samp>&rsquo;</dt>
<dd><p>Print commands (to <code>stderr</code>), but don't execute them.
</p></dd>
</dl>


<hr size="6">
<a name="Mangel-annotation-options"></a>
<a name="SEC99"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC98" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC100" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.4.2.3 Mangel annotation options </h4>

<p>Mangel passes these options to the wurzel preprocessor, which adds
instrumentation to the code and produces a &lsquo;<tt>.decls</tt>&rsquo; file for each
source file.
</p>
<dl compact="compact">
<dt> &lsquo;<samp>--decls-file <var>filename</var></samp>&rsquo;</dt>
<dd><p>Specify <var>filename</var> as the name of the &lsquo;<tt>.decls</tt>&rsquo; file for this
compilation unit.  If this option is not specified, declarations are
written to a file in the current directory with a name derived from
the current compilation unit.
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-file <var>filename</var></samp>&rsquo;</dt>
<dd><p>Specify <var>filename</var> as the name of the &lsquo;<tt>.dtrace</tt>&rsquo; file for this
program.  This option is only used if the compilation unit contains a
definition for <code>main</code>.  If this option is not specified, trace
output is written to a file in the current directory when the executable
is run, with a name derived from the file containing the definition of
<code>main</code>.
</p>
<p>If you specify a <var>filename</var> of &lsquo;<samp>-</samp>&rsquo;, trace output is written to
stdout.  In this case, regular program output to stdout is redirected to
the terminal (on Unix) or console (on Windows).  This allows you to
redirect trace output to a file or pipe on the command line, without
mingling the two output streams.
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-append</samp>&rsquo;</dt>
<dd><p>Specify that output should be appended to an existing &lsquo;<tt>.dtrace</tt>&rsquo; file,
rather than overwriting it.
This option is only used if the compilation unit contains a
definition for <code>main</code>.
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-gzip</samp>&rsquo;</dt>
<dd><p>Produce gzipped (compressed) trace output.
This is implemented by filtering the trace output through <code>gzip</code>.
This option is only used if the compilation unit contains a
definition for <code>main</code>.
</p>
<p>The runtime library invokes gzip as a subprocess, via a pipe.  If you
have gzip installed in a nonstandard location on your system, you can
specify its pathname using the <code>GZIP</code> environment variable.
</p>
</dd>
<dt> &lsquo;<samp>--ignore-globals</samp>&rsquo;</dt>
<dd><p>Ignore global, file-scope static, and function-scope static
variables when emitting program point state.
The default behavior is to emit declarations and trace information for
static variables and global variables
that are defined (not just declared as <code>extern</code>) in the compilation
unit and are in scope at the given program point,
as well as (for C++ class member functions) static member variables of
the containing class.
</p>
</dd>
<dt> &lsquo;<samp>--ignore-static-vars</samp>&rsquo;</dt>
<dd><p>Ignore file-scope and function-scope static variables when emitting
program point state, but include global variables defined in the compilation
unit.
</p>
</dd>
<dt> &lsquo;<samp>--nesting-depth <var>depth</var></samp>&rsquo;</dt>
<dd><p>Specify the recursion depth for examining fields of nested <code>struct</code>,
<code>union</code>, and <code>class</code> types.  The default value is 2.
</p>
</dd>
<dt> &lsquo;<samp>--flatten-arrays</samp>&rsquo;</dt>
<dd><p>This option forces the flattening of statically-sized arrays into
separate variables, one for each element.  For example, an array
<var>foo</var> of size 3 would be flattened into 3 variables: <var>foo[0]</var>,
<var>foo[1]</var>, <var>foo[2]</var>.  By default, Mangel-Wurzel flattens
arrays only after is has already exhausted the one level of sequences
that Daikon allows in the .dtrace output format.
</p>
</dd>
<dt> &lsquo;<samp>--max-flatten-array-size <var>size</var></samp>&rsquo;</dt>
<dd><p>Specify the maximum <var>size</var> of any dimension for arrays to be flattened.
The default value is 10, so that (for instance) a 10x10x20 array would be
broken down into 100 variables each containing a 20-element sequence.  If
any one dimension to be flattened is larger than <var>size</var>, then Mangel-Wurzel
doesn't output the contents of the array.
</p>
</dd>
<dt> &lsquo;<samp>--max-array-size <var>size</var></samp>&rsquo;</dt>
<dd><p>Specify the maximum <var>size</var> of one-dimensional arrays, which are
output as sequences in the .dtrace file.  If the static array dimension is
larger than <var>size</var>, then Mangel-Wurzel doesn't output the contents of
the array.  The default is 100.
</p>
</dd>
<dt> &lsquo;<samp>--ignore-system-structs</samp>&rsquo;</dt>
<dd><p>If you specify this option, Mangel-Wurzel ignores fields of
<code>struct</code>, <code>union</code>, and <code>class</code> types declared in system
include files (e.g., those included via the
&lsquo;<samp>#include &lt;<var>file.h</var>&gt;</samp>&rsquo; syntax rather than
&lsquo;<samp>#include &quot;<var>file.h</var>&quot;</samp>&rsquo;.)
These are typically interfaces like <code>FILE</code>
whose internal representations are not interesting to &ldquo;regular&rdquo;
programmers or portable across operating systems.
</p>
</dd>
<dt> &lsquo;<samp>--ppt-select-pattern <var>regex</var></samp>&rsquo;</dt>
<dd><p>Only emit program points that match <var>regex</var>.
Specifically, a program point is considered to match <var>regex</var> if any of
the function name, program point name, or containing class name (for C++)
match <var>regex</var>.
</p>
<p>This option can be specified multiple times, but cannot be used in
conjunction with &lsquo;<samp>--ppt-omit-pattern</samp>&rsquo;.
</p>

</dd>
<dt> &lsquo;<samp>--ppt-omit-pattern <var>regex</var></samp>&rsquo;</dt>
<dd><p>Suppress program points that match <var>regex</var>.
Specifically, a program point is considered to match <var>regex</var> if any of
the function name, program point name, or containing class name (for C++)
match <var>regex</var>.
</p>
<p>This option can be specified multiple times, but cannot be used in
conjunction with &lsquo;<samp>--ppt-select-pattern</samp>&rsquo;.
</p>
</dd>
</dl>

<hr size="6">
<a name="Options-files-for-Mangel"></a>
<a name="SEC100"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC99" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC101" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC96" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.4.2.4 Options files for Mangel </h4>

<p>In addition to specifying mangel options on the command line, you can
also put them in an options file.  This is most useful for customizing the
defaults for the configuration options (<a href="#SEC98">Mangel configuration options</a>) which control how wurzel and the host compiler and linker
should be invoked, but you can put any command-line options in the file.
</p>
<p>Mangel looks for an options file in the following places, and will use
the first one it finds.
</p>
<ol>
<li> &lsquo;<tt>.mangelrc</tt>&rsquo;
</li><li> &lsquo;<tt>$HOME/.mangelrc</tt>&rsquo;
</li><li> &lsquo;<tt>$MANGEL_DIR/.mangelrc</tt>&rsquo;
</li></ol>

<p>Option files are formatted with one option, or option/value pair, per
line.  Everything following the option keyword on the same line is
considered to be a value.  Value strings should not be quoted (even if they
contain embedded spaces).  Blank lines are ignored.
</p>
<p>Here is an example of an options file:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">--preprocessor wurzel
--preprocessor_opts --sys_include=/usr/include

--compiler cc
--compiler_opts -g -Dsetjmp=_setjmp -Dva_copy=__va_copy

--linker cc
--linker_opts -lstdc++

--purify purify
--purify_opts -log-file=/dev/null -append-logfile
</pre></td></tr></table>


<hr size="6">
<a name="Pointer_002farray-disambiguation-in-Mangel_002dWurzel"></a>
<a name="SEC101"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC100" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC102" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.4.3 Pointer/array disambiguation in Mangel-Wurzel </h3>

<p>Wurzel currently does not support any form of pointer/array
disambiguation.  In other words, an object of type &lsquo;<samp>int *</samp>&rsquo; is
treated as a pointer to a single integer, not as the address of an array
of <code>int</code>.  This is in contrast to the default behavior of Kvasir
(<a href="#SEC80">C/C++ front end Kvasir</a>), which assumes the more general case that pointers point to
arrays rather than single objects.  The difference in behavior is due
to differences in the underlying runtime support; Purify does not track
the length of arrays or provide an API for querying this information.
</p>
<p>Wurzel does, however, make use of static type information to emit trace
information for function arguments and global and static variables with
fully-defined array types as arrays.  Note that a &ldquo;fully-defined&rdquo; array type
includes a complete set of (constant) dimensions.
</p>
<p>Wurzel also assumes that variables with type <code>char *</code>, or arrays of
<code>char</code>, are likely to be null-terminated strings rather than pointers to
a single <code>char</code> object.  The runtime code which prints strings
first performs a &ldquo;sanity check&rdquo; to make sure the string is of
reasonable length and contains only printable characters (as determined by
the C library functions <code>isprint</code> and <code>isspace</code>) rather than
arbitrary byte values.  If these conditions are not met, the string is
printed as its first character followed by &lsquo;<samp>...</samp>&rsquo; (such as &lsquo;<samp>&quot;a...&quot;</samp>&rsquo;),
or as &ldquo;nonsensical&rdquo; if the first character is not printable.
</p>
<p>On the other hand, variables with type <code>signed char *</code> or
<code>unsigned char *</code>, or arrays of explicitly <code>signed</code> or
<code>unsigned char</code>, are treated as byte pointers or byte arrays,
respectively, and the elements print as normal integer values rather than
as strings.  Multidimensional <code>char</code> arrays also print as byte arrays
rather than as arrays of strings.
</p>

<hr size="6">
<a name="Mangel_002dWurzel-usage-notes"></a>
<a name="SEC102"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC101" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC103" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.4.4 Mangel-Wurzel usage notes </h3>

<p>You do not need to instrument all compilation units in a program with
Mangel-Wurzel if you are only interested in analyzing certain parts of it with
Daikon; you can simply compile the &ldquo;uninteresting&rdquo; files in the normal
way with your usual C compiler.  However, you must either instrument the
compilation unit including the definition of <code>main</code> so that the
necessary runtime initialization is performed when the program starts, or
insert an explicit call to <code>mw_init</code> in your program before any of the
instrumented code is executed.  You should also use mangel to link
your program.
</p>
<p>The wurzel preprocessor produces the same dialect of code that it receives as
input, that is C, C99, or C++.  It does not translate C++ to C.  This ensures
that preprocessed code is link-compatible with system C++ libraries and other
code that is not processed with wurzel.
</p>
<p>While wurzel recognizes standard C++, its support of instrumentation for
C++ programs is rather rudimentary at this point.  In particular, it
ignores anything having to do with templates.  Wurzel is smart enough to
only generate references to class fields that are accessible at a given
program point, to avoid errors in the compilation phase, but at this
time it will not also generate references to accessible base classes and
their members.  (This should be optional in any case because it will
greatly increase the number of variables at a given program point.)
</p>
<p>If you are using the C++ libraries that came with your host C++
compiler, you will probably have to add the locations of the include
files to the search path passed to wurzel, as well adding the libraries
themselves to your link options.
</p>
<p>If your source code uses extensions specific to a particular host compiler,
you may need to use the &lsquo;<samp>--gcc</samp>&rsquo; or &lsquo;<samp>--microsoft</samp>&rsquo; flags to enable
the appropriate compatibility mode.
Wurzel recognizes many other command-line options supported by the
underlying EDG front end to customize the language dialects it accepts,
as described in the EDG documentation.  You can set these options using
the &lsquo;<samp>--preprocessor-opts</samp>&rsquo; flag to mangel.
</p>
<p>If your code compiles with your host compiler, but not with
Mangel-Wurzel, you can try these approaches:
</p>
<ol>
<li> If you are getting compilation errors from wurzel that can't be resolved
with one of the above compatibility flags or with appropriate defines, a
possible workaround is to preprocess the code with the host compiler's
preprocessor before running it through Mangel-Wurzel.

</li><li> If you are getting compilation errors from the host C compiler, you can
use the &lsquo;<samp>-E</samp>&rsquo; option to mangel to produce a &lsquo;<tt>.int.c</tt>&rsquo; file
containing the code as preprocessed by wurzel, which you can examine to track
down the cause of the errors.

</li></ol>

<p>Note that since the output of wurzel is compilable source code, it is possible
to perform the preprocessing on one machine and then compile, link, and run
on another platform supported by Rational Purify.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC103">7.4.4.1 Using Mangel-Wurzel on Unix</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC104">7.4.4.2 Using Mangel-Wurzel on Windows</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Using-Mangel_002dWurzel-on-Unix"></a>
<a name="SEC103"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC102" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC104" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC102" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.4.4.1 Using Mangel-Wurzel on Unix </h4>

<p>GCC is the standard compiler on most Unix-based systems.  You may find
it necessary to specify the &lsquo;<samp>--gcc</samp>&rsquo; option to wurzel to make it
correctly process system
include files, even if your code doesn't use GCC extensions itself.
</p>
<p>Not all of the preprocessor symbols predefined by GCC's cpp are correctly
predefined by the EDG front end's GCC compatibility mode, so you may
need to specify some of these preprocessor symbols yourself.  If you run
into such preprocessing errors, consider creating a &lsquo;<tt>mwdefines.h</tt>&rsquo; file
instead of trying to define every necessary macro on the command line
for wurzel:
</p>
<ol>
<li> Create a file with a list of all of cpp's
built-in defines: &lsquo;<samp>cpp -dM &gt; mwdefines.h</samp>&rsquo;

</li><li>
Edit the file, wrapping each of the &lsquo;<samp>#define</samp>&rsquo;s in an
&lsquo;<samp>#ifndef...#endif</samp>&rsquo; to prevent multiple definition.

</li><li> In the &lsquo;<samp>--preprocessor-opts</samp>&rsquo; value in your &lsquo;<tt>.mangelrc</tt>&rsquo;, add
&lsquo;<samp>--preinclude=<var>filename</var></samp>&rsquo;, where <var>filename</var> is the name of your
new &lsquo;<tt>mwdefines.h</tt>&rsquo; file.
</li></ol>


<hr size="6">
<a name="Using-Mangel_002dWurzel-on-Windows"></a>
<a name="SEC104"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC103" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC105" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC102" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h4 class="subsubsection"> 7.4.4.2 Using Mangel-Wurzel on Windows </h4>

<p>Rational Purify on Windows only supports the Microsoft Visual C/C++ compiler,
not GCC.  Therefore Mangel-Wurzel will only work with the Microsoft compiler
on this platform as well.  Currently, Mangel-Wurzel is not integrated with
the Visual Studio IDE, and runs as a command-line utility only.
</p>
<p>You can run Mangel-Wurzel and programs instrumented with Mangel-Wurzel
from within a Cygwin shell, Makefile, and the like, as well as from the
default Windows &lsquo;<samp>cmd</samp>&rsquo; shell in a console window.  However, another
limitation of Rational Purify on Windows is that instrumented
executables will only run from a console window, not an XTerm or other
Cygwin pty.  (This is because Purify, like some other Windows console programs,
does not like having its standard input or output redirected to pipes.)
</p>
<p>Since Mangel-Wurzel runs as a regular Windows console application, it
expects all pathname arguments and environment variables to be in
regular Windows pathname syntax even when you run it from inside a
Cygwin shell.
</p>


<hr size="6">
<a name="Interaction-with-Purify"></a>
<a name="SEC105"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC104" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC106" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.4.5 Interaction with Purify </h3>

<p>If you are interested in obtaining Purify diagnostics for your code, you
should run Purify on the uninstrumented program.  The remainder of this
section explains why this is the case.  It is not necessary to fix all
the problems that Purify diagnoses before running Mangel-Wurzel.
However, fixing them is likely to correct bugs and make your code more
robust, so it is recommended.
</p>
<p>Mangel-Wurzel's runtime library relies on the Purify API to test the
validity of pointers &mdash; in particular, to check for pointers to
unallocated memory and pointers to memory that has been allocated but
not initialized.  It performs these checks so that it can avoid
dereferencing bad pointers and uninitialized variables when printing
values at program points to the &lsquo;<tt>.dtrace</tt>&rsquo; file.  (Instead,
it prints a value of &ldquo;nonsensical&rdquo; for those variables, which has a
special meaning to Daikon (see <a href="..//Nonsensical-values.html#Nonsensical-values">(./developer)Nonsensical values</a> section `Nonsensical values' in <cite>Daikon Developer Manual</cite>).)
</p>
<p>Both the Unix and Windows versions of Purify have problems identifying
uninitialized variables on the stack.  In Mangel-Wurzel, this manifests
itself by uninitialized block-scope automatic variables sometimes
printing as garbage values rather than as &ldquo;nonsensical&rdquo;, which in turn
might cause Daikon to find inaccurate invariants.
</p>
<p>Normally, mangel is configured to tell Purify to discard all of its
diagnostic messages.  This is because, due to limitations of the Purify
API, it isn't possible for the Mangel-Wurzel runtime to run Purify
completely silently, and the diagnostics will contain bogus messages
generated by the Mangel-Wurzel runtime as well as genuine diagnostics
about the program that has been instrumented.
</p>
<p>Specifically, since the Unix versions of Purify don't provide any API
functions
for checking the validity of pointers without generating messages, the
Mangel-Wurzel runtime works around this by enabling message batching and
by discarding the batched messages as processing of each program point
is completed.
</p>

<hr size="6">
<a name="Installing-Mangel_002dWurzel"></a>
<a name="SEC106"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC105" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC107" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC94" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.4.6 Installing Mangel-Wurzel </h3>

<p>Since Mangel-Wurzel is based on the proprietary EDG C/C++ front end, we
distribute it, at <a href="http://pag.csail.mit.edu/daikon/download/">http://pag.csail.mit.edu/daikon/download/</a>, in
binary rather than source format.  (If the web page does not currently
contain a binary for your architecture, send mail to
<a href="mailto:daikon-developers@lists.csail.mit.edu">daikon-developers@lists.csail.mit.edu</a> and we may be able to
produce one for you.)  The distribution does not include Purify, which
you must install separately (either purchase it or download an
evaluation copy).
</p>
<p>Installation requires unpacking the distribution, setting the
<code>MANGEL_DIR</code> and <code>PURIFY_DIR</code> environment
variables, optionally customizing the defaults for how mangel operates,
and optionally running its tests.
</p>

<ol>
<li>
Download the archive from
<a href="http://pag.csail.mit.edu/daikon/download/">http://pag.csail.mit.edu/daikon/download/</a> and unpack it in the
parent of the directory where you wish to install Mangel-Wurzel.
Unpacking creates a directory named &lsquo;<tt>mangel-wurzel</tt>&rsquo;.
<ul class="toc">
<li>
On the Linux/x86 platform, execute these two commands (other Unix
platforms are similar):

<table><tr><td>&nbsp;</td><td><pre class="smallexample">wget http://pag.csail.mit.edu/daikon/download/binaries/mangel-wurzel-linux-x86.tar.gz
tar xvzf mangel-wurzel-linux-x86.tar.gz
</pre></td></tr></table>

</li><li>
On Windows, download, then unzip,
<a href="http://pag.csail.mit.edu/daikon/download/binaries/mangel-wurzel-linux-x86.tar.gz">http://pag.csail.mit.edu/daikon/download/binaries/mangel-wurzel-linux-x86.tar.gz</a> .

</li></ul>

</li><li>
Set these environment variables:

<dl compact="compact">
<dt> <code>MANGEL_DIR</code></dt>
<dd><a name="IDX107"></a>
<p>Set to the full pathname of the &lsquo;<tt>mangel-wurzel</tt>&rsquo; directory.
</p></dd>
<dt> <code>PATH</code></dt>
<dd><p>Add &lsquo;<tt><var>MANGEL_DIR</var>/bin</tt>&rsquo; to your path.
</p></dd>
<dt> <code>PURIFY_DIR</code></dt>
<dd><a name="IDX108"></a>
<p>Set to the directory in your Purify distribution containing
&lsquo;<tt>libpurify_stubs.a</tt>&rsquo;.
</p></dd>
</dl>

</li><li>
Customize the default commands and options mangel uses to
invoke the wurzel preprocessor, the host compiler and linker, and
Purify.  Make these changes in the system options file
&lsquo;<tt>mangel-wurzel/.mangelrc</tt>&rsquo;; see <a href="#SEC100">Options files for Mangel</a> for
details about the format of this file.

<p>A suggested version of &lsquo;<tt>.mangelrc</tt>&rsquo; for each supported platform is
included with the distribution.  For example, &lsquo;<tt>.mangelrc.linux</tt>&rsquo; is
provided for Linux.  You should copy the appropriate file to &lsquo;<tt>.mangelrc</tt>&rsquo;
and make any necessary changes there.  The most likely things you may need to
customize are:
</p>
<ul class="toc">
<li> Make sure that the &lsquo;<samp>--compiler</samp>&rsquo; and &lsquo;<samp>--linker</samp>&rsquo; commands are
correct.  For example, if you want to use gcc, on some systems you may
need to specify &lsquo;<samp>gcc</samp>&rsquo; explicitly instead of &lsquo;<samp>cc</samp>&rsquo;, or use a
full pathname.  On Windows, you should use &lsquo;<samp>cl</samp>&rsquo; only.

</li><li> You may need to alter the default system include paths, specified with
&lsquo;<samp>--sys_include</samp>&rsquo; in the &lsquo;<samp>--preprocessor_opts</samp>&rsquo; option.  See
<a href="#SEC103">Using Mangel-Wurzel on Unix</a>, and <a href="#SEC104">Using Mangel-Wurzel on Windows</a>,
for details.

<ul class="toc">
<li>
On Unix, you must specify the full set of search paths for include files in
your &lsquo;<tt>.mangelrc</tt>&rsquo; file, since these are normally hard-wired into GCC
instead of configured with an environment variable.
These include your gcc include directory (run &lsquo;<samp>gcc
-print-libgcc-file-name | sed s/libgcc.a/include/</samp>&rsquo;),
&lsquo;<tt>/usr/local/include</tt>&rsquo;, and &lsquo;<tt>/usr/include</tt>&rsquo; (after the gcc
include directory).

</li><li>
On Windows, Mangel-Wurzel uses the same <code>INCLUDE</code> environment variable as the
Microsoft compiler to set up the system include paths, so in theory you
should not have to specify any additional paths in your &lsquo;<tt>.mangelrc</tt>&rsquo;
configuration file.
Do be sure that you specify &lsquo;<samp>cl</samp>&rsquo; (the Microsoft C compiler) for
both the &lsquo;<samp>--compiler</samp>&rsquo; and &lsquo;<samp>--linker</samp>&rsquo; options and that you have
your <code>PATH</code> environment variable set up to include both the path to the
cl compiler and related Visual C utilities, and the path for Rational Purify.

<p>Make sure you set up your &lsquo;<tt>.mangelrc</tt>&rsquo; to compile with debugging
information enabled; otherwise Rational Purify does not detect
uninitialized memory references, which is a critical feature for
Mangel-Wurzel's data structure traversal.  On Windows, Purify also has
problems reliably detecting uninitialized stack locations which manifest
themselves in Mangel-Wurzel as uninitialized block-scope automatic
variables sometimes being reported as having garbage values instead of as
being &ldquo;nonsensical&rdquo;, which is treated specially by Daikon
(see <a href="..//Nonsensical-values.html#Nonsensical-values">(./developer)Nonsensical values</a> section `Nonsensical values' in <cite>Daikon Developer Manual</cite>).
</p>
<p>You will probably need to specify the &lsquo;<samp>--microsoft</samp>&rsquo; compatibility mode
option as the default in your &lsquo;<tt>.mangelrc</tt>&rsquo; file.
</p>
</li></ul>

</li><li> You might also want to add some additional options, such as specifying
&lsquo;<samp>--gcc</samp>&rsquo; or &lsquo;<samp>--microsoft</samp>&rsquo; to enable the appropriate compatibility
mode for your normal C compiler by default.
</li></ul>

<p>For debugging the options file, you can use the &lsquo;<samp>-n</samp>&rsquo; or
&lsquo;<samp>-v</samp>&rsquo; options to see the actual commands mangel is generating to
invoke each phase.
</p>
</li><li>
Optionally (but recommended), run Mangel-Wurzel's tests.
<table><tr><td>&nbsp;</td><td><pre class="example">cd tests
make
</pre></td></tr></table>

</li></ol>



<hr size="6">
<a name="dfepl"></a>
<a name="SEC107"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC106" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC108" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.5 Perl front end dfepl </h2>


<p>This section contains details about dfepl, the Daikon front end for
Perl.  For a brief introduction to dfepl, see <a href="daikon_3.html#SEC26">Perl examples</a> and
<a href="daikon_3.html#SEC25">Instrumenting Perl programs</a>.
</p>
<p>dfepl works with Perl versions 5.8 and later. (To be precise, Perl
programs instrumented with dfepl can also be run with Perl 5.6, but
the instrumentation engine, which is itself written in Perl, requires
version 5.8).  dfepl reads the source code for Perl modules or
programs, and writes out instrumented versions of that code that
keep track of function parameters, and make calls to routines in the
&lsquo;<tt>daikon_runtime</tt>&rsquo; package whenever an instrumented subroutine is
entered or exited.
</p>
<p>The instrumentation engine recognizes parameters as those variables
that are declared with <code>my(...)</code> or <code>local(...)</code> and, in the
same expression, assigned to from a value related to the argument
array <code>@_</code>, but only among the first contiguous series of such
assignments in the body of a subroutine.  This will capture the most
common assignment idioms, such as <code>my $self = shift;</code> (where
<code>shift</code> is short for <code>shift @_</code>), <code>my $x = $_[0];</code>, and
<code>my($x, $y, @a) = @_;</code>, but the arguments to subroutines which
access them only directly through <code>@_</code>, or that perform other
operations before reading their arguments, will not be recognized.
</p>
<p>If the uninstrumented code requested warnings via the <code>use
warnings</code> pragma or by adding the &lsquo;<samp>-w</samp>&rsquo; flag on the <code>#!</code>
line, the instrumented code will also request warnings.  In this case,
or if &lsquo;<samp>-w</samp>&rsquo; is specified on the command line when running it, the
instrumented code may produce warnings that the original code did
not.  There are several situations in which the instrumented code
produced by dfepl, while functionally equivalent to the original,
generates more warnings.  The most common such problem, which arises
from code that captures the scalar-context return value of a
subroutine that returns a list, has been avoided in the current
version by disabling the warning in question.  Other warnings which
are known to be produced innocuously in this way include
&lsquo;<samp>Ambiguous call resolved as CORE::foo(), qualify as such or use
&amp;</samp>&rsquo; (caused by code that uses <code>CORE::</code> to distinguish a built-in
function from a user subroutine of the same name), and &lsquo;<samp>Constant
subroutine foo redefined</samp>&rsquo; (caused by loading both instrumented and
uninstrumented versions of a file).  Though some such warnings
represent deficiencies in the instrumentation engine, they can be
safely ignored when they occur.
</p>
<p>Because Perl programs do not contain static type information to
distinguish, for instance, between strings and numbers, the Perl
front end incorporates an additional dynamic analysis to infer these
types.  This type guessing, which occurs as a first pass before the
program can be instrumented to produce output for Daikon, operates in
a manner somewhat analogous to Daikon itself: watching the execution
of a program, the runtime system chooses the most restrictive type for
a variable that is not contradicted during that execution.  These
types indicate, for instance, whether a scalar value always holds an
integer, a possibly fractional numeric value, or a reference to
another object.  It should not be necessary to examine or modify this
type information directly, but for the curious, the syntax of the type
information is described in comments in the &lsquo;<tt>Daikon::PerlType</tt>&rsquo;
module.
</p>
<p>The safest course is to infer types for variables using exactly the
same program executions (e.g., test cases) which will later be used to
generate traces for Daikon, as this guarantees that the type
information will match the actual data written to the trace file.
However, because the type-guessing-instrumented versions of programs
run fairly slowly in the current version, you may be tempted to use a
subset of the input data for type guessing.  Doing so is possible, but
it will only work correctly if the smaller tests exercise all of the
instrumented subroutines and exit points with all the types of data
they will later be used with.  If the trace runtime tries to output a
data value that doesn't match the inferred type, the value may
silently be converted according to Perl's usual conventions (for
instance, a non-numeric string may be treated as the number zero), or
it may cause an error during tracing (for instance, trying to
dereference a supposed array reference that isn't).  Also, if a
subroutine exit point is traced but was never encountered during type
guessing, the generated &lsquo;<tt>.decls</tt>&rsquo; and &lsquo;<tt>.dtrace</tt>&rsquo; files will be
incompatible in a way that will cause Daikon to abort with an error
message of the form &lsquo;<samp>Program point foo():::EXIT22 appears in dtrace
file but not in any decl file</samp>&rsquo;.
</p>
<div class="float"><a name="dfepl_002dflow"></a>
<p align="center"> <img src=".././images/dfepl-flow.jpg" alt="images/dfepl-flow">
</p>
</div><p><strong>Figure 7.1: Workflow of instrumenting Perl code with dfepl.
</strong>
</p>
<p>dfepl works by reading one or more Perl programs
or modules, and writing out new versions of those files, instrumented
to capture information about their execution, by default to another
directory.  dfepl is used in two passes: first, before type
information is available, instrumented versions are written to a
directory &lsquo;<tt>daikon-untyped</tt>&rsquo;.  These untyped programs, when run,
will write
files containing dynamically inferred type information (with the
extension &lsquo;<tt>.types</tt>&rsquo;), by default to the &lsquo;<tt>daikon-instrumented</tt>&rsquo;
directory.  When dfepl is rerun with this type information, it
produces type-aware instrumented code in the
&lsquo;<tt>daikon-instrumented</tt>&rsquo; directory, which when run produces
execution traces in files with the extension &lsquo;<tt>.dtrace</tt>&rsquo; in the a
directory &lsquo;<tt>daikon-output</tt>&rsquo;.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC108">7.5.1 dfepl options</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               
</td></tr>
</table>

<hr size="6">
<a name="dfepl-options"></a>
<a name="SEC108"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC107" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC109" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC107" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 7.5.1 dfepl options </h3>

<dl compact="compact">
<dt> &lsquo;<samp>--absolute</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--no-absolute</samp>&rsquo;</dt>
<dd><p>&lsquo;<samp>--absolute</samp>&rsquo; stores the absolute path to the output directories
(by default named &lsquo;<tt>daikon-untyped</tt>&rsquo;, &lsquo;<tt>daikon-instrumented</tt>&rsquo; or
&lsquo;<tt>daikon-output</tt>&rsquo;) in the instrumented programs, so that no matter
where the instrumented program is run, the output will go to a fixed
location.  Even if these directories are given as relative paths (as is
the default), &lsquo;<samp>--absolute</samp>&rsquo; specifies that they should always be
taken as relative to the directory that was the working directory when
dfepl was run.
</p>
<p>&lsquo;<samp>--no-absolute</samp>&rsquo; specifies the opposite, causing the output paths
to be interpreted relative to the current working directory each time
the instrumented program is invoked.  The default, when neither option
is specified, is for &lsquo;<tt>.types</tt>&rsquo; files to use an absolute path, but
all others to use relative path, so that the &lsquo;<tt>.types</tt>&rsquo; files will
always be in the same place as the instrumented source files that
generated them, but the &lsquo;<tt>daikon-output</tt>&rsquo; directory will be created
in the current directory when the program runs.
</p>
</dd>
<dt> &lsquo;<samp>--accessor-depth=<var>num</var></samp>&rsquo;</dt>
<dd><p>Controls the number of nested invocations of object accessor methods
to examine.  For instance, suppose that the <code>Person</code> class has a
method <code>mother()</code> that returns another person (and has been
specified to dfepl as an accessor), and that <code>$me</code> is
an instrumented variable.  If the accessor depth is 1, only
<code>$me-&gt;mother()</code> will be examined.  If the depth is 2,
<code>$me-&gt;mother()-&gt;mother()</code> will also be examined.  Specifying large
accessor depths is generally not advisable, especially with many
accessor methods, as the number of variables examined can be too many
for Daikon to process efficiently.
</p>
<p>By default, the Daikon Perl trace runtime will examine at most a
single level of accessors.
</p>
</dd>
<dt> &lsquo;<samp>-A</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--accessors-dir=<var>directory</var></samp>&rsquo;</dt>
<dd><p>Look for files containing accessor lists in <var>directory</var>, or the
current directory if <var>directory</var> is omitted.  For a class
<code>Acme::Foo</code>, accessors are methods that return information about
an object but do not modify it.  dfepl cannot determine on
its own which methods are accessors, but when a list of them is
provided, it can call an object's accessors when examining a variable
of that class to obtain more information about the object.  To tell
dfepl about the accessors for <code>Acme::Foo</code>, make a file
listing the names of each accessor method, one per line with no other
punctuation, named &lsquo;<tt>Acme/Foo.accessors</tt>&rsquo; in the same directory as
&lsquo;<tt>Acme/Foo.pm</tt>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--decls-dir=<var>directory</var></samp>&rsquo;</dt>
<dd><p>Put generated declaration files in <var>directory</var> and its
subdirectories.  The default is &lsquo;<tt>daikon-output</tt>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--decls-style=<var>style</var></samp>&rsquo;</dt>
<dd><p><var>style</var> should be one of &lsquo;<samp>combined</samp>&rsquo;, &lsquo;<samp>flat</samp>&rsquo;, or
&lsquo;<samp>tree</samp>&rsquo;.  A style of &lsquo;<samp>combined</samp>&rsquo; specifies that the
declarations for all packages should be merged, in a file named
&lsquo;<tt>prog-combined.decls</tt>&rsquo; where &lsquo;<tt>prog</tt>&rsquo; is the name of the
program.  A style of &lsquo;<samp>flat</samp>&rsquo; specifies that the declarations for
each package should be in a separate file named after the package, but
that these files should go in a single directory; for instance, the
declarations for <code>Acme::Trampoline</code> and
<code>Acme::Skates::Rocket</code> would go in files named
&lsquo;<tt>Acme::Trampoline.decls</tt>&rsquo; and &lsquo;<tt>Acme::Skates::Rocket.decls</tt>&rsquo;.  A
style of &lsquo;<samp>tree</samp>&rsquo; specifies that each package should have its own
declarations file, and that those files should be arranged in
directories whose structure matches the structure of their package
names; in the example above, the files would be
&lsquo;<tt>Acme/Trampoline.decls</tt>&rsquo; and &lsquo;<tt>Acme/Skates/Rocket.decls</tt>&rsquo;.
</p>
<p>The default is &lsquo;<samp>tree</samp>&rsquo;.  Note that &lsquo;<samp>--decls-style</samp>&rsquo; and
&lsquo;<samp>--types-style</samp>&rsquo; are currently constrained to be the same; if
one is specified, the other will use the same value.
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-append</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--no-dtrace-append</samp>&rsquo;</dt>
<dd><p>When &lsquo;<samp>--dtrace-append</samp>&rsquo; is specified, the instrumented program
will append trace information to the appropriate
&lsquo;<tt>.dtrace</tt>&rsquo; file each time it runs.  When
&lsquo;<samp>--no-dtrace-append</samp>&rsquo; is specified, it will overwrite the file
instead.
</p>
<p>The default behavior is to overwrite.  This choice can also be
overridden, when the program is run, to always append by setting the
environment variable <code>DTRACEAPPEND</code> to 1.
</p>
<p>When appending to a &lsquo;<tt>.dtrace</tt>&rsquo; file, no declaration information is
ever produced, because it would be redundant to do so and Daikon does
not permit re-declarations of program points.
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-dir=<var>directory</var></samp>&rsquo;</dt>
<dd><p>Put generated trace files in <var>directory</var> and its
subdirectories.  The default is &lsquo;<tt>daikon-output</tt>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--dtrace-style=<var>style</var></samp>&rsquo;</dt>
<dd><p><var>style</var> should be one of &lsquo;<samp>combined</samp>&rsquo;, &lsquo;<samp>flat</samp>&rsquo;, or
&lsquo;<samp>tree</samp>&rsquo;.  A style of &lsquo;<samp>combined</samp>&rsquo; specifies that the traces
for all packages should be merged, in a file named
&lsquo;<tt>prog-combined.dtrace</tt>&rsquo;, where &lsquo;<tt>prog</tt>&rsquo; is the name of the
program.  A style of &lsquo;<samp>flat</samp>&rsquo; specifies that the
traces for each package should be in a separate file named after the
package, but that these files should go in a single directory; for
instance, the declarations for <code>Acme::Trampoline</code> and
<code>Acme::Skates::Rocket</code> would go in files named
&lsquo;<tt>Acme::Trampoline.dtrace</tt>&rsquo; and
&lsquo;<tt>Acme::Skates::Rocket.dtrace</tt>&rsquo;.  A style of &lsquo;<samp>tree</samp>&rsquo; specifies
that each package should have its own trace file, and that
those files should be arranged in directories whose structure matches
the structure of their package names; in the example above, the files
would be &lsquo;<tt>Acme/Trampoline.dtrace</tt>&rsquo; and
&lsquo;<tt>Acme/Skates/Rocket.dtrace</tt>&rsquo;.
</p>
<p>The default is &lsquo;<samp>combined</samp>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--help</samp>&rsquo;</dt>
<dd><p>Print a short options summary.
</p>
</dd>
<dt> &lsquo;<samp>--instr-dir=<var>directory</var></samp>&rsquo;</dt>
<dt> &lsquo;<samp>--instrsourcedir=<var>directory</var></samp>&rsquo;</dt>
<dd><p>Put instrumented source files in <var>directory</var> and its
subdirectories.  The default is &lsquo;<tt>daikon-untyped</tt>&rsquo;, or
&lsquo;<tt>daikon-instrumented</tt>&rsquo; if type information is available.
</p>
</dd>
<dt> &lsquo;<samp>--list-depth=<var>DEPTH</var></samp>&rsquo;</dt>
<dd><p>Consider as many as <var>DEPTH</var> of the first elements of a list to be
distinct entities, for the purpose of guessing their types.  When
subroutines return a list of values, each value may have a distinct
meaning, or the list may be homogeneous.  When trying to assign types
to the elements of a list, the Daikon Perl trace runtime will try
making separate guesses about the types of the elements of a short
list, but it would be inefficient to make retain this distinction for
many elements.  This parameter controls how many elements of a list
will be examined individually; all the others will be treated
uniformly.
</p>
<p>The default is 3.
</p>
</dd>
<dt> &lsquo;<samp>--output-dir=<var>directory</var></samp>&rsquo;</dt>
<dd><p>Put all of the files that are the output of the tracing process (and
therefore input to the Daikon invariant detection engine) in
<var>directory</var> and its subdirectories.  This option is a shorthand
equivalent to setting both &lsquo;<samp>--decls-dir</samp>&rsquo; and
&lsquo;<samp>--dtrace-dir</samp>&rsquo; to the same value.
</p>
<p>The default behavior is as if &lsquo;<samp>--output-dir=daikon-output</samp>&rsquo; had
been specified.
</p>
</dd>
<dt> &lsquo;<samp>--perl=<var>path</var></samp>&rsquo;</dt>
<dd><p>Use <var>path</var> as the location of Perl when calling the annotation
back end (a module named <code>B::DeparseDaikon</code>), rather than the
version of Perl under which <code>dfepl</code> itself is running, which
is probably the first <code>perl</code> that occurs on your path.  For
instance, if the first version of <code>perl</code> on your path isn't
version 5.8 or later, you should this option to specify another
<code>perl</code> program that is.
</p>
</dd>
<dt> &lsquo;<samp>--nesting-depth=<var>num</var></samp>&rsquo;</dt>
<dd><p>When examining nested data structures, traverse as many as <var>num</var>
nested references.  For instance, suppose that <code>@a</code> is the array
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">@a = ({1 =&gt; [2, 3]}, {5 =&gt; [4, 2]})
</pre></td></tr></table>

<p>If the depth is 0, then when examining <code>@a</code>, Daikon's Perl trace
runtime will consider it to be an array whose elements are references,
but it won't examine what those references point to.  If the depth is
1, it will consider it to be an array of references to hashes whose
keys are integers and whose values are references, but it won't
examine what <em>those</em> references point to.  Finally, if the depth
is 2 or more, it will consider <code>@a</code> to be an array of references
to hashes whose keys are integers and whose values are references to
arrays of integers.
</p>
<p>The default nesting depth is 3.
</p>
<p>When referenced objects have accessor methods, or when accessors
return references, the &lsquo;<samp>--accessor-depth</samp>&rsquo; and
&lsquo;<samp>--nesting-depth</samp>&rsquo; options interact.  Specifically, if these
depths are A and R, the behavior is as if the runtime has a budget of
1 unit, which it can use either on accessors which cost 1/A or
references which cost 1/R.  It may thus sometimes be useful to specify
fractional values for &lsquo;<samp>--accessor-depth</samp>&rsquo; and
&lsquo;<samp>--nesting-depth</samp>&rsquo;; in fact, the default accessor depth is
1.5.
</p>
</dd>
<dt> &lsquo;<samp>--types-append</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--no-types-append</samp>&rsquo;</dt>
<dd><p>When &lsquo;<samp>--types-append</samp>&rsquo; is specified, the instrumented program
will append type information to the appropriate
&lsquo;<tt>.types</tt>&rsquo; file each time it runs.  When
&lsquo;<samp>--no-types-append</samp>&rsquo; is specified, it will overwrite the file
instead.
</p>
<p>The default behavior is to append.  If &lsquo;<samp>--no-types-append</samp>&rsquo; is
specified, however, this choice can also be overridden, when the
program is run, to append by setting the environment variable
<code>TYPESAPPEND</code> to 1.  There is no way to use environment variables
to force the runtime to overwrite a types file, but an equivalent
effect can be obtained by simply removing the previous types file
before each run.
</p>
</dd>
<dt> &lsquo;<samp>-T</samp>&rsquo;</dt>
<dt> &lsquo;<samp>--types-dir=<var>directory</var></samp>&rsquo;</dt>
<dd><p>Look for &lsquo;<tt>.types</tt>&rsquo; files in <var>directory</var>, or
&lsquo;<tt>daikon-instrumented</tt>&rsquo; if <var>directory</var> is omitted.  When
instrumenting a module <code>Acme::Trampoline</code>, used in a program
&lsquo;<tt>coyote.pl</tt>&rsquo;,  dfepl will look for
files named &lsquo;<tt>coyote-combined.types</tt>&rsquo;, &lsquo;<tt>Acme::Trampoline.types</tt>&rsquo;, and
&lsquo;<tt>Acme/Trampoline.types</tt>&rsquo;, corresponding to the possible choices of
&lsquo;<samp>--types-style</samp>&rsquo;.  Once discovered, the files are used in the
same way as for &lsquo;<samp>-t</samp>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--types-file=<var>file</var></samp>&rsquo;</dt>
<dt> &lsquo;<samp>-t <var>file</var></samp>&rsquo;</dt>
<dd><p>Include type information from <var>file</var> when instrumenting programs
or modules.  Since Daikon needs to know the types of variables when
they are declared, useful &lsquo;<tt>.decls</tt>&rsquo; and &lsquo;<tt>.dtrace</tt>&rsquo; files can
only be produced by source code instrumented with type
information.  Since Perl programs don't include this information to
begin with, and it would be cumbersome to produce by hand, type
information must usually be produced by running a version of the
program that has itself been annotated, but without type
information.  The Daikon Perl trace runtime will automatically decide
whether to output types, or declarations and traces, depending on
whether the source was instrumented without or with types.  This option
may occur multiple times, to read information from multiple types
files (irrelevant type information will be ignored).
</p>
</dd>
<dt> &lsquo;<samp>--types-basedir=<var>directory</var></samp>&rsquo;</dt>
<dd><p>Put files containing type information in <var>directory</var> and its
subdirectories.  By default, this is whatever &lsquo;<samp>--instr-dir</samp>&rsquo;
is, usually &lsquo;<tt>daikon-instrumented</tt>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>--types-style=<var>style</var></samp>&rsquo;</dt>
<dd><p><var>style</var> should be one of &lsquo;<samp>combined</samp>&rsquo;, &lsquo;<samp>flat</samp>&rsquo;, or
&lsquo;<samp>tree</samp>&rsquo;.  A style of &lsquo;<samp>combined</samp>&rsquo; specifies that the types
for all packages should be merged, in a file named
&lsquo;<tt>prog-combined.types</tt>&rsquo;, where &lsquo;<tt>prog</tt>&rsquo; is the name of the
program.  A style of &lsquo;<samp>flat</samp>&rsquo; specifies that the
types for each package should be in a separate file named after the
package, but that these files should go in a single directory; for
instance, the declarations for <code>Acme::Trampoline</code> and
<code>Acme::Skates::Rocket</code> would go in files named
&lsquo;<tt>Acme::Trampoline.types</tt>&rsquo; and
&lsquo;<tt>Acme::Skates::Rocket.types</tt>&rsquo;.  A style of &lsquo;<samp>tree</samp>&rsquo; specifies
that each package should have its own trace file, and that
those files should be arranged in directories whose structure matches
the structure of their package names; in the example above, the files
would be &lsquo;<tt>Acme/Trampoline.types</tt>&rsquo; and
&lsquo;<tt>Acme/Skates/Rocket.types</tt>&rsquo;.
</p>
<p>The default is &lsquo;<samp>tree</samp>&rsquo;.  Note that &lsquo;<samp>--types-style</samp>&rsquo; and
&lsquo;<samp>--decls-style</samp>&rsquo; are currently constrained to be the same; if
one is specified, the other will use the same value.
</p>
</dd>
<dt> &lsquo;<samp>--verbose</samp>&rsquo;</dt>
<dt> &lsquo;<samp>-v</samp>&rsquo;</dt>
<dd><p>Print additional information about what dfepl is doing,
including external commands invoked.
</p></dd>
</dl>


<hr size="6">
<a name="convertcsv_002epl"></a>
<a name="SEC109"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC108" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC110" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.6 Comma-separated-value front end convertcsv.pl </h2>


<p>Daikon can process data from spreadsheets such as Excel.  In order to
use such files, first save them in <a href="http://en.wikipedia.org/wiki/Comma-separated_values">comma-separated-value</a>, also known
as csv or comma-delimited or comma-separated-list, format.
Then, convert the &lsquo;<tt>.csv</tt>&rsquo; file into a &lsquo;<tt>.dtrace</tt>&rsquo; file (and a
&lsquo;<tt>.decls</tt>&rsquo; file) to be used by Daikon by running the
<code>convertcsv.pl</code> program found in the &lsquo;<tt>$DAIKONDIR/bin</tt>&rsquo;
directory.  For example,
</p><table><tr><td>&nbsp;</td><td><pre class="example">convertcsv.pl myfile.csv
</pre></td></tr></table>
<p>produces files &lsquo;<tt>myfile.decls</tt>&rsquo; and &lsquo;<tt>myfile.dtrace</tt>&rsquo;.
</p>
<p>Important:  run <code>convertcsv.pl</code> without any arguments in order
to see a usage message.
</p>
<p>In order to ensure all data is processed, use Daikon with the 
&lsquo;<samp>--nohierarchy</samp>&rsquo; option, as follows: 
</p><table><tr><td>&nbsp;</td><td><pre class="example">java daikon.Daikon --nohierarchy myfile.decls myfile.dtrace
</pre></td></tr></table>
<p>In a future release, the &lsquo;<samp>--nohierarchy</samp>&rsquo; option may not be necessary,
but it should always be safe to use this option.
</p>
<p>Before running <code>convertcsv.pl</code>, you may need to install
Text::CSV, a Perl package that <code>convertcsv.pl</code> uses.
</p>

<hr size="6">
<a name="Other-front-ends"></a>
<a name="SEC110"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC109" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC68" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 7.7 Other front ends </h2>

<p>It is relatively easy to create a Daikon front end for another language
or run-time system.  For example, people have done this without any help
at all from the Daikon developers.  For more information about building
a new front end, see <a href="..//New-front-ends.html#New-front-ends">(./developer)New front ends</a> section `New front ends' in <cite>Daikon Developer Manual</cite>.
</p>
<a name="IDX109"></a>
<a name="IDX110"></a>
<a name="IDX111"></a>

<p>A front end for the Eiffel programming language is distributed
separately; see <a href="http://se.inf.ethz.ch/people/polikarpova/citadel.html">http://se.inf.ethz.ch/people/polikarpova/citadel.html</a>.
</p>
<a name="IDX112"></a>
<a name="IDX113"></a>
<a name="IDX114"></a>

<p>A front end for the IOA programming language is distributed separately;
see <a href="http://groups.csail.mit.edu/tds/ioa.html">http://groups.csail.mit.edu/tds/ioa.html</a>.
</p>
<a name="IDX115"></a>
<a name="IDX116"></a>
<a name="IDX117"></a>

<p>An earlier version of Daikon included a Lisp front end, but it is no
longer supported.
</p>
<p>An earlier version of Daikon provided a source-based front end for Java
named dfej.  It has been superseded by Chicory (see section <a href="#SEC69">Java front end Chicory</a>).
</p>
<p>An earlier version of Daikon provided a source-based front end for C
named dfec.  It has been superseded by Kvasir  (binary-based, for
Linux/x86; see section <a href="#SEC80">C/C++ front end Kvasir</a>) and
Mangel-Wurzel (source-based, for all other platforms; see section <a href="#SEC94">Source-based C/C++ front end Mangel-Wurzel</a>).
</p>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC68" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="daikon_8.html#SEC111" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="daikon.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="daikon_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="daikon_11.html#SEC157" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="daikon_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Daikon User</em> on <em>June, 23 2010</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
