<html lang="en">
<head>
<title>The Daikon Invariant Detector User Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The Daikon Invariant Detector User Manual">
<meta name="generator" content="makeinfo 4.11">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">The Daikon Invariant Detector User Manual</h1>
<img src="images/daikon-logo.gif" alt="Daikon logo"><!-- Why is this here?  It duplicates the stuff further down. -->
<!-- @html -->
<!-- <h1>Daikon Invariant Detector User Manual</h1> -->
<!-- This is the user manual for the Daikon invariant detector. -->
<!-- It describes Daikon version 4.6.4, released June 23, 2010. -->
<!-- @end html -->

<!-- Putting this lower in the HTML version looks a little bit strange, -->
<!-- but it's acceptable. -->
<div class="node">
<p><hr>
<a name="Top"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>

</div>

<!-- node-name, next,          previous, up -->
<!-- Unfortunately, the Daikon logo doesn't look good in ASCII. -->
<!-- @ifinfo -->
<!-- @image{images/daikon-logo,4in,} -->
<!-- @end ifinfo -->
   <p>This is the user manual for the Daikon invariant detector. 
It describes Daikon version 4.6.4, released June 23, 2010.

<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>
<li><a accesskey="2" href="#Installing-Daikon">Installing Daikon</a>
<li><a accesskey="3" href="#Example-usage">Example usage</a>
<li><a accesskey="4" href="#Running-Daikon">Running Daikon</a>
<li><a accesskey="5" href="#Daikon-output">Daikon output</a>
<li><a accesskey="6" href="#Enhancing-Daikon-output">Enhancing Daikon output</a>
<li><a accesskey="7" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>
<li><a accesskey="8" href="#Tools">Tools</a>
<li><a accesskey="9" href="#Troubleshooting">Troubleshooting</a>
<li><a href="#Details">Details</a>
<li><a href="#Index">Index</a>

<div class="contents">
</ul>

</ul>

<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Introduction" href="#Introduction">1 Introduction</a>
<ul>
<li><a href="#Mailing-lists">1.1 Mailing lists</a>
</li></ul>
<li><a name="toc_Installing-Daikon" href="#Installing-Daikon">2 Installing Daikon</a>
<ul>
<li><a href="#Simple-installation">2.1 Simple installation instructions</a>
<li><a href="#Complete-installation">2.2 Complete installation instructions</a>
<ul>
<li><a href="#Requirements">2.2.1 Requirements for running Daikon</a>
<ul>
<li><a href="#Optional-requirements">2.2.1.1 Optional requirements for running Daikon</a>
</li></ul>
<li><a href="#Unix_002fLinux_002fMacOS-installation">2.2.2 Unix/Linux/MacOS installation</a>
<li><a href="#Windows-installation">2.2.3 Windows installation</a>
<li><a href="#Running-Daikon-under-Windows">2.2.4 Running Daikon under Windows</a>
<ul>
<li><a href="#Windows-command-line">2.2.4.1 Windows command line</a>
<li><a href="#Cygwin-shell">2.2.4.2 Cygwin shell</a>
</li></ul>
</li></ul>
</li></ul>
<li><a name="toc_Example-usage" href="#Example-usage">3 Example usage for Java, C/C++, Perl, and Eiffel</a>
<ul>
<li><a href="#Detecting-invariants-in-Java-programs">3.1 Detecting invariants in Java programs</a>
<ul>
<li><a href="#StackAr-example">3.1.1 StackAr example</a>
<li><a href="#Using-DynComp-with-Java-programs">3.1.2 Using DynComp with Java programs</a>
<li><a href="#Understanding-the-invariants">3.1.3 Understanding the invariants</a>
<li><a href="#Understanding-DynComp">3.1.4 Understanding DynComp</a>
<li><a href="#Second-Java-example">3.1.5 A second Java example</a>
</li></ul>
<li><a href="#Detecting-invariants-in-C_002fC_002b_002b-programs">3.2 Detecting invariants in C/C++ programs</a>
<ul>
<li><a href="#C-examples">3.2.1 C examples</a>
<li><a href="#Using-DynComp-with-C-programs">3.2.2 Using DynComp with C programs</a>
<li><a href="#Dealing-with-large-examples">3.2.3 Dealing with large examples</a>
</li></ul>
<li><a href="#Detecting-invariants-in-Perl-programs">3.3 Detecting invariants in Perl programs</a>
<ul>
<li><a href="#Instrumenting-Perl-programs">3.3.1 Instrumenting Perl programs</a>
<li><a href="#Perl-examples">3.3.2 Perl examples</a>
</li></ul>
<li><a href="#Detecting-invariants-in-Eiffel-programs">3.4 Detecting invariants in Eiffel programs</a>
</li></ul>
<li><a name="toc_Running-Daikon" href="#Running-Daikon">4 Running Daikon</a>
<ul>
<li><a href="#Options-to-control-Daikon-output">4.1 Options to control Daikon output</a>
<li><a href="#Options-to-control-invariant-detection">4.2 Options to control invariant detection</a>
<li><a href="#Processing-only-part-of-the-trace-file">4.3 Processing only part of the trace file</a>
<li><a href="#Daikon-configuration-options">4.4 Daikon configuration options</a>
<li><a href="#Daikon-debugging-options">4.5 Daikon debugging options</a>
</li></ul>
<li><a name="toc_Daikon-output" href="#Daikon-output">5 Daikon output</a>
<ul>
<li><a href="#Invariant-syntax">5.1 Invariant syntax</a>
<li><a href="#Program-points">5.2 Program points</a>
<li><a href="#Variable-names">5.3 Variable names</a>
<ul>
<li><a href="#orig-variable-example">5.3.1 orig variable example</a>
</li></ul>
<li><a href="#Interpreting-output">5.4 Interpreting Daikon output</a>
<ul>
<li><a href="#Redundant-invariants">5.4.1 Redundant</a>
<li><a href="#Equal-variables">5.4.2 Equal variables</a>
<li><a href="#Has-only-one-value-variables">5.4.3 Has only one value variables</a>
</li></ul>
<li><a href="#Invariant-list">5.5 Invariant list</a>
<li><a href="#Invariant-filters">5.6 Invariant filters</a>
</li></ul>
<li><a name="toc_Enhancing-Daikon-output" href="#Enhancing-Daikon-output">6 Enhancing Daikon output</a>
<ul>
<li><a href="#Configuration-options">6.1 Configuration options</a>
<ul>
<li><a href="#List-of-configuration-options">6.1.1 List of configuration options</a>
<ul>
<li><a href="#Options-to-enable_002fdisable-filters">6.1.1.1 Options to enable/disable filters</a>
<li><a href="#Options-to-enable_002fdisable-specific-invariants">6.1.1.2 Options to enable/disable specific invariants</a>
<li><a href="#Other-invariant-configuration-parameters">6.1.1.3 Other invariant configuration parameters</a>
<li><a href="#Options-to-enable_002fdisable-derived-variables">6.1.1.4 Options to enable/disable derived variables</a>
<li><a href="#Simplify-interface-configuration-options">6.1.1.5 Simplify interface configuration options</a>
<li><a href="#General-configuration-options">6.1.1.6 General configuration options</a>
</li></ul>
</li></ul>
<li><a href="#Conditional-invariants">6.2 Conditional invariants and implications</a>
<ul>
<li><a href="#Splitter-info-file">6.2.1 Splitter info file</a>
<ul>
<li><a href="#Program-point-sections">6.2.1.1 Program point sections</a>
<li><a href="#Replacement-sections">6.2.1.2 Replacement sections</a>
</li></ul>
<li><a href="#Indiscriminate-splitting">6.2.2 Indiscriminate splitting</a>
<li><a href="#Example-splitter-info-file">6.2.3 Example splitter info file</a>
<ul>
<li><a href="#Example-class">6.2.3.1 Example class</a>
<li><a href="#Resulting-_002espinfo-file">6.2.3.2 Resulting .spinfo file</a>
</li></ul>
</li></ul>
<li><a href="#Enhancing-conditional-invariant-detection">6.3 Enhancing conditional invariant detection</a>
<ul>
<li><a href="#Static-analysis-for-splitters">6.3.1 Static analysis for splitters</a>
<li><a href="#Cluster-analysis-for-splitters">6.3.2 Cluster analysis for splitters</a>
<li><a href="#Random-selection-for-splitters">6.3.3 Random selection for splitters</a>
</li></ul>
<li><a href="#Dynamic-abstract-type-inference-_0028DynComp_0029">6.4 Dynamic abstract type inference (DynComp)</a>
<li><a href="#Loop-invariants">6.5 Loop invariants</a>
</li></ul>
<li><a name="toc_Front-ends-_0028instrumentation_0029" href="#Front-ends-_0028instrumentation_0029">7 Front ends (instrumentation)</a>
<ul>
<li><a href="#Chicory">7.1 Java front end Chicory</a>
<ul>
<li><a href="#Chicory-options">7.1.1 Chicory options</a>
<ul>
<li><a href="#Program-points-in-Chicory-output">7.1.1.1 Program points in Chicory output</a>
<li><a href="#Variables-in-Chicory-output">7.1.1.2 Variables in Chicory output</a>
<li><a href="#Chicory-miscellaneous-options">7.1.1.3 Chicory miscellaneous options</a>
</li></ul>
<li><a href="#Static-fields-_0028global-variables_0029">7.1.2 Static fields (global variables)</a>
</li></ul>
<li><a href="#DynComp-for-Java">7.2 DynComp dynamic comparability (abstract type) analysis for Java</a>
<ul>
<li><a href="#Instrumenting-the-JDK-with-DynComp">7.2.1 Instrumenting the JDK with DynComp</a>
<li><a href="#DynComp-for-Java-options">7.2.2 DynComp options</a>
<li><a href="#Instrumentation-of-Object-methods">7.2.3 Instrumentation of Object methods</a>
<li><a href="#DynComp-for-Java-known-bugs">7.2.4 Known bugs and limitations</a>
</li></ul>
<li><a href="#Kvasir">7.3 C/C++ front end Kvasir</a>
<ul>
<li><a href="#Using-Kvasir">7.3.1 Using Kvasir</a>
<li><a href="#Kvasir-options">7.3.2 Kvasir options</a>
<li><a href="#DynComp-for-C_002fC_002b_002b">7.3.3 DynComp dynamic comparability (abstract type) analysis for C/C++</a>
<li><a href="#Tracing-only-part-of-a-program">7.3.4 Tracing only part of a program</a>
<li><a href="#Pointer-type-disambiguation">7.3.5 Pointer type disambiguation</a>
<ul>
<li><a href="#Pointer-type-coercion">7.3.5.1 Pointer type coercion</a>
<li><a href="#Pointer-type-disambiguation-example">7.3.5.2 Pointer type disambiguation example</a>
<li><a href="#Using-pointer-type-disambiguation-with-partial-program-tracing">7.3.5.3 Using pointer type disambiguation with partial program tracing</a>
</li></ul>
<li><a href="#C_002b_002b-support">7.3.6 C++ support</a>
<li><a href="#Online-execution">7.3.7 Online execution</a>
<ul>
<li><a href="#Online-execution-with-DynComp-for-C_002fC_002b_002b">7.3.7.1 Online execution with DynComp for C/C++</a>
</li></ul>
<li><a href="#Installing-Kvasir">7.3.8 Installing Kvasir</a>
<li><a href="#Kvasir-limitations">7.3.9 Kvasir implementation and limitations</a>
</li></ul>
<li><a href="#Mangel_002dWurzel">7.4 Source-based C/C++ front end Mangel-Wurzel</a>
<ul>
<li><a href="#Using-Mangel_002dWurzel">7.4.1 Using Mangel-Wurzel</a>
<li><a href="#Mangel-options">7.4.2 Mangel options</a>
<ul>
<li><a href="#Standard-compiler-options-for-Mangel">7.4.2.1 Standard compiler options for Mangel</a>
<li><a href="#Mangel-configuration-options">7.4.2.2 Mangel configuration options</a>
<li><a href="#Mangel-annotation-options">7.4.2.3 Mangel annotation options</a>
<li><a href="#Options-files-for-Mangel">7.4.2.4 Options files for Mangel</a>
</li></ul>
<li><a href="#Pointer_002farray-disambiguation-in-Mangel_002dWurzel">7.4.3 Pointer/array disambiguation in Mangel-Wurzel</a>
<li><a href="#Mangel_002dWurzel-usage-notes">7.4.4 Mangel-Wurzel usage notes</a>
<ul>
<li><a href="#Using-Mangel_002dWurzel-on-Unix">7.4.4.1 Using Mangel-Wurzel on Unix</a>
<li><a href="#Using-Mangel_002dWurzel-on-Windows">7.4.4.2 Using Mangel-Wurzel on Windows</a>
</li></ul>
<li><a href="#Interaction-with-Purify">7.4.5 Interaction with Purify</a>
<li><a href="#Installing-Mangel_002dWurzel">7.4.6 Installing Mangel-Wurzel</a>
</li></ul>
<li><a href="#dfepl">7.5 Perl front end dfepl</a>
<ul>
<li><a href="#dfepl-options">7.5.1 dfepl options</a>
</li></ul>
<li><a href="#convertcsv_002epl">7.6 Comma-separated-value front end convertcsv.pl</a>
<li><a href="#Other-front-ends">7.7 Other front ends</a>
</li></ul>
<li><a name="toc_Tools" href="#Tools">8 Tools for use with Daikon</a>
<ul>
<li><a href="#Tools-for-manipulating-invariants">8.1 Tools for manipulating invariants</a>
<ul>
<li><a href="#Printing-invariants">8.1.1 Printing invariants</a>
<li><a href="#MergeInvariants">8.1.2 MergeInvariants</a>
<li><a href="#Invariant-Diff">8.1.3 Invariant Diff</a>
<li><a href="#Annotate">8.1.4 Annotate</a>
<li><a href="#AnnotateNullable">8.1.5 AnnotateNullable</a>
<li><a href="#Runtime_002dcheck-instrumenter">8.1.6 Runtime-check instrumenter (runtimechecker)</a>
<ul>
<li><a href="#Accessing-violations">8.1.6.1 Accessing violations</a>
</li></ul>
<li><a href="#InvariantChecker">8.1.7 InvariantChecker</a>
<li><a href="#LogicalCompare">8.1.8 LogicalCompare</a>
</li></ul>
<li><a href="#DtraceDiff-utility">8.2 DtraceDiff utility</a>
</li></ul>
<li><a name="toc_Troubleshooting" href="#Troubleshooting">9 Troubleshooting</a>
<ul>
<li><a href="#Daikon-problems">9.1 Problems running Daikon</a>
<ul>
<li><a href="#Too-much-output">9.1.1 Too much output</a>
<li><a href="#Missing-output-invariants">9.1.2 Missing output invariants</a>
<li><a href="#No-samples">9.1.3 No samples and no output</a>
<li><a href="#No-return-from-procedure">9.1.4 No return from procedure</a>
<li><a href="#Unsupported-class-version">9.1.5 Unsupported class version</a>
<li><a href="#Out-of-memory">9.1.6 Out of memory</a>
<li><a href="#Simplify-errors">9.1.7 Simplify errors</a>
<li><a href="#Contradictory-invariants">9.1.8 Contradictory invariants</a>
<li><a href="#Method-needs-to-be-implemented">9.1.9 Method needs to be implemented</a>
<li><a href="#Daikon-runs-slowly">9.1.10 Daikon runs slowly</a>
<ul>
<li><a href="#Daikon-runs-slowly">9.1.10.1 Slow creation of large trace files</a>
<li><a href="#Daikon-runs-slowly">9.1.10.2 Slow inference of invariants</a>
</li></ul>
<li><a href="#Bigger-traces-cause-invariants-to-appear">9.1.11 Bigger traces cause invariants to appear</a>
</li></ul>
<li><a href="#Large-dtrace-files">9.2 Large data trace (.dtrace) files</a>
<ul>
<li><a href="#Run-Daikon-online">9.2.1 Run Daikon online</a>
<li><a href="#Multiple-smaller-files">9.2.2 Create multiple smaller data trace files</a>
<li><a href="#Less-information-per-file">9.2.3 Record or read less information in the data trace file</a>
<li><a href="#Reducing-program-points">9.2.4 Reducing program points (functions)</a>
<li><a href="#Reducing-variables">9.2.5 Reducing variables</a>
<li><a href="#Reducing-executions">9.2.6 Reducing executions</a>
</li></ul>
<li><a href="#Parsing-Java-5_002e0-code">9.3 Parsing Java 5.0 code</a>
<li><a href="#Chicory-problems">9.4 Problems with Chicory</a>
<ul>
<li><a href="#VerifyError-constant-pool-index-error">9.4.1 VerifyError constant pool index error</a>
</li></ul>
<li><a href="#Reporting-problems">9.5 Reporting problems</a>
<li><a href="#Known-bugs">9.6 Known bugs</a>
<li><a href="#Further-reading">9.7 Further reading</a>
</li></ul>
<li><a name="toc_Details" href="#Details">10 Details</a>
<ul>
<li><a href="#History">10.1 History</a>
<li><a href="#License">10.2 License</a>
<li><a href="#Mailing-lists-reminder">10.3 Mailing lists reminder</a>
<li><a href="#Credits">10.4 Credits</a>
<li><a href="#Citing-Daikon">10.5 Citing Daikon</a>
</li></ul>
<li><a name="toc_Index" href="#Index">Index</a>
</li></ul>
</div>

   </ul>

<div class="node">
<p><hr>
<a name="Introduction"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installing-Daikon">Installing Daikon</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Introduction</h2>

<!-- If you edit the introduction, then re-generate daikon.html and insert -->
<!-- its ``Introduction'' section into $inv/doc/www/index.html . -->
<p><a href="http://pag.csail.mit.edu/daikon/">Daikon</a> is an implementation of
dynamic detection of likely invariants; that is, the Daikon invariant
detector reports likely program invariants.  An invariant is a property
that holds at a certain point or points in a program; these are often
seen in assert statements, documentation, and formal specifications. 
Invariants can be useful in program understanding and a host of other
applications.  Examples include &ldquo;.field &gt; abs(y)&rdquo;; &ldquo;y = 2*x+3&rdquo;;
&ldquo;array a is sorted&rdquo;; &ldquo;for all list objects lst, lst.next.prev =
lst&rdquo;; &ldquo;for all treenode objects n, n.left.value &lt; n.right.value&rdquo;; &ldquo;p
!= null =&gt; p.content in myArray&rdquo;; and many more.  You can extend Daikon
to add new properties (see <a href="#Enhancing-Daikon-output">Enhancing Daikon output</a>;
see <a href="developer.html#New-invariants">New invariants</a>).

   <p>Dynamic invariant detection runs a program, observes the values that the
program computes, and then reports properties that were true over the
observed executions. 
<!-- Daikon's output, which is sometimes called an ``operational abstraction'', -->
<!-- looks like a formal specification, or the contents of assert statements. -->
Daikon can detect properties in C, C++, Eiffel, Java, and Perl programs;
in spreadsheet files; and in other data sources.  (Dynamic invariant
detection is a machine learning technique that can be applied to
arbitrary data.)  It is easy to extend Daikon to other applications; as
one example, an interface exists to the Java PathFinder model checker. 
<!-- Removed this because it was the biggest link on the page, which is -->
<!-- not the desired effect:  @uref{http://ase.arc.nasa.gov/visser/jpf/, , } -->

   <p>Daikon is freely available for download from
<a href="http://pag.csail.mit.edu/daikon/download/">http://pag.csail.mit.edu/daikon/download/</a>.  The distribution
includes both source code and
<a href="http://pag.csail.mit.edu/daikon/download/doc/">documentation</a>,
and Daikon's license permits unrestricted use (see <a href="#License">License</a>).  Many
researchers and practitioners have used Daikon; those uses, and Daikon
itself, are described in various
<a href="http://pag.csail.mit.edu/daikon/pubs/">publications</a>.

   <p>More information on Daikon can be found in the Daikon Developer
Manual (see <a href="developer.html#Top">Top</a>). 
For instance, the Daikon Developer Manual indicates how to
extend Daikon with new invariants, new derived variables, and front
ends for new languages.  It also contains information about the
implementation and about debugging flags.

<ul class="menu">
<li><a accesskey="1" href="#Mailing-lists">Mailing lists</a>
</ul>

<div class="node">
<p><hr>
<a name="Mailing-lists"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<h3 class="section">1.1 Mailing lists</h3>

<p><a name="index-mailing-lists-1"></a><a name="index-daikon_002dannounce-mailing-list-2"></a><a name="index-daikon_002ddiscuss-mailing-list-3"></a><a name="index-daikon_002ddevelopers-mailing-list-4"></a>
The following mailing lists (and their archives) are available:
     <dl>
<dt>&lsquo;<samp><span class="samp">daikon-announce@lists.csail.mit.edu</span></samp>&rsquo;<dd>A low-volume, announcement-only list.  For example,
announcements of new releases are sent to this list. 
To subscribe, visit
<a href="https://lists.csail.mit.edu/mailman/listinfo/daikon-announce">https://lists.csail.mit.edu/mailman/listinfo/daikon-announce</a>. 
<br><dt>&lsquo;<samp><span class="samp">daikon-discuss@lists.csail.mit.edu</span></samp>&rsquo;<dd>A moderated list for the community of Daikon users.  Use it to share
tips and successes, and to get help with questions or problems (after
checking the documentation).  To subscribe, visit
<a href="https://lists.csail.mit.edu/mailman/listinfo/daikon-discuss">https://lists.csail.mit.edu/mailman/listinfo/daikon-discuss</a>. 
<br><dt>&lsquo;<samp><span class="samp">daikon-developers@lists.csail.mit.edu</span></samp>&rsquo;<dd>This list goes to the Daikon maintainers.  Use it for bug reports,
suggestions, and the like.  If you are an active contributor to Daikon,
you may send mail to the list asking to be added. 
</dl>

<div class="node">
<p><hr>
<a name="Installing-Daikon"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Example-usage">Example usage</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Installing Daikon</h2>

<p><a name="index-installing-Daikon-5"></a>
Shortcut for the impatient:  skip directly to installation instructions
(see <a href="#Unix_002fLinux_002fMacOS-installation">Unix/Linux/MacOS installation</a>) (see <a href="#Windows-installation">Windows installation</a>).

   <p>There are two main ways to install Daikon.  See <a href="#Simple-installation">Simple installation</a>,
for a simple 2-step installation process that is adequate for the needs
of many users.  See <a href="#Complete-installation">Complete installation</a>, for a complete
installation, in 4 easy steps, that permits you to use all of the
functionality in the Daikon distribution.

   <p>Use the simple installation instructions if you only wish to detect
invariants in Java programs.  Use the complete installation instructions
(which are easy to follow) if you wish to detect invariants in C or Perl
programs, if you wish to run certain other programs distributed with
Daikon in its <samp><span class="file">bin/</span></samp> directory, or if you wish to edit and
recompile the source code of Daikon itself.

   <p>Differences from previous versions of Daikon appear
in the file <samp><span class="file">doc/CHANGES</span></samp> in the distribution. 
To be notified of new releases, or to join discussions about Daikon,
subscribe to one of the mailing lists (see <a href="#Mailing-lists">Mailing lists</a>).

<ul class="menu">
<li><a accesskey="1" href="#Simple-installation">Simple installation</a>
<li><a accesskey="2" href="#Complete-installation">Complete installation</a>
</ul>

<div class="node">
<p><hr>
<a name="Simple-installation"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Complete-installation">Complete installation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installing-Daikon">Installing Daikon</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installing-Daikon">Installing Daikon</a>

</div>

<h3 class="section">2.1 Simple installation instructions</h3>

<p>Daikon is written in Java.  In order to run Daikon, all you really need
is the <samp><span class="file">daikon.jar</span></samp> file, which is included in the distribution or
can be downloaded separately from
<a href="http://pag.csail.mit.edu/daikon/download/daikon.jar">http://pag.csail.mit.edu/daikon/download/daikon.jar</a>.  Place
<samp><span class="file">daikon.jar</span></samp> on your classpath so that Java can find it.  You are
now ready to use Daikon!

   <p>There are two additional requirements.  You must have a Java 5.0 (or later)
JVM (<a href="http://java.sun.com">Java Virtual Machine</a>).  The
<samp><span class="file">tools.jar</span></samp> file that comes with your JVM must also be on your
classpath.

   <p>See <a href="#Installing-Daikon">Installing Daikon</a>, for situations where you should
follow the complete installation instructions of <a href="#Complete-installation">Complete installation</a>.  (Also, if you do not know how to add a jar file to your
classpath, then use the complete installation instructions, which walk
you through the process.)

<div class="node">
<p><hr>
<a name="Complete-installation"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Simple-installation">Simple installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installing-Daikon">Installing Daikon</a>

</div>

<h3 class="section">2.2 Complete installation instructions</h3>

<p>This section gives step-by-step instructions for installing Daikon.

   <p>Here is an overview of the steps.  Details appear below; select the
instructions for your operating system.

     <ol type=1 start=1>
<li>Download Daikon.

     <li>Place three commands in your shell initialization file.

     <li>Optionally, customize your installation.

     <li>Optionally, compile Daikon and build other tools by running <code>make</code>.

        </ol>

   <p>For more complete information on compiling Daikon, see <a href="developer.html#Compiling-Daikon">Compiling Daikon</a> in the Daikon Developer Manual.

<ul class="menu">
<li><a accesskey="1" href="#Requirements">Requirements</a>
<li><a accesskey="2" href="#Unix_002fLinux_002fMacOS-installation">Unix/Linux/MacOS installation</a>
<li><a accesskey="3" href="#Windows-installation">Windows installation</a>
<li><a accesskey="4" href="#Running-Daikon-under-Windows">Running Daikon under Windows</a>
</ul>

<div class="node">
<p><hr>
<a name="Requirements"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Unix_002fLinux_002fMacOS-installation">Unix/Linux/MacOS installation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Complete-installation">Complete installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Complete-installation">Complete installation</a>

</div>

<h4 class="subsection">2.2.1 Requirements for running Daikon</h4>

<p>In order to run Daikon, you must have a Java 5.0 (or later) JVM
(<a href="http://java.sun.com">Java Virtual Machine</a>).  You must also
have a Java 5.0 (or later) compiler.

<ul class="menu">
<li><a accesskey="1" href="#Optional-requirements">Optional requirements</a>
</ul>

<div class="node">
<p><hr>
<a name="Optional-requirements"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Requirements">Requirements</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Requirements">Requirements</a>

</div>

<h5 class="subsubsection">2.2.1.1 Optional requirements for running Daikon</h5>

<p>All the remaining requirements listed here are optional (they enable you
to perform certain additional tasks with Daikon).

   <p>If you plan to use one of Daikon's source-based front ends, such as
Mangel-Wurzel (see <a href="#Mangel_002dWurzel">Mangel-Wurzel</a>), then you need a compiler
for whatever language your target programs are written in.  For
instance, if you wish to analyze C or C++ programs, you need a C or C++
compiler such as GCC.  Source code and a compiler are not necessary if
you plan to use one of Daikon's front ends that work on binaries, such
as Chicory (see <a href="#Chicory">Chicory</a>) and Kvasir (see <a href="#Kvasir">Kvasir</a>).

   <p>If you wish to edit the Daikon source code and re-compile Daikon, see
<a href="developer.html#Compiling-Daikon">Compiling Daikon</a> in the
Daikon developers manual.

<!-- The explicit examples, segregated by OS type, seem necessary for some users. -->
<div class="node">
<p><hr>
<a name="Unix%2fLinux%2fMacOS-installation"></a>
<a name="Unix_002fLinux_002fMacOS-installation"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Windows-installation">Windows installation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Requirements">Requirements</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Complete-installation">Complete installation</a>

</div>

<h4 class="subsection">2.2.2 Unix/Linux/MacOS installation</h4>

     <ol type=1 start=1>
<li>Choose the directory where you want to install Daikon; we'll call this
the <var>daikonparent</var> directory.  In this directory, download and
unpack Daikon.

     <pre class="example">          cd <var>daikonparent</var>
          wget http://pag.csail.mit.edu/daikon/download/daikon.tar.gz
          tar zxf daikon.tar.gz
</pre>
     <p class="noindent">This creates a <samp><var>daikonparent</var><span class="file">/daikon/</span></samp> subdirectory.

     <li>Place three commands in your shell initialization file:
set two environment variables
and source a Daikon startup file.

     <p><strong>sh/bash:</strong>  If you use the sh or bash shell or their variants,
add these three commands to your <samp><span class="file">~/.bashrc</span></samp> or <samp><span class="file">~/.bash_profile</span></samp> file:
     <pre class="example">          # The full pathname of the directory that contains Daikon
          export DAIKONDIR=$HOME/daikon
          # The full pathname of the directory that contains the Java JDK
          export JAVA_HOME=/usr/java/jdk1.6.0_20
          source $DAIKONDIR/bin/daikon.bashrc
</pre>
     <p><strong>csh/tcsh:</strong> If you use the csh or tcsh shell or their variants,
add these three commands to your <samp><span class="file">~/.cshrc</span></samp> file:
     <pre class="example">          # The full pathname of the directory that contains Daikon
          setenv DAIKONDIR $HOME/daikon
          # The full pathname of the directory that contains the Java JDK
          setenv JAVA_HOME /usr/java/jdk1.6.0_20
          source $DAIKONDIR/bin/daikon.cshrc
</pre>
     <p>After editing your shell initialization file, either execute the commands
you placed in it, or else log out and log back in to achieve the same
effect.

     <li>Optionally, customize other variables.  The customizable variables are
listed in the Daikon startup file: <samp><span class="file">daikon.bashrc</span></samp> or
<samp><span class="file">daikon.cshrc</span></samp>.

     <p>You may customize them by setting environment variables, or by adding a
<code>Makefile.user</code> file to directory <code>$DAIKONDIR/java</code> (it is
automatically read at the beginning of the main Makefile, and prevents
you from having to edit the main Makefile directly).

     <li>Compile Daikon and build other tools by running <code>make</code>. 
Note that this step is <em>not</em> required if you only want to use Daikon
with its Java front end (Chicory).  This step is required for using
Daikon with its C/C++ front end (Kvasir), and for other tools.

     <pre class="example">          cd $DAIKONDIR
          make
</pre>
     <p>This builds the various executables used by Daikon, such as the
C/C++ front end Kvasir (see <a href="#Installing-Kvasir">Installing Kvasir</a>) and the
JDK for use with DynComp (see <a href="#Instrumenting-the-JDK-with-DynComp">Instrumenting the JDK with DynComp</a>). 
For more
information about compiling Daikon, see <a href="developer.html#Compiling-Daikon">Compiling Daikon</a> in the Daikon Developer Manual.

     <p>Note that running this make command may take 20 minutes or more,
depending on your computer.

     <p>Optionally, download other executables, such as
the Simplify theorem
prover (<a href="http://www.hpl.hp.com/downloads/crl/jtk/">http://www.hpl.hp.com/downloads/crl/jtk/</a>).

     </ol>

<div class="node">
<p><hr>
<a name="Windows-installation"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Running-Daikon-under-Windows">Running Daikon under Windows</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Unix_002fLinux_002fMacOS-installation">Unix/Linux/MacOS installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Complete-installation">Complete installation</a>

</div>

<h4 class="subsection">2.2.3 Windows installation</h4>

<p>To perform a complete install on
Windows, it is necessary to install the Cygwin toolset. 
After you have installed Daikon, you can run it using either Cygwin or
the regular Windows shell (see <a href="#Running-Daikon-under-Windows">Running Daikon under Windows</a>).

   <p>The Cygwin toolset (available at
<a href="http://sources.redhat.com/cygwin/">http://sources.redhat.com/cygwin/</a>) contains everything you need
to compile and run Unix programs under Windows.  You can install Cygwin
by simply running the program found at
<a href="http://sources.redhat.com/cygwin/setup.exe">http://sources.redhat.com/cygwin/setup.exe</a>.  The default
installation of Cygwin is sufficient for installing Daikon.

     <ol type=1 start=1>
<li>Choose the directory where you want to install Daikon; we'll call this
the <var>daikonparent</var> directory.  In this directory, download and
unpack Daikon.

     <pre class="example">          cd <var>daikonparent</var>
          wget http://pag.csail.mit.edu/daikon/download/daikon.tar.gz
          tar zxf daikon.tar.gz
</pre>
     <p class="noindent">This creates a <samp><var>daikonparent</var><span class="file">/daikon/</span></samp> subdirectory.

     <li>Place three commands in your shell initialization file <samp><span class="file">~/.bashrc</span></samp>:
set two environment variables
and source a Daikon startup file. 
Do not use a Windows shell; use the Cygwin bash shell instead.

     <pre class="example">          # The full pathname of the directory that contains Daikon
          export DAIKONDIR=$HOME/daikon
          # The full Unix pathname of the directory that contains the Java JDK
          export JAVA_HOME=/cygdrive/c/Program Files/Java/jdk1.6.0_20
          source $DAIKONDIR/bin/daikon.bashrc
</pre>
     <p>Use the Cygwin/Unix path style (e.g., <code>/cygdrive/c/daikon</code>) rather than the
windows path style (<code>C:\daikon</code>). 
Some users have reported problems when using pathnames
with spaces.  You can avoid the problem by using the <code>ln</code> command to add a
symbolic link without spaces to <code>Program Files</code>.
     <pre class="example">              cd /cygdrive/c
              ln -s "Program Files" program_files
</pre>
     <p class="noindent">and then the JAVA_HOME line becomes:
     <pre class="example">          export JAVA_HOME=/cygdrive/c/program_files/Java/jdk1.6.0_20
</pre>
     <!-- You can also -->
     <!-- set the environment variables in the registry (right-click My Computer, -->
     <!-- and then click Properties; click the Advanced tab; click Environment -->
     <!-- variables), but that only reduces the number of steps you have to do for -->
     <!-- each shell from 3 (two variables plus running the @file{daikonenv.bat} -->
     <!-- file) to 1 (running the @file{daikonenv.bat} file). -->
     <p>After editing your shell initialization file, either execute the commands
you placed in it, or else log out and log back in to achieve the same
effect.

     <li>Optionally, customize other variables.  The customizable variables are
listed in the Daikon startup file: <samp><span class="file">daikon.bashrc</span></samp> or
<samp><span class="file">daikon.cshrc</span></samp>.

     <p>You may customize them by setting environment variables, or by adding a
<code>Makefile.user</code> file to directory <code>$DAIKONDIR/java</code> (it is
automatically read at the beginning of the main Makefile, and prevents
you from having to edit the main Makefile directly).

     <p>The one variable you must customize is
to define the <code>OSTYPE</code> variable to be <code>cygwin</code>.
     <pre class="example">            OSTYPE = cygwin
</pre>
     <li>Compile Daikon and build other tools by running <code>make</code>. 
Note that this step is <em>not</em> required if you only want to use Daikon
with its Java front end (Chicory).  This step is required for using
Daikon with its C/C++ front end (Kvasir), and for other tools.

     <pre class="example">          cd $DAIKONDIR
          make
</pre>
     <p>This builds the various executables used by Daikon, such as the
C/C++ front end Kvasir (see <a href="#Installing-Kvasir">Installing Kvasir</a>) and the
JDK for use with DynComp (see <a href="#Instrumenting-the-JDK-with-DynComp">Instrumenting the JDK with DynComp</a>). 
For more
information about compiling Daikon, see <a href="developer.html#Compiling-Daikon">Compiling Daikon</a> in the Daikon Developer Manual.

     <p>Note that running this make command may take 20 minutes or more,
depending on your computer. 
On Windows, running <code>make</code> requires
that <a href="http://www.cygwin.com/">Cygwin</a> be installed.

     <p>Optionally, download other executables, such as
the Simplify theorem
prover (<a href="http://www.hpl.hp.com/downloads/crl/jtk/">http://www.hpl.hp.com/downloads/crl/jtk/</a>),
or
the Z3 theorem
prover (<a href="http://research.microsoft.com/en-us/um/redmond/projects/z3/">http://research.microsoft.com/en-us/um/redmond/projects/z3/</a>; Z3
can replace Simplify but is only distributed for Windows). 
<!-- @c -->
<!-- and the source-based C front -->
<!-- end Mangel-Wurzel (@pxref{Installing Mangel-Wurzel}). -->

        </ol>

<div class="node">
<p><hr>
<a name="Running-Daikon-under-Windows"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Windows-installation">Windows installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Complete-installation">Complete installation</a>

</div>

<h4 class="subsection">2.2.4 Running Daikon under Windows</h4>

<p><a name="index-Windows-6"></a><a name="index-Microsoft-Windows-7"></a>
After you have installed Daikon under Windows (see <a href="#Windows-installation">Windows installation</a>), you can run it either using native Windows utilities, or
using the Cygwin environment &mdash; it's your choice.

   <p>Daikon is a <strong>command-line application</strong> (and so are its related
programs, such as Chicory).  You should invoke them from a command shell
&mdash; either a Windows command shell or a Cygwin command shell &mdash; rather
than by double-clicking their icons.  In any event, double-clicking
would not supply the proper arguments to the program.

<ul class="menu">
<li><a accesskey="1" href="#Windows-command-line">Windows command line</a>
<li><a accesskey="2" href="#Cygwin-shell">Cygwin shell</a>
</ul>

<div class="node">
<p><hr>
<a name="Windows-command-line"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Cygwin-shell">Cygwin shell</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-Daikon-under-Windows">Running Daikon under Windows</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Running-Daikon-under-Windows">Running Daikon under Windows</a>

</div>

<h5 class="subsubsection">2.2.4.1 Windows command line</h5>

<p>The first option is to run Daikon using native Windows utilities. 
The is done in the normal fashion.  The <code>CLASSPATH</code> must include
either <code>$DAIKONDIR/daikon.jar</code> or <code>$DAIKONDIR/java</code> (if you
have recompiled the Daikon source).  The <code>CLASSPATH</code> should be
specified in Windows format (Windows paths and semicolon separators).

<!-- JHP Jan 2 2009: I comment out the below.  I don't think the environment -->
<!-- is necessary to run Daikon, only to build it. -->
<!-- Before running Daikon, you must invoke the @file{daikonenv.bat} batch -->
<!-- file (once) in the Windows command shell to set up the environment -->
<!-- properly.  To automatically run something (such as a batch file) every -->
<!-- time the Windows command shell is started, set the value of this -->
<!-- registry key to the program you want to run: -->
<!-- @example -->
<!-- HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\AutoRun -->
<!-- @end example -->
<!-- @noindent -->
<!-- @c This feels quite irrelevant; omit? -->
<!-- You may also wish to set two registry entries to enable automatic completion: -->
<!-- @example -->
<!-- HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\CompletionChar -->
<!-- HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor\PathCompletionChar -->
<!-- @end example -->
<!-- @noindent -->
<!-- The values for these registry entries are ASCII key codes.  Tab is 9. -->
<div class="node">
<p><hr>
<a name="Cygwin-shell"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Windows-command-line">Windows command line</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Running-Daikon-under-Windows">Running Daikon under Windows</a>

</div>

<h5 class="subsubsection">2.2.4.2 Cygwin shell</h5>

<p><a name="index-Cygwin-toolset-8"></a>
The second option for Windows is to run Daikon using the Cygwin
toolset (available at <a href="http://sources.redhat.com/cygwin/">http://sources.redhat.com/cygwin/</a>), which
contains everything you need to compile and run Unix programs under
Windows.  You can install Cygwin by simply running the program found
at <a href="http://sources.redhat.com/cygwin/setup.exe">http://sources.redhat.com/cygwin/setup.exe</a>.

   <p>There is an incompatibility between Cygwin and programs compiled for
Windows (such as Java).  (The incompatibility does not exist if the
program was compiled for Cygwin.)  The incompatibility is that Windows
programs use the semicolon (&lsquo;<samp><span class="samp">;</span></samp>&rsquo;) as their path separator (for
instance, for <samp><span class="env">CLASSPATH</span></samp>), but Unix and Cygwin programs use the
colon (&lsquo;<samp><span class="samp">:</span></samp>&rsquo;) as their path separator.

   <p>The <code>Makefiles</code> used to build Daikon will change the Unix style
<code>CLASSPATH</code> (e.g., .;/cygdrive/c/daikon/java) into a Windows
style <code>CLASSPATH</code> (.;C:\daikon\java) when necessary.  The
<code>CLASSPATH</code> must be in Unix format for the build to work
correctly.

   <p>However, when running any Java program (such as Daikon or Chicory),
the <code>CLASSPATH</code> should be specified in Windows format.  That is
why the build instructions suggest specifying the <code>CLASSPATH</code> in
the <code>$DAIKONDIR/java/Makefile.user</code> file &mdash; so that the required
Unix definition is not part of the environment.

<!-- JHP Jan 2 2008: I removed this as I don't think this a problem for -->
<!-- a user that isn't trying to write scripts on two platforms.  They -->
<!-- can just specify the classpath as Java expects it. -->
<!-- The @file{cygwin-runner.pl} script in the @file{bin/} directory may -->
<!-- help you run windows-native Java tools from within the Cygwin -->
<!-- environment.  It translates Unix @samp{:}-separated pathlists to -->
<!-- Windows @samp{;}-separated pathlists, changes filenames to their 8.3 -->
<!-- ``old style'' name (e.g., @file{My Documents} to @file{MYDOCU~1}), -->
<!-- changes forward slashes to backslashes, and translates paths with -->
<!-- Cygwin mount points to simple @file{C:\}-like paths. -->
<!-- For now, @file{cygwin-runner.pl} doesn't touch environment variables, -->
<!-- but you can still use it for classpath by getting your classpath onto -->
<!-- the command line explicitly: -->
<!-- @example -->
<!-- dfej -classpath $CLASSPATH DataStructures/StackAr.java -->
<!-- @end example -->
<!-- (It would be nice to patch cygwin-runner to translate environment -->
<!-- variables, too.  For example, always translate @env{CLASSPATH}, or -->
<!-- always translate anything listed in @env{CYGWIN_RUNNER_ENV} (e.g., -->
<!-- @samp{CYGWIN_RUNNER_ENV="PATH:CLASSPATH:PWD"}) so users can set -->
<!-- @env{CYGWIN_RUNNER_ENV} in their dotfiles or various wrappers.) -->
<div class="node">
<p><hr>
<a name="Example-usage"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Running-Daikon">Running Daikon</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installing-Daikon">Installing Daikon</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Example usage for Java, C/C++, Perl, and Eiffel</h2>

<p>Detecting invariants involves two steps:
     <ol type=1 start=1>
<li>Obtain one or more data trace files by running your program under the control of a
front end (also known as an instrumenter or tracer) that records information about
variable values.  You can run your program over one or more inputs of your own
choosing, such as regression tests or a typical user input session. 
You may choose to obtain trace data for only part of
your program; this can avoid inundating you with
output, and can also improve performance.

     <li>Run the Daikon invariant detector over the data trace files
(see <a href="#Running-Daikon">Running Daikon</a>).  This detects invariants in the recorded
information.  You can view the invariants textually, or process them
with a variety of tools.
        </ol>
Often, you can run a single command that performs both steps.  Among
other benefits, this can avoid the need to create the data trace file by
sending trace information directly from the instrumented program to
Daikon, which is called &ldquo;online execution&rdquo; of Daikon.

   <p>This section briefly describes how to obtain data traces for Java, C,
Perl, and Eiffel programs, and how to run Daikon.  For detailed
information about these and other front ends that are available for
Daikon, <a href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>.

<ul class="menu">
<li><a accesskey="1" href="#Detecting-invariants-in-Java-programs">Detecting invariants in Java programs</a>
<li><a accesskey="2" href="#Detecting-invariants-in-C_002fC_002b_002b-programs">Detecting invariants in C/C++ programs</a>
<li><a accesskey="3" href="#Detecting-invariants-in-Perl-programs">Detecting invariants in Perl programs</a>
<li><a accesskey="4" href="#Detecting-invariants-in-Eiffel-programs">Detecting invariants in Eiffel programs</a>
</ul>

<div class="node">
<p><hr>
<a name="Detecting-invariants-in-Java-programs"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Detecting-invariants-in-C_002fC_002b_002b-programs">Detecting invariants in C/C++ programs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Example-usage">Example usage</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Example-usage">Example usage</a>

</div>

<h3 class="section">3.1 Detecting invariants in Java programs</h3>

<p>In order to detect invariants in a Java program, run the
program using the Chicory front end (see <a href="#Chicory">Chicory</a>) to create a data trace file, then
run Daikon itself to detect invariants. 
With the <samp><span class="option">--daikon</span></samp> option to Chicory, a single command performs
both steps.

   <p>For example, if you usually run
<pre class="example">     java mypackage.MyClass arg1 arg2 arg3
</pre>
   <p class="noindent">then instead you would run
<pre class="example">     java daikon.Chicory --daikon mypackage.MyClass arg1 arg2 arg3
</pre>
   <p class="noindent">and the Daikon output is written to the terminal.

<ul class="menu">
<li><a accesskey="1" href="#StackAr-example">StackAr example</a>
<li><a accesskey="2" href="#Using-DynComp-with-Java-programs">Using DynComp with Java programs</a>
<li><a accesskey="3" href="#Understanding-the-invariants">Understanding the invariants</a>
<li><a accesskey="4" href="#Understanding-DynComp">Understanding DynComp</a>
<li><a accesskey="5" href="#Second-Java-example">Second Java example</a>
</ul>

<!-- Commented out as of summer 2005, because David Cok doesn't seem likely -->
<!-- to pick this up again, and we don't want to lead users astray or -->
<!-- discourage them with non-functional software. -->
<!-- @node    Eclipse plug-in, StackAr example, Detecting invariants in Java programs, Detecting invariants in Java programs -->
<!-- @subsection Eclipse plug-in -->
<!-- @cindex Eclipse plug-in -->
<!-- @cindex GUI, Eclipse -->
<!-- Daikon is integrated with the -->
<!-- @uref{http://eclipse.org/, , -->
<!-- Eclipse} IDE (Integrated Development Environment) for Java. -->
<!-- The Daikon plug-in provides a convenient way to instrument files, -->
<!-- obtain trace information, analyze those traces, -->
<!-- and create appropriately annotated Java source code. -->
<!-- For -->
<!-- details, see the @uref{daikonHelp.html, , Daikon Eclipse plug-in -->
<!-- documentation}. -->
<!-- As of this writing (February 11, 2005), the plug-in only works with -->
<!-- Daikon 3 (for instance, version 3.1.7), not with Daikon 4.  Support for -->
<!-- Daikon 4 is underway. -->
<!-- For brief troubleshooting information, see @ref{Eclipse plug-in problems}. -->
<div class="node">
<p><hr>
<a name="StackAr-example"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-DynComp-with-Java-programs">Using DynComp with Java programs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Detecting-invariants-in-Java-programs">Detecting invariants in Java programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Detecting-invariants-in-Java-programs">Detecting invariants in Java programs</a>

</div>

<h4 class="subsection">3.1.1 StackAr example</h4>

<p>The Daikon distribution contains some sample programs that will help
you get practice in running Daikon.

   <p>To detect invariants in the StackAr sample program, perform the following steps.

     <ol type=1 start=1>
<li>Compile the program with the <samp><span class="option">-g</span></samp> switch to enable debugging
symbols.  (The program and test suite appear in the
<samp><span class="file">DataStructures</span></samp> subdirectory directory.)
     <pre class="example">          cd examples/java-examples/StackAr
          javac -g DataStructures/*.java
</pre>
     <li>Run the program under the control of the Chicory front end,
pass the information to Daikon, print the inferred invariants, and write
a binary representation of the invariants to <samp><span class="file">StackArTester.inv.gz</span></samp>.

     <pre class="example">          java daikon.Chicory --daikon DataStructures.StackArTester
</pre>
     <p>Alternately, replacing the <samp><span class="option">--daikon</span></samp> argument by
<samp><span class="option">--daikon-online</span></samp> has the same effect, but does not write a data
trace file to disk.

        </ol>

   <p>If you wish to have more control over the invariant detection process,
you can split the second step above into multiple steps.  Then, the
whole process would be as follows:

     <ol type=1 start=1>
<li>Compile the program with the <samp><span class="option">-g</span></samp> switch to enable debugging
symbols.  (The program and test suite appear in the
<samp><span class="file">DataStructures</span></samp> subdirectory directory.)
     <pre class="example">          cd examples/java-examples/StackAr
          javac -g DataStructures/*.java
</pre>
     <li>Run the program under the control of the Chicory front end, in
order to create a trace file named <samp><span class="file">StackArTester.dtrace.gz</span></samp>.

     <pre class="example">          java daikon.Chicory DataStructures.StackArTester
</pre>
     <li>Run Daikon on the trace file.

     <pre class="example">          java daikon.Daikon StackArTester.dtrace.gz
</pre>
     <p>Daikon can analyze multiple runs (executions) of the program.  You can
supply Daikon with multiple trace files:

     <pre class="smallexample">          java daikon.Chicory --dtrace-file=StackArTester1.dtrace.gz DataStructures.StackArTester
          java daikon.Chicory --dtrace-file=StackArTester2.dtrace.gz DataStructures.StackArTester
          java daikon.Chicory --dtrace-file=StackArTester3.dtrace.gz DataStructures.StackArTester
          java daikon.Daikon StackArTester*.dtrace.gz
</pre>
     <!-- @noindent -->
     <!-- or, you can append information from multiple runs in a single trace file -->
     <!-- (but in this case you cannot use a compressed trace file): -->
     <!-- @example -->
     <!-- java -DDTRACEAPPEND=1 daikon.Chicory -dtrace-file=StackArTester.dtrace DataStructures.StackArTester -->
     <!-- java -DDTRACEAPPEND=1 daikon.Chicory -dtrace-file=StackArTester.dtrace DataStructures.StackArTester -->
     <!-- java -DDTRACEAPPEND=1 daikon.Chicory -dtrace-file=StackArTester.dtrace DataStructures.StackArTester -->
     <!-- java daikon.Daikon StackArTester.dtrace -->
     <!-- @end example -->
     <p>(In this example, all the runs are identical, so multiple runs yield the
same invariants as one run.)

     <li>Examine the invariants.  (They were also printed to standard out
by the previous step.)

     <p>There are various ways to do this.
          <ul>
<li>Examine the output from running Daikon.  (You may find it
convenient to capture the output in a file; add &lsquo;<samp><span class="samp">&gt; StackAr.txt</span></samp>&rsquo;
to the end of the command that runs Daikon.)

          <li>Use the PrintInvariants program to display the invariants.

          <pre class="example">               java daikon.PrintInvariants StackArTester.inv.gz
</pre>
          <p>For more options to the PrintInvariants program, see <a href="#Printing-invariants">Printing invariants</a>.

          <li>Use the Annotate program to insert the invariants as comments
into the Java source program.

          <pre class="example">               cd ..
               java daikon.tools.jtb.Annotate StackArTester.inv.gz \
                    DataStructures/StackAr.java
</pre>
          <p>Now examine file <samp><span class="file">DataStructures/StackAr.java-escannotated</span></samp>. 
For more information about the Annotate program, see <a href="#Annotate">Annotate</a>.

     </ul>
     </ol>

<div class="node">
<p><hr>
<a name="Using-DynComp-with-Java-programs"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Understanding-the-invariants">Understanding the invariants</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#StackAr-example">StackAr example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Detecting-invariants-in-Java-programs">Detecting invariants in Java programs</a>

</div>

<h4 class="subsection">3.1.2 Using DynComp with Java programs</h4>

<p>DynComp can help to filter Daikon's output by omitting invariants
involving unrelated variables (see <a href="#DynComp-for-Java">DynComp for Java</a>).  To do so, run
DynComp on the target program first, then pass the resulting
<samp><span class="file">.decls</span></samp> file to Chicory.  The process would be as follows:

     <ol type=1 start=1>
<li>Compile the program with the <samp><span class="option">-g</span></samp> switch to enable debugging
symbols.  (The program and test suite appear in the
<samp><span class="file">DataStructures</span></samp> subdirectory of the <samp><span class="file">StackAr</span></samp> directory.)
     <pre class="example">          cd examples/java-examples/StackAr
          javac -g DataStructures/*.java
</pre>
     <li>Run the program with DynComp to generate comparability information.  You
should produce an instrumented version of the JDK first (see
<a href="#Instrumenting-the-JDK-with-DynComp">Instrumenting the JDK with DynComp</a>).  By default, comparability
information is written to <samp><span class="file">StackArTester.decls-DynComp</span></samp>.

     <pre class="example">          java daikon.DynComp DataStructures.StackArTester
</pre>
     <li>Run the program under the control of the Chicory front end, including
comparability information.  Pass the information to Daikon, print the
inferred invariants, and write a binary representation of the invariants
to <samp><span class="file">StackArTester.inv.gz</span></samp>.  Note that this runs the target program
for a second time.

     <pre class="example">          java daikon.Chicory --daikon \
               --comparability-file=StackArTester.decls-DynComp \
               DataStructures.StackArTester
</pre>
        </ol>

   <p>You could split the third step into multiple steps, as described in
<a href="#StackAr-example">StackAr example</a>, to gain more control over the invariant detection
process.

<div class="node">
<p><hr>
<a name="Understanding-the-invariants"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Understanding-DynComp">Understanding DynComp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-DynComp-with-Java-programs">Using DynComp with Java programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Detecting-invariants-in-Java-programs">Detecting invariants in Java programs</a>

</div>

<h4 class="subsection">3.1.3 Understanding the invariants</h4>

<p>This section examines some of the invariants for the StackAr example. 
For more help interpreting invariants, see <a href="#Interpreting-output">Interpreting output</a>.

   <p>The StackAr example is an array-based stack implementation.  Take a
look at <samp><span class="file">DataStructures/StackAr.java</span></samp> to get a sense of the
implementation.  Now, look at the first section of Daikon output.

<pre class="example">     ======================================================================
     StackAr:::OBJECT
     this.theArray != null
     this.theArray.getClass() == java.lang.Object[].class
     this.topOfStack &gt;= -1
     this.theArray[this.topOfStack+1..] elements == null
     this.theArray[0..this.topOfStack] elements != null
     this.topOfStack &lt;= size(this.theArray[])-1
     ======================================================================
</pre>
   <p>These six annotations describe the representation invariant.  The
array is never null, and its runtime type is <code>Object[]</code>.  The
<code>topOfStack</code> index is at least -1 and is less than the length
of the array.  Finally, the elements of the array are non-null if
their index is no more than <code>topOfStack</code> and are null
otherwise.

   <p>Next, look at the invariants for the <code>top()</code> method. 
<code>top()</code> has two different exit points, at lines 78 and 79
in the original source.  There is a set of invariants for each exit
point, as well as a set of invariants that hold for all exit points. 
Look at the invariants when <code>top()</code> returns at line 79.

<pre class="example">     ======================================================================
     StackAr.top():::EXIT79
     return == this.theArray[this.topOfStack]
     this.theArray == orig(this.theArray)
     this.theArray[] == orig(this.theArray[])
     this.topOfStack == orig(this.topOfStack)
     return != null
     this.topOfStack &gt;= 0
     this.theArray[this.topOfStack+1..] elements == this.theArray[-1]
     ======================================================================
</pre>
   <p>The return value is never null, and is equal to the array element at
index <code>topOfStack</code>.  The top of the stack is at least 0.  The
array, the elements of the array, and <code>topOfStack</code> are not
modified by this method &mdash; this method is an &ldquo;observer&rdquo;.  The
last invariant is not particularly interesting.

<div class="node">
<p><hr>
<a name="Understanding-DynComp"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Second-Java-example">Second Java example</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Understanding-the-invariants">Understanding the invariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Detecting-invariants-in-Java-programs">Detecting invariants in Java programs</a>

</div>

<h4 class="subsection">3.1.4 Understanding DynComp</h4>

<p>To get a sense of how DynComp helps eliminate uninteresting output, take
a look at the invariants for the exit point at line 32 of the
<code>createItem(int)</code> method.

<pre class="example">     ======================================================================
     DataStructures.StackArTester.createItem(int):::EXIT32
     this.phase == 4
     return.getClass() == int[].class
     this.s.topOfStack &lt; orig(i)
     this.phase &lt; orig(i)
     this.phase != size(this.s.theArray[])
     this.maxPhase &lt; orig(i)
     ======================================================================
</pre>
   <p>The value of <code>phase</code> is always less than the value of
<code>i</code>.  While this is true for the observed executions, it is not a
helpful invariant, since <code>phase</code> and <code>i</code> represent different
abstract types; <code>i</code> is a number to be pushed onto the stack, while
<code>phase</code> is used for program flow control.  Although they are both
<code>int</code>s, comparing the two is not meaningful, so this invariant,
among others, is omitted from the output when Daikon is run with
DynComp.

<pre class="example">     ======================================================================
     DataStructures.StackArTester.createItem(int):::EXIT32
     this.phase == 4
     return.getClass() == int[].class
     this.s.topOfStack &lt; orig(i)
     ======================================================================
</pre>
   <div class="node">
<p><hr>
<a name="Second-Java-example"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Understanding-DynComp">Understanding DynComp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Detecting-invariants-in-Java-programs">Detecting invariants in Java programs</a>

</div>

<h4 class="subsection">3.1.5 A second Java example</h4>

<p>A second example is located in the <samp><span class="file">examples/java-examples/QueueAr</span></samp> subdirectory. 
Run this sample using the following steps:

     <ul>
<li>Compile
     <pre class="example">          cd examples/java-examples/QueueAr
          javac -g DataStructures/*.java
</pre>
     <li>Trace file generation and invariant detection
     <pre class="example">          java daikon.Chicory --daikon DataStructures.QueueArTester
</pre>
     </ul>

   <p>Alternately, you can split the second command into two parts:

     <ul>
<li>Trace file generation
     <pre class="example">          java daikon.Chicory DataStructures.QueueArTester
</pre>
     <li>Invariant detection
     <pre class="example">          java daikon.Daikon QueueArTester.dtrace.gz
</pre>
     </ul>

<div class="node">
<p><hr>
<a name="Detecting-invariants-in-C%2fC++-programs"></a>
<a name="Detecting-invariants-in-C_002fC_002b_002b-programs"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Detecting-invariants-in-Perl-programs">Detecting invariants in Perl programs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Detecting-invariants-in-Java-programs">Detecting invariants in Java programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Example-usage">Example usage</a>

</div>

<h3 class="section">3.2 Detecting invariants in C/C++ programs</h3>

<p>In order to detect invariants over C or C++ programs, you must first install
a C/C++ front end (instrumenter).  You can choose Kvasir (see <a href="#Kvasir">Kvasir</a>) or
Mangel-Wurzel (see <a href="#Mangel_002dWurzel">Mangel-Wurzel</a>).  We recommend the use of Kvasir, and
this section gives examples
using Kvasir.

   <p>To use the C/C++ front end Kvasir with your program, first make sure that
your program has been compiled with DWARF-2 format debugging
information, such as by giving the <samp><span class="option">-gdwarf-2</span></samp> flag to GCC when
compiling.  Then, run your program as usual, but prepend
<samp><span class="command">kvasir-dtrace</span></samp> to the command line.

   <p>For more information about Kvasir, including more detailed
documentation on its command-line options, see <a href="#Kvasir">Kvasir</a>.

<ul class="menu">
<li><a accesskey="1" href="#C-examples">C examples</a>
<li><a accesskey="2" href="#Using-DynComp-with-C-programs">Using DynComp with C programs</a>
<li><a accesskey="3" href="#Dealing-with-large-examples">Dealing with large examples</a>
</ul>

<div class="node">
<p><hr>
<a name="C-examples"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-DynComp-with-C-programs">Using DynComp with C programs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Detecting-invariants-in-C_002fC_002b_002b-programs">Detecting invariants in C/C++ programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Detecting-invariants-in-C_002fC_002b_002b-programs">Detecting invariants in C/C++ programs</a>

</div>

<h4 class="subsection">3.2.1 C examples</h4>

<p>The Daikon distribution comes with several example C programs in the
<samp><span class="file">examples/c-examples</span></samp> directory to enable users to become
familiar with running Daikon on C programs.

<!-- There are two sets of examples, corresponding to the two supplied C -->
<!-- front ends.  Examples intended for use with the binary-based front end -->
<!-- Kvasir are in a subdirectory @file{c-examples}; examples for the -->
<!-- older source-based front end dfec are in a subdirectory -->
<!-- @file{dfec-examples}.  It should be possible to instrument the dfec -->
<!-- examples with Kvasir, though we will not give directions here. -->
<!-- Instrumenting the Kvasir examples with dfec is not recommended (and is -->
<!-- not likely to work). -->
   <p>To detect invariants for a program with Kvasir, you need to perform
two basic tasks:  run the program under Kvasir to create a data trace
file (steps 1&ndash;2), and run
Daikon over the data trace file to produce invariants (steps 3&ndash;4). 
The following instructions are for the wordplay example, which is a
program for finding anagrams.

     <ol type=1 start=1>
<li>Change to the directory containing the program.
     <pre class="example">          cd $DAIKONDIR/examples/c-examples/wordplay
</pre>
     <li>Compile the program with DWARF-2 debugging information enabled
(and all optimizations disabled).
     <pre class="example">          gcc -gdwarf-2 wordplay.c -o wordplay
</pre>
     <p>Kvasir can also be used for programs constructed by compiling a number
of <samp><span class="file">.c</span></samp> files separately, and then linking them together; in such
a program, specify <samp><span class="option">-gdwarf-2</span></samp> when compiling each source file
containing code you wish to see invariants about.

     <li>Run the program just as you normally would, but prepend
<samp><span class="command">kvasir-dtrace</span></samp> to the command line.
     <pre class="example">          kvasir-dtrace ./wordplay -f words.txt 'daikon dynamic invariant detector'
</pre>
     <p>Any options to the program can be specified as usual; here, for
instance, we give commands to look for anagrams of the phrase &ldquo;Daikon
Dynamic Invariant Detector&rdquo; using words from the file <samp><span class="file">words.txt</span></samp>.

     <p>Executing under Kvasir, the program runs normally, but Kvasir
executes additional checks and collects trace information (for this
reason, the program will run more slowly than usual).  Kvasir creates a
directory named <samp><span class="file">daikon-output</span></samp> under the current directory, and
creates the <samp><span class="file">wordplay.dtrace</span></samp> file, which lists both variable
declarations and values.

     <p>Kvasir will also print messages if it observes your program doing
something with undefined effects; these may indicate bugs in your
program, or they may be spurious.  (If they are bugs, they can also be
tracked down by using Valgrind (<a href="http://www.valgrind.org/">http://www.valgrind.org/</a>)
with its regular memory checking
tool; if they do not appear with that tool, they are probably
spurious).

     <li>Run Daikon on the trace file.
     <pre class="smallexample">          java daikon.Daikon \
               --config_option daikon.derive.Derivation.disable_derived_variables=true \
               daikon-output/wordplay.dtrace
</pre>
     <p>The invariants are printed to standard output, and a binary representation
of the invariants is written to <samp><span class="file">wordplay.inv.gz</span></samp>.  Note that the
example uses a configuration option to disable the use of derived
variables; it can also run without that option, but takes significantly
longer.

     <p>Daikon can analyze multiple runs (executions) of the program.  You can
supply Daikon with multiple trace files:

     <pre class="smallexample">          kvasir-dtrace --dtrace-file=daikon-output/wordplay1.dtrace \
              ./wordplay -f words.txt 'daikon dynamic invariant detector'
          kvasir-dtrace --dtrace-file=daikon-output/wordplay2.dtrace \
              ./wordplay -f words.txt 'better results from multiple runs'
          kvasir-dtrace --dtrace-file=daikon-output/wordplay3.dtrace \
              ./wordplay -f words.txt 'more testing equals better testing'
          java -Xmx256m daikon.Daikon daikon-output/wordplay*.dtrace
</pre>
     <p class="noindent">or, you can append information from multiple runs in a single trace file:

     <pre class="smallexample">          kvasir-dtrace --dtrace-file=daikon-output/wordplay-all.dtrace \
              ./wordplay -f words.txt 'daikon dynamic invariant detector'
          kvasir-dtrace --dtrace-append --dtrace-file=daikon-output/wordplay-all.dtrace \
              ./wordplay -f words.txt 'better results from multiple runs'
          kvasir-dtrace --dtrace-append --dtrace-file=daikon-output/wordplay-all.dtrace \
              ./wordplay -f words.txt 'more testing equals better testing'
          java -Xmx256m daikon.Daikon daikon-output/wordplay-all.dtrace
</pre>
     <li>Examine the invariants.  As described in <a href="#StackAr-example">StackAr example</a>,
there are several ways to do this:
          <ul>
<li>Examine the output from running Daikon. 
<li>Use the PrintInvariants program to display the invariants. 
</ul>
     For help understanding the invariants, see <a href="#Interpreting-output">Interpreting output</a>.

        </ol>

<div class="node">
<p><hr>
<a name="Using-DynComp-with-C-programs"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Dealing-with-large-examples">Dealing with large examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#C-examples">C examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Detecting-invariants-in-C_002fC_002b_002b-programs">Detecting invariants in C/C++ programs</a>

</div>

<h4 class="subsection">3.2.2 Using DynComp with C programs</h4>

<p>Optionally, the DynComp tool can be used along with Kvasir and Daikon. 
DynComp uses a dynamic analysis to infer which program variables can
meaningfully be used together; Daikon can then use this information to
restrict the invariants it considers, potentially improving both its
performance and the usefulness of its results.

   <p>DynComp is enabled as an extra mode of Kvasir; when running with DynComp
enabled, Kvasir produces two output files instead of one: in addition to
a <samp><span class="file">.dtrace</span></samp> file containing a trace of a particular execution, the
information about what variables and functions exist in a program, along
with information grouping the variables into abstract types, is stored
in a file with the extension <samp><span class="file">.decls</span></samp>.  Both of these files must be
supplied to Daikon.

   <p>For instance, to repeat the wordplay example with DynComp, first rerun
<samp><span class="command">kvasir-dtrace</span></samp> giving it the option <samp><span class="option">--with-dyncomp</span></samp>:

<pre class="example">     kvasir-dtrace --with-dyncomp \
        ./wordplay -f words.txt 'daikon dynamic invariant detector'
</pre>
   <p>Then, supply the <samp><span class="file">.decls</span></samp> file when invoking Daikon:

<pre class="smallexample">     java daikon.Daikon \
          --config_option daikon.derive.Derivation.disable_derived_variables=true \
          daikon-output/wordplay.decls daikon-output/wordplay.dtrace
</pre>
   <p>For instance, one effect of DynComp that can be seen in the wordplay
example concerns the global variables <code>largestlet</code>,
<code>rec_anag_count</code>, <code>adjacentdups</code>, <code>specfirstword</code>,
<code>maxdepthspec</code>, and <code>silent</code>. 
These variables are all 0 in the sample execution (for instance, several
of them correspond to command-line options that are not enabled), so
without DynComp, Daikon gives the invariants that they are all equal. 
However, DynComp's analysis finds that the variables are of different
abstract types, so it is not meaningful to compare them. 
When DynComp information is provided, Daikon instead gives separate
invariants about the value of each variable.

<div class="node">
<p><hr>
<a name="Dealing-with-large-examples"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-DynComp-with-C-programs">Using DynComp with C programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Detecting-invariants-in-C_002fC_002b_002b-programs">Detecting invariants in C/C++ programs</a>

</div>

<h4 class="subsection">3.2.3 Dealing with large examples</h4>

<p>Since the default memory size used by Java virtual machines varies, we
suggest that Daikon be run with at least 256 megabytes of
memory (and perhaps much more), specified for many JVMs by the option <samp><span class="option">-Xmx256m</span></samp>. 
For more
information about specifying the memory usage for Daikon, see
<a href="#Out-of-memory">Out of memory</a>.

   <p>Disk usage can be reduced by specifying that the front end should
compress its output dtrace files. 
<!-- ; see @ref{dfec runtime customization}. -->

   <p>In some cases, the time and space requirements of the examples can be
reduced by reducing the length of the program run. 
However, Daikon's running time
depends on both the length of the test run and the size of the program
data (such as its use of global variables and nested data
structures). 
The examples also demonstrate disabling derived variables, which
significantly improves Daikon's performance at the cost of producing
fewer invariants. 
For more techniques for using Daikon with large programs
and long program runs, see <a href="#Large-dtrace-files">Large dtrace files</a>.

<div class="node">
<p><hr>
<a name="Detecting-invariants-in-Perl-programs"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Detecting-invariants-in-Eiffel-programs">Detecting invariants in Eiffel programs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Detecting-invariants-in-C_002fC_002b_002b-programs">Detecting invariants in C/C++ programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Example-usage">Example usage</a>

</div>

<h3 class="section">3.3 Detecting invariants in Perl programs</h3>

<p>The Daikon front end for Perl is called dfepl.

   <p>Using the Perl front end is a two-pass
process: first you must run the annotated program so that the runtime
system can dynamically infer the kind of data stored in each variable,
and then you must re-annotate and re-run the program with the added
type information. 
This is necessary because Perl programs do not contain type declarations.

   <p>dfepl requires version 5.8 or later of Perl.

<ul class="menu">
<li><a accesskey="1" href="#Instrumenting-Perl-programs">Instrumenting Perl programs</a>
<li><a accesskey="2" href="#Perl-examples">Perl examples</a>
</ul>

<div class="node">
<p><hr>
<a name="Instrumenting-Perl-programs"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Perl-examples">Perl examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Detecting-invariants-in-Perl-programs">Detecting invariants in Perl programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Detecting-invariants-in-Perl-programs">Detecting invariants in Perl programs</a>

</div>

<h4 class="subsection">3.3.1 Instrumenting Perl programs</h4>

<p>Perl programs must be instrumented twice.  First they must be
instrumented without type information.  Then, once the first
instrumented version has been run to produce type information, they
must be instrumented again taking the type information into account.

   <p>To instrument a stand-alone Perl program, invoke dfepl with
the name of the program as an argument.

<pre class="example">     dfepl program.pl
</pre>
   <p>To instrument a Perl module or a collection of modules, invoke
dfepl either with the name of each module, or with the name
of a directory containing the modules.  To instrument all the modules
in the current directory, give dfepl the argument <samp><span class="file">.</span></samp>. 
For instance, if the current directory contains a module
<code>Acme::Trampoline</code> in <samp><span class="file">Acme/Trampoline.pm</span></samp> and another
module <code>Acme::Date</code> in <samp><span class="file">Acme/Date.pm</span></samp>, they can be annotated
by either of the following two commands:

<pre class="example">     dfepl Acme/Trampoline.pm Acme/Date.pm
     dfepl .
</pre>
   <p>Once type information is available, run the instrumentation command
again with the <samp><span class="option">-T</span></samp> or <samp><span class="option">-t</span></samp> options added to use the
produced type information.

   <p>For more information about dfepl, see <a href="#dfepl">dfepl</a>.

<div class="node">
<p><hr>
<a name="Perl-examples"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Instrumenting-Perl-programs">Instrumenting Perl programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Detecting-invariants-in-Perl-programs">Detecting invariants in Perl programs</a>

</div>

<h4 class="subsection">3.3.2 Perl examples</h4>

<p>The Daikon distribution includes sample Perl programs suitable for use
with Daikon in the <samp><span class="file">examples/perl-examples</span></samp> directory.

   <p>Here are step-by-step instructions for examining a simple module,
<samp><span class="file">Birthday.pm</span></samp>, as used by a test script <samp><span class="file">test-bday.pl</span></samp>.

     <ol type=1 start=1>
<li>Change to the directory containing the <samp><span class="file">Birthday.pm</span></samp>
module.
     <pre class="example">          cd examples/perl-examples
</pre>
     <li>Instrument the <samp><span class="file">Birthday.pm</span></samp> file.
     <pre class="example">          dfepl Birthday.pm
</pre>
     <p>This command creates a directory <samp><span class="file">daikon-untyped</span></samp>, and puts
the instrumented version of <samp><span class="file">Birthday.pm</span></samp> into
<samp><span class="file">daikon-untyped/Birthday.pm</span></samp>.  As the directory name implies, this
instrumented version doesn't contain type information.

     <li>Run a test suite using the instrumented <samp><span class="file">Birthday.pm</span></samp>
file.
     <pre class="example">          dtype-perl test_bday.pl 10
</pre>
     <p>The <samp><span class="file">dtype-perl</span></samp> is a script that runs Perl with the appropriate
command line options to find the modules used by the Daikon Perl
runtime tracing modules, and to use the instrumented versions of
modules in <samp><span class="file">daikon-untyped</span></samp> in preference to their original
ones.  The number 10 is an argument to the <samp><span class="file">test_bday.pl</span></samp> script
telling it to run a relatively short test.

     <p>This will also generate a file
<samp><span class="file">daikon-instrumented/Birthday.types</span></samp> recording the type of each
variable seen during the execution of the instrumented program.

     <li>Re-annotate the module using the type information.
     <pre class="example">          dfepl -T Birthday.pm
</pre>
     <p>This step repeats step 2, except that the <samp><span class="option">-T</span></samp> flag to
dfepl tells it to use the type information generated in the
previous step, and to put the output in the directory
<samp><span class="file">daikon-instrumented</span></samp>.  dfepl also converts the
type information into a file <samp><span class="file">daikon-output/Birthday.decls</span></samp>
containing subroutine declarations suitable for Daikon.

     <li>Run the full test suite with the type-instrumented
<samp><span class="file">Birthday.pm</span></samp>.
     <pre class="example">          dtrace-perl test_bday.pl 30
</pre>
     <p>Here we run another test suite, which happens to be the same
<samp><span class="file">test_bday.pl</span></samp>, but running for longer. (The example will also
work with a smaller number).  The script <samp><span class="command">dtrace-perl</span></samp> is
similar to <samp><span class="command">dtype-perl</span></samp> mentioned earlier, but looks for
instrumented source files in <samp><span class="file">daikon-instrumented</span></samp>.

     <p>This creates <samp><span class="file">daikon-output/test_bday-combined.dtrace</span></samp>, a trace
file containing the values of variables at each invocation. (The
filename is formed from the name of the test program, with
<samp><span class="file">-combined</span></samp> appended because it contains the trace information
from all the instrumented modules invoked from the program).

     <li>Change to the <samp><span class="file">daikon-output</span></samp> directory to analyze the
output.
     <pre class="example">          cd daikon-output
</pre>
     <li>Run Daikon on the trace file
     <pre class="example">          java daikon.Daikon Birthday.decls test_bday-combined.dtrace
</pre>
     <li>Examine the invariants.  They are printed to standard output, and
they are also saved to file <samp><span class="file">Birthday.inv.gz</span></samp>, which you can
manipulate with the PrintInvariants program and other Daikon tools. 
For example:
     <pre class="example">          java daikon.PrintInvariants Birthday.inv.gz
</pre>
     <p>Invariants produced from Perl programs can be examined using the same
tools as other Daikon invariants.
        </ol>

   <p>In the example above, the script <samp><span class="file">test_bday.pl</span></samp> was not itself
instrumented; it was only used to test the instrumented code.  The
Perl front end can also be used to instrument stand-alone Perl
programs.  The following sequence of commands, similar to those above,
show how Daikon can be used with the stand-alone program
<samp><span class="file">standalone.pl</span></samp>, also in the <samp><span class="file">examples/perl-examples</span></samp>
directory.

<pre class="example">     dfepl standalone.pl
     dtype-perl daikon-untyped/standalone.pl
     dfepl -T standalone.pl
     dtrace-perl daikon-instrumented/standalone.pl
     cd daikon-output
     java daikon.Daikon -o standalone.inv standalone-main.decls \
          standalone-combined.dtrace
</pre>
   <p>Note two differences when running a stand-alone program.  First, the
instrumented versions of the program, in the <samp><span class="file">daikon-untyped</span></samp> or
<samp><span class="file">daikon-instrumented</span></samp> directory, are run directly.  Second, the
declarations file is named after the package in which the subroutines
were declared, but since every stand-alone program uses the
<code>main</code> package, the name of the program is prepended to the
<samp><span class="file">.decls</span></samp> file name to avoid collisions.

<div class="node">
<p><hr>
<a name="Detecting-invariants-in-Eiffel-programs"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Detecting-invariants-in-Perl-programs">Detecting invariants in Perl programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Example-usage">Example usage</a>

</div>

<h3 class="section">3.4 Detecting invariants in Eiffel programs</h3>

<p>CITADEL is an Eiffel front-end to the Daikon invariant detector. 
You can obtain Citadel and its documentation from
<a href="http://se.inf.ethz.ch/people/polikarpova/citadel.html">http://se.inf.ethz.ch/people/polikarpova/citadel.html</a>.

<div class="node">
<p><hr>
<a name="Running-Daikon"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Daikon-output">Daikon output</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Example-usage">Example usage</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Running Daikon</h2>

<p>This section describes how to run Daikon on a data trace
(<samp><span class="file">.dtrace</span></samp>) file, and describes Daikon's command-line options. 
This section assumes you have already run a front end (e.g., an
instrumenter) to produce a <samp><span class="file">.dtrace</span></samp> file (and optionally
<samp><span class="file">.decl</span></samp> and <samp><span class="file">.spinfo</span></samp> files); to learn more about that
process, see <a href="#Example-usage">Example usage</a>, and see <a href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>.

   <p>Run the Daikon invariant detector via the command
<pre class="smallexample">     java daikon.Daikon <i>[</i><var>flags</var><i>]</i> <var>dtrace-files...</var> <i>[</i><var>decl-files...</var><i>]</i> <i>[</i><var>spinfo-files...</var><i>]</i>
</pre>
     <ul>
<li>The <var>dtrace-files</var> are data trace (<samp><span class="file">.dtrace</span></samp>) files containing
variable values from an execution of the target program.

     <li>The <var>decl-files</var> are declaration (<samp><span class="file">.decl</span></samp>) files containing
program point declarations.  Be sure to include all declaration files
that are needed for the particular data trace file; the simplest way
is to include every declaration file created when instrumenting the
program.

     <p>Not all Daikon front ends produce <samp><span class="file">.decl</span></samp> files, since program point
declarations may also appear in <samp><span class="file">.dtrace</span></samp> files.  For instance, the
Chicory front end for Java (see <a href="#Chicory">Chicory</a>) produces only <samp><span class="file">.dtrace</span></samp>
files.  If there are no <samp><span class="file">.decl</span></samp> files, then it is not necessary to
include them on the command line to Daikon.

     <li>The <var>spinfo-files</var> are splitter info (<samp><span class="file">.spinfo</span></samp>) files that
enable detection of conditional invariants (see <a href="#Conditional-invariants">Conditional invariants</a>); these are optional and may be created automatically or by hand.

   </ul>
   The files may appear in any order;
the file type is determined by whether the file name contains
<samp><span class="file">.decls</span></samp>, <samp><span class="file">.dtrace</span></samp>, or <samp><span class="file">.spinfo</span></samp>. 
As a special case, a file name of <samp><span class="file">-</span></samp> means to read data trace
information from standard input.

   <p><a name="index-command-line-options-for-Daikon-9"></a><a name="index-flags-for-Daikon-10"></a>The optional flags are described in the sections that follow.  For
further ways to control Daikon's behavior via configuration options, see
<a href="#Configuration-options">Configuration options</a>, and see the list of options to the front
end such as Chicory (see <a href="#Chicory-options">Chicory options</a>) or Kvasir (see <a href="#Kvasir-options">Kvasir options</a>).

<ul class="menu">
<li><a accesskey="1" href="#Options-to-control-Daikon-output">Options to control Daikon output</a>
<li><a accesskey="2" href="#Options-to-control-invariant-detection">Options to control invariant detection</a>
<li><a accesskey="3" href="#Processing-only-part-of-the-trace-file">Processing only part of the trace file</a>
<li><a accesskey="4" href="#Daikon-configuration-options">Daikon configuration options</a>
<li><a accesskey="5" href="#Daikon-debugging-options">Daikon debugging options</a>
</ul>

<div class="node">
<p><hr>
<a name="Options-to-control-Daikon-output"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Options-to-control-invariant-detection">Options to control invariant detection</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-Daikon">Running Daikon</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Running-Daikon">Running Daikon</a>

</div>

<h3 class="section">4.1 Options to control Daikon output</h3>

<!-- Unfortunately, @option{} adds quotes in the Info and printed output -->
<!-- which is not necessary in a table.  However, @t and @code compress -->
<!-- the two hyphens to one in Info and HTML output, which is even worse. -->
     <dl>
<dt><samp><span class="option">--help</span></samp><dd>Print usage message.

     <br><dt><samp><span class="option">-o </span><var>inv_file</var></samp><dd>Output serialized invariants to the specified file; they can later be
postprocessed, compared, etc.  Default: <samp><var>basename</var><span class="file">.inv.gz</span></samp> in
the current directory, where the first data trace file's basename starts
with <samp><var>basename</var><span class="file">.dtrace</span></samp>.  Default is no serialized output, if
no such data trace file was supplied.  If a data trace file was
supplied, there is currently no way to avoid creating a serialized
invariant file.

     <br><dt><samp><span class="option">--no_text_output</span></samp><dd>Don't print invariants as text output.  This option may be used in
conjunction with the <samp><span class="option">-o</span></samp> option.

     <br><dt><samp><span class="option">--format </span><var>name</var></samp><dd>Produce output in the given format.  For a list of the output formats
supported by Daikon, see <a href="#Invariant-syntax">Invariant syntax</a>.

     <br><dt><samp><span class="option">--show_progress</span></samp><dt><samp><span class="option">--no_show_progress</span></samp><dd>Prints (respectively, suppresses) timing information as major portions of Daikon are executed.

     <br><dt><samp><span class="option">--noversion</span></samp><dd>Suppress the printing of version information

     <br><dt><samp><span class="option">--output_num_samples</span></samp><dd><a name="index-samples-breakdown-output-11"></a><a name="index-mux-output-12"></a>Output numbers of values and samples for invariants and program points;
this is a debugging flag.  (That is, it helps you understand why Daikon
produced the output that it did.)

     <p>The &ldquo;Samples breakdown&rdquo; output indicates how many samples in the
<samp><span class="file">.dtrace</span></samp> file had a modified value (&ldquo;m&rdquo;), had an unmodified
value (&ldquo;u&rdquo;), and had a missing value (&ldquo;x&rdquo;).  The summary uses a
capital letter if the sample had any of the corresponding type of
variable, and a lower-case letter if it had none.  These types affect
statistical tests that determine whether a particular invariant (that
was true over all the test runs) is printed.

     <p>Only variables that appear in both the pre-state and the post-state
(variables that are in scope at both procedure exit and entry) are
eligible to be listed as modified or unmodified.  This is why the list
of all variables is not the union of the modified and unmodified
variables.

     <br><dt><samp><span class="option">--files_from </span><var>filename</var></samp><dd>Read a list of <samp><span class="file">.decl</span></samp>, <samp><span class="file">.dtrace</span></samp>, or <samp><span class="file">.spinfo</span></samp> files from the
given text file, one filename per line, as an alternative to providing
them on the command line.

     <br><dt><samp><span class="option">--server </span><var>dirname</var></samp><dd>Server mode for Daikon in which it reads files from <var>dirname</var> as they appear (sorted lexicographically) until it finds a file ending in &ldquo;.end&rdquo;, at which point it calculates and outputs the invariants.

     <br><dt><samp><span class="option">--omit_from_output [0rs]</span></samp><dd>Omit some potentially redundant information from the serialized output
file produced with <samp><span class="option">-o</span></samp>. 
By default, the serialized output contains all of the data structures
produced by Daikon while inferring invariants. 
Depending on the use to which the serialized output will later be put,
the file can sometimes be significantly shortened by omitting
information that is no longer needed. 
The flag should be followed by one or more characters each representing
a kind of structures the can be omitted. 
The following characters are recognized:

          <dl>
<dt><samp><span class="option">0 (zero)</span></samp><dd>Omit information about program points that were declared, but for which
no samples were found in any <samp><span class="file">.dtrace</span></samp> file.

          <br><dt><samp><span class="option">r</span></samp><dd>Omit &ldquo;reflexive&rdquo; invariants, those in which a variable appears more
than once. 
Usually, such invariants are not interesting, because their meaning is
duplicated by invariants with fewer variables: for instance, <code>x =
x - x</code> and <code>y = z + z</code> can be expressed as <code>x = 0</code> and
<code>y = 2 * z</code> instead. 
However, Daikon generates and uses such invariants internally to
decide what invariants to create when two previously equal variables
turn out to be different.

          <br><dt><samp><span class="option">s</span></samp><dd>Omit invariants that are suppressed by other invariants. 
&ldquo;Suppression&rdquo; refers to a particular optimization
in which the processing of an invariant is
postponed as long as certain other invariants that logically imply it
hold. 
</dl>

     <p>For most uses of serialized output in the current version, it is safe
to use the <samp><span class="option">0</span></samp> and <samp><span class="option">r</span></samp> omissions, but the <samp><span class="option">s</span></samp> omission
will cause subtle output changes. 
In many cases, the amount of space saved is modest (typically around
10%), but the savings can be more substantial for programs with many
unused program points, or program points with many variables.

</dl>

<div class="node">
<p><hr>
<a name="Options-to-control-invariant-detection"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Processing-only-part-of-the-trace-file">Processing only part of the trace file</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Options-to-control-Daikon-output">Options to control Daikon output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Running-Daikon">Running Daikon</a>

</div>

<h3 class="section">4.2 Options to control invariant detection</h3>

     
<a name="index-confidence-limit-13"></a>
<dl><dt><samp><span class="option">--conf_limit </span><var>val</var></samp><dd>Set the confidence limit for justifying invariants. 
If the confidence level for a given invariant is larger than the limit, then
Daikon outputs the invariant.  This mechanism filters out
invariants that are satisfied purely by chance. 
This is only relevant to invariants that were true in all observed
samples; Daikon never outputs invariants that were ever false.

     <p><var>val</var> must be between 0 and 1; the default is .99.  Larger values
yield stronger filtering.

     <p>Each type of invariant has its own rules for determining confidence. 
See the <code>computeConfidence</code> method in the Java source code for the
invariant.

     <p>For example, consider the invariant <var>a</var>&lt;<var>b</var> whose confidence computation
is <code>1 - 1/2^</code><var>numsamples</var>, which indicates the likelihood that the
observations of <var>a</var> and <var>b</var> did not occur by chance.  If there were 3
samples, and <var>a</var>&lt;<var>b</var> on all of them, then the confidence would be 7/8 =
.875.  If there were 6 samples, and <var>a</var>&lt;<var>b</var> on only 5 on them, the
confidence would be 0.  If there were 9 samples, and <var>a</var>&lt;<var>b</var> on all of
them, then the confidence would be 1-1/2^9 = .998.

     <p>There are two ways to print the confidence of each invariant.  You can
use Diff (see <a href="#Invariant-Diff">Invariant Diff</a>):
     <pre class="example">          java daikon.diff.Diff MyFile.inv.gz
</pre>
     <p>or you can use PrintInvariants
(see <a href="#Printing-invariants">Printing invariants</a>):
     <pre class="example">          java daikon.PrintInvariants --dbg daikon.PrintInvariants.repr MyFile.inv.gz
</pre>
     <p>To print the confidence of each invariant that is discarded, run Daikon
with the <samp><span class="option">--disc_reason all</span></samp> command-line option (see <a href="#Daikon-debugging-options">Daikon debugging options</a>).

     <br><dt><samp><span class="option">--list_type </span><var>classname</var></samp><dd>Indicate that the given class implements the <code>java.util.List</code>
interface.  The preferred mechanism for indicating such information is
the <code>ListImplementors</code> section of the <samp><span class="file">.decls</span></samp> file. 
See <a href="developer.html#V1-ListImplementors-declaration">V1 ListImplementors declaration</a>.

     <br><dt><samp><span class="option">--nohierarchy</span></samp><dd><a name="index-hierarchy_002c-disabling-14"></a><a name="index-unmatched-entries_002c-not-ignoring-15"></a>Avoid connecting program points in a dataflow hierarchy.  For example,
Daikon normally connects the <code>:::ENTER</code> program points of class methods
with the class's <code>:::CLASS</code> program point, so that any invariant
that holds on the <code>:::CLASS</code> program point is considered to hold
true on the <code>:::ENTER</code>
program point.  With no hierarchy, each program point is treated
independently.  This is for using Daikon on applications that do not
have a concept of hierarchy.  It can also be useful when you wish to
process unmatched enter point samples from a trace file that is missing
some exit point samples.

     <br><dt><samp><span class="option">--suppress_redundant</span></samp><dd>Suppress display of logically redundant invariants, using the Simplify
automatic theorem prover.  Daikon already suppresses most logically
redundant output.  For example, if &ldquo;x &gt;= 0&rdquo; and &ldquo;x &gt; 0&rdquo; are both
true, then Daikon outputs only &ldquo;x &gt; 0&rdquo;.  Use of the
<samp><span class="option">--suppress_redundant</span></samp> option tells Daikon to use Simplify to
eliminate even more redundant output, and should be used if it is
important that absolutely no redundancies appear in the output.

     <p>Simplify must be separately obtained (from
<a href="http://www.hpl.hp.com/downloads/crl/jtk/">http://www.hpl.hp.com/downloads/crl/jtk/</a>) and installed in
order to take advantage of this option.  Beware that Simplify can run slowly;
the amount of effort Simplify exerts for each invariant can be controlled
using the <samp><span class="option">daikon.simplify.Session.simplify_max_iterations</span></samp> and
<samp><span class="option">daikon.simplify.Session.simplify_timeout</span></samp> configuration
options.

</dl>

<div class="node">
<p><hr>
<a name="Processing-only-part-of-the-trace-file"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Daikon-configuration-options">Daikon configuration options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Options-to-control-invariant-detection">Options to control invariant detection</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Running-Daikon">Running Daikon</a>

</div>

<h3 class="section">4.3 Processing only part of the trace file</h3>

<p>Using <samp><span class="option">--ppt-select-pattern</span></samp> and <samp><span class="option">--ppt-omit-pattern</span></samp> can
save time even if there are no samples for the excluded program points,
as Daikon can skip the declarations and need not initialize data
structures that would be used if samples were encountered.

     <dl>
<dt><samp><span class="option">--ppt-select-pattern=</span><var>ppt_regexp</var></samp><dd>Only process program points whose names match the regular expression. 
The <samp><span class="option">--ppt-omit-pattern</span></samp> argument takes precedence over this argument.

     <br><dt><samp><span class="option">--ppt-omit-pattern=</span><var>ppt_regexp</var></samp><dd>Do not process program points whose names match the regular expression. 
This takes precedence over the <samp><span class="option">--ppt-select-pattern</span></samp> argument.

     <br><dt><samp><span class="option">--var-select-pattern=</span><var>var_regexp</var></samp><dd>Only process variables (whether in the trace file or derived) whose
names match the regular expression. 
The <samp><span class="option">--var-omit-pattern</span></samp> argument takes precedence over this argument.

     <br><dt><samp><span class="option">--var-omit-pattern=</span><var>var_regexp</var></samp><dd>Ignore variables (whether in the trace file or derived) whose names
match the regular expression. 
This takes priority over the <samp><span class="option">--var-select-pattern</span></samp> argument.

   </dl>

   <p>The <var>...-omit-pattern</var> arguments take precedence:  if a name matches
an omit pattern, it is excluded.  If a name does not match an omit
pattern, it is tested against the select pattern (if any).  If any
select patterns are specified, the name must match one of the patterns
in order to be included.  If no select patterns are specified, then any
ppt name that does not match the omit patterns is included.

   <p>All of the regular expressions used by Daikon use Java's
regular expression syntax, which is similar to Perl's but not
exactly the same.  Details are available at
<a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html#sum">http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html#sum</a>. 
Multiple items can be matched by using the logical or operator (|),
for example <var>var1|var2|var3</var>.

<div class="node">
<p><hr>
<a name="Daikon-configuration-options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Daikon-debugging-options">Daikon debugging options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Processing-only-part-of-the-trace-file">Processing only part of the trace file</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Running-Daikon">Running Daikon</a>

</div>

<h3 class="section">4.4 Daikon configuration options</h3>

     <dl>
<dt><samp><span class="option">--config </span><var>filename</var></samp><dd>Load the configuration settings specified in the given file. 
See <a href="#Configuration-options">Configuration options</a>, for details.

     <br><dt><samp><span class="option">--config_option </span><var>name</var><span class="option">=</span><var>value</var></samp><dd>Specify a single configuration setting. 
See <a href="#Configuration-options">Configuration options</a>, for details.

</dl>

<div class="node">
<p><hr>
<a name="Daikon-debugging-options"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Daikon-configuration-options">Daikon configuration options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Running-Daikon">Running Daikon</a>

</div>

<h3 class="section">4.5 Daikon debugging options</h3>

     <dl>
<dt><samp><span class="option">--dbg </span><var>category</var></samp><dt><samp><span class="option">--debug</span></samp><dd><a name="index-debugging-flags-16"></a><a name="index-category_002c-for-debugging-17"></a><a name="index-logging_002c-for-debugging-Daikon-18"></a><a name="index-Logger-19"></a>These debugging options cause output to be written to a log file (by
default, to the terminal); in other words, they enable a Logger. 
The <samp><span class="option">--dbg </span><var>category</var></samp> option
enables debugging output for a specific part of Daikon; it may be
specified multiple times, permitting find-grained control over debugging
output.  The <samp><span class="option">--debug</span></samp> option turns on all debugging flags. 
(This produces a lot of output!)  Most categories are class or
package names in the Daikon implementation, such as <code>daikon.split</code>
or <code>daikon.derive.binary.SequencesJoin</code>.  Only classes that check
the appropriate categories are affected by the debug flags; you can
determine this by looking for a call to &lsquo;<samp><span class="samp">Logger.getLogger</span></samp>&rsquo; in
the specific class.

     <br><dt><samp><span class="option">--track </span><var>class</var><span class="option">&lt;</span><var>var1</var><span class="option">,</span><var>var2</var><span class="option">,</span><var>var3</var><span class="option">&gt;@</span><var>ppt</var></samp><dd><a name="index-debugging-flags-20"></a><a name="index-category_002c-for-debugging-21"></a><a name="index-logging_002c-for-debugging-Daikon-22"></a><a name="index-Logger-23"></a>Turns on debugging information on the specified class, variables, and
program point.  In contrast to the <samp><span class="option">--dbg</span></samp> option, track logging follows
a particular invariant through Daikon.  Multiple <samp><span class="option">--track</span></samp> options
can be specified.  Each item (class, variables, and program point) is optional. 
Multiple classes can be specified separated by vertical bars (|).  Matching
is a simple substring (not a regular expression) comparison.  Each item
must match in order for a printout to occur.  For more information, see
<a href="developer.html#Track-logging">Track logging</a>.

     <br><dt><samp><span class="option">--disc_reason </span><var>inv_class</var><span class="option">&lt;</span><var>var1</var><span class="option">,</span><var>var2</var><span class="option">,...&gt;@</span><var>ppt</var></samp><dd>Prints all discarded invariants of class <var>inv_class</var> at the program point
specified that involve exactly the variables given, as well as a short reason
and discard code explaining why they were not worthy of print.  Any of
the three parts of the argument may be made a wildcard by excluding it. 
For example, &lsquo;<samp><var>inv_class</var></samp>&rsquo; and
&lsquo;<samp><span class="samp">&lt;</span><var>var1</var><span class="samp">,</span><var>var2</var><span class="samp">,...&gt;@</span><var>ppt</var></samp>&rsquo; are valid arguments. 
Concrete examples are &lsquo;<samp><span class="samp">Implication&lt;x,y&gt;@foo():::EXIT</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">Implication&lt;x,y&gt;</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">&lt;x,y&gt;@foo():::EXIT</span></samp>&rsquo;. 
To print all discarded invariants, use the argument &lsquo;<samp><span class="samp">all</span></samp>&rsquo;.

     <br><dt><samp><span class="option">--mem_stat</span></samp><dd>Prints memory usage statistics into a file named <samp><span class="file">stat.out</span></samp> in the
current directory.

</dl>

<div class="node">
<p><hr>
<a name="Daikon-output"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Enhancing-Daikon-output">Enhancing Daikon output</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running-Daikon">Running Daikon</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Daikon output</h2>

<p>Daikon outputs the invariants that it discovers in textual form to your
terminal.  This chapter describes how to interpret those invariants &mdash;
in other words, what do they mean?

   <p>Daikon also creates a <samp><span class="file">.inv</span></samp> file that contains the invariants in
serialized (binary) form.  You can use the <samp><span class="file">.inv</span></samp> file to print the
invariants (see <a href="#Printing-invariants">Printing invariants</a>) in a variety of formats, to
insert the invariants in your source code (see <a href="#Annotate">Annotate</a>), to perform
run-time checking of the invariants (see <a href="#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a>,
and <a href="#InvariantChecker">InvariantChecker</a>), and to do various other operations.  See
<a href="#Tools">Tools</a>, for descriptions of such tools.

   <p>If you wish to write your own tools for processing invariants, you have
two general options.  You can parse Daikon's textual output, or you can
write Java code that processes the <samp><span class="file">.inv</span></samp> file.  The <samp><span class="file">.inv</span></samp>
file is simply a serialized
<a href="http://groups.csail.mit.edu/pag/daikon/download/jdoc/daikon/PptMap.html"><code>PptMap</code></a>
object.  In addition to reading the Javadoc, you can examine how the
other tools use this data structure.

<ul class="menu">
<li><a accesskey="1" href="#Invariant-syntax">Invariant syntax</a>
<li><a accesskey="2" href="#Program-points">Program points</a>
<li><a accesskey="3" href="#Variable-names">Variable names</a>
<li><a accesskey="4" href="#Interpreting-output">Interpreting output</a>
<li><a accesskey="5" href="#Invariant-list">Invariant list</a>
<li><a accesskey="6" href="#Invariant-filters">Invariant filters</a>
</ul>

<div class="node">
<p><hr>
<a name="Invariant-syntax"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Program-points">Program points</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Daikon-output">Daikon output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-output">Daikon output</a>

</div>

<h3 class="section">5.1 Invariant syntax</h3>

<p>Daikon can produce output in a variety of formats.  Each of the format
names can be specified as an argument to the <samp><span class="option">--format</span></samp> argument
of Daikon (see <a href="#Options-to-control-Daikon-output">Options to control Daikon output</a>), PrintInvariants
(see <a href="#Printing-invariants">Printing invariants</a>), and Annotate (see <a href="#Annotate">Annotate</a>). 
When passed on the command line, the format names are case-insensitive:
<samp><span class="option">--format JML</span></samp> and <samp><span class="option">--format jml</span></samp> have the same effect.

   <p>You can enhance Daikon to produce output in other formats.  See
<a href="developer.html#New-formatting-for-invariants">New formatting for invariants</a>

   <p><a name="index-invariant-output-format-24"></a><a name="index-output-format_002c-for-invariants-25"></a>
     
<a name="index-Daikon-output-format-26"></a>
<a name="index-output-format_002c-Daikon-27"></a>
<dl><dt>Daikon format<dd>
Daikon's default format is a mix of Java, mathematical logic, and some
additional extensions.  It is intended to concisely convey meaning to
programmers.

     <p><a name="index-DBC-output-format-28"></a><a name="index-output-format_002c-DBC-29"></a><a name="index-Jtest-DBC-output-format-30"></a><a name="index-output-format_002c-Jtest-DBC-31"></a><br><dt>DBC format<dd>This format produces output in the design-by-contract (DBC) format
expected by Parasoft's Jtest tool (<a href="http://www.parasoft.com">http://www.parasoft.com</a>).

     <!-- This implementation detail is not relevant to users -->
     <!-- Like the Java output format, this output format makes extensive use of -->
     <!-- helper methods defined in class @code{daikon.Quant}. -->
     <p><a name="index-ESC_002fJava-output-format-32"></a><a name="index-output-format_002c-ESC_002fJava-33"></a><br><dt>ESC/Java format<dt>ESC format<dd>The Extended Static Checker for Java (ESC/Java) is a programming tool
for finding errors in Java programs by checking annotations that are
inserted in source code; for more details, see
<a href="http://www.hpl.hp.com/downloads/crl/jtk/">http://www.hpl.hp.com/downloads/crl/jtk/</a>.  Daikon's ESC/Java format
(which can also be specified as ESC format) is intended for use with the
original ESC/Java tool.  Use Daikon's JML format for use with the
<a href="http://kind.ucd.ie/products/opensource/ESCJava2/">ESC/Java2</a>
tool.

     <p><a name="index-Java-output-format-34"></a><a name="index-output-format_002c-Java-35"></a><br><dt>Java format<dd>Write output as Java expressions.  This means that each invariant
would be a valid Java expression, if inserted at the correct program
point: right after method entry, for method entry invariants;
right before method exit, for method exit invariants;, or anywhere in
the code, for object invariants.

     <p>There are two exceptions.  Method exit invariants that refer to
prestate, such as &lsquo;<samp><span class="samp">x == old(x) + 1</span></samp>&rsquo;, are output with the tag
&lsquo;<samp><span class="samp">\old</span></samp>&rsquo; surrounding the prestate expression (e.g. &lsquo;<samp><span class="samp">x ==
\old(x) + 1</span></samp>&rsquo;.  Method exit invariants that refer to the return value of
the method, such as &lsquo;<samp><span class="samp">return == x + y</span></samp>&rsquo;, are output with the tag
&lsquo;<samp><span class="samp">\result</span></samp>&rsquo; in place of the return value (e.g. &lsquo;<samp><span class="samp">\result == x + y</span></samp>&rsquo;). 
These expression are obviously not valid Java code.

     <!-- This implementation detail not relevant to users -->
     <!-- The Java output format makes extensive use of helper methods defined -->
     <!-- in class @code{daikon.Quant}, which provides methods for -->
     <!-- quantification and set comprehension over Java collections.  For -->
     <!-- example, @code{daikon.Quant.eltsEqual(int[] seq1, int elt)} checks -->
     <!-- whether all elements in @code{seq1} are equal to @code{elt}.  For -->
     <!-- detailed meanings of all methods in the @code{Quant} class, see the -->
     <!-- Javadoc documentation for the class (or look inside -->
     <!-- @file{daikon/QuantBody.java}). -->
     <p><a name="index-JML-output-format-36"></a><a name="index-output-format_002c-JML-37"></a><br><dt>JML format<dd>Produces output in JML (Java Modeling Language,
<a href="http://www.jmlspecs.org">http://www.jmlspecs.org</a>); for details, see the
<a href="http://www.cs.ucf.edu/~leavens/JML/">JML Manual</a>.  JML
format lets you use the various JML tools on Daikon invariants,
including runtime assertion checking and the
<a href="http://kind.ucd.ie/products/opensource/ESCJava2/">ESC/Java2</a>
tool.

     <!-- This implementation detail not relevant to users -->
     <!-- Like the Java output format, this output format makes extensive use of -->
     <!-- helper methods defined in class @code{daikon.Quant}. -->
     <p><a name="index-Simplify-output-format-38"></a><a name="index-output-format_002c-Simplify-39"></a><br><dt>Simplify format<dd>Produces output in the format expected by the Simplify automated theorem
prover; for details, see the
<!-- was: @uref{http://research.compaq.com/SRC/esc/simplify/InputSyntax.html} -->
<a href="http://www.hpl.hp.com/downloads/crl/jtk/">Simplify distribution</a>.

   </dl>

<div class="node">
<p><hr>
<a name="Program-points"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Variable-names">Variable names</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Invariant-syntax">Invariant syntax</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-output">Daikon output</a>

</div>

<h3 class="section">5.2 Program points</h3>

<p><a name="index-program-point-40"></a>
A program point is a specific place in the source code, such as
immediately before a particular line of code.  Daikon's output is
organized by program points.

   <p><a name="index-g_t_003a_003a_003aENTER-program-point-41"></a><a name="index-ENTER-program-point-42"></a><a name="index-precondition-43"></a>
For example, <code>foo():::ENTER</code> is the point at the entry to procedure
<code>foo()</code>; the invariants at that point are the preconditions for the
<code>foo()</code> method, properties that are always true when the procedure
is invoked.

   <p><a name="index-g_t_003a_003a_003aEXIT-program-point-44"></a><a name="index-EXIT-program-point-45"></a><a name="index-postcondition-46"></a><a name="index-hierarchy-of-program-points-47"></a><a name="index-program-point-hierarchy-48"></a>
Likewise, <code>foo():::EXIT</code> is the program point at the procedure
exit, and invariants there are postconditions.  When there are multiple
exit points from a procedure (for instance, because of multiple
<code>return</code> statements), the different exits are differentiated by
suffixing them with their line numbers; for instance,
<code>StackAr.top():::EXIT79</code>.  The exit point lacking a line number (in
this example, <code>StackAr.top():::EXIT</code>) collects the postconditions
that are true at every numbered exit point.  This is an example of a
program point that represents a collection of locations in the program
source rather than a single location.  This concept is represented in
Daikon by the dataflow hierarchy, see
<a href="developer.html#Dataflow-hierarchy">Dataflow hierarchy</a>.

   <p><a name="index-g_t_003a_003a_003aOBJECT-program-point-49"></a><a name="index-OBJECT-program-point-50"></a><a name="index-g_t_003a_003a_003aCLASS-program-point-51"></a><a name="index-CLASS-program-point-52"></a><a name="index-object-invariants-53"></a><a name="index-representation-invariants-54"></a><a name="index-class-invariants-55"></a>
Two other program point tags that have special meaning to Daikon's hierarchy
organization are <code>:::OBJECT</code> and <code>:::CLASS</code>. 
The <code>:::OBJECT</code> tag indicates object invariants (sometimes called
representation invariants or class invariants) over all the instance
(member) fields and static fields of the class.  These properties always hold
for any object of the given class, from the point of view of a client or
user.  These properties hold at entry to and exit from every public
method of the class (except not the entry to constructors, when fields
are not yet initialized).

   <p>The <code>:::CLASS</code> tag is just like <code>:::OBJECT</code>, but only for
static variables, which have only one value for all objects.  Static
fields and instance fields are often used for different purposes. 
Daikon's separation of the two types of fields permits programmers to
see the properties over the static fields without knowing which are the
static fields and pick them out of the <code>:::OBJECT</code> program point.

   <p><a name="index-private-methods-56"></a>
(By contrast, ESC/Java and JML make class invariants hold even at the
entry and exit of private methods.  Their designers believe that most
private methods preserve the class invariant and are called only when
the class invariant holds.  ESC/Java and JML require an explicit
&ldquo;helper&rdquo; annotation to indicate a private method for which the class
invariant does not hold.)

   <p>The Java instrumenter Chicory selects names for program
points that include an indication of the argument and return types for
each method.  These signatures are presented in the JVML format: one
character for each primitive type (&lsquo;<samp><span class="samp">B</span></samp>&rsquo; for byte, &lsquo;<samp><span class="samp">C</span></samp>&rsquo; for
character, &lsquo;<samp><span class="samp">Z</span></samp>&rsquo; for boolean (so as not to clash with byte), etc.);
&lsquo;<samp><span class="samp">L</span><var>classname</var><span class="samp">;</span></samp>&rsquo; for object types; and a &lsquo;<samp><span class="samp">[</span></samp>&rsquo;
prefix for each level of array nesting.

<div class="node">
<p><hr>
<a name="Variable-names"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Interpreting-output">Interpreting output</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Program-points">Program points</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-output">Daikon output</a>

</div>

<h3 class="section">5.3 Variable names</h3>

<p>A front end produces a trace file that associates trace variable names
with values.  Trace variable names need not be exactly the same as the
variables in the program.  The trace may contain values that are not
held in any program variables; in this case, the front end must make up
a name to express that value (see below for examples).

   <p>Daikon ignores variable names when inferring invariants; it uses the
names only when performing output.  (Thus, the only practical
restriction on trace names is that the VarInfoName <code>parse</code> method
must be able to parse the name.)

   <p>By convention, trace variables are similar to program variables and
field accesses.  For example, <code>w</code> and <code>x.y.z</code> are legal trace
variables.  (So are &lsquo;<samp><span class="samp">a[i]</span></samp>&rsquo;, and
&lsquo;<samp><span class="samp">a[0].next</span></samp>&rsquo;, but these are usually handled as derived variables
instead; see below.)  As in languages such as
Java and C, a period character represents field access and square
brackets represent selecting an element of a sequence.

   <p><a name="index-derived-variables_002c-explanation-of-57"></a>
In addition to variables that appear in the trace file, Daikon creates
additional variables, called &ldquo;derived variables&rdquo;, by combining trace
variables.  For example, for any array <code>a</code> and integer <code>i</code>,
Daikon creates a derived variable <code>a[i]</code>.  This is not a variable
in the program (and this expression might not even appear in the source
code), but it may still be useful to compute invariants over this
expression.  For a list of derived variables and how to control Daikon's
use of them, see <a href="#Options-to-enable_002fdisable-derived-variables">Options to enable/disable derived variables</a>.

   <p><a name="index-nonsensical-values-for-variables-58"></a>
Some trace variables and derived variables may represent meaningless
expressions; in such a circumstance, the value is said to be nonsensical
(see <a href="developer.html#Nonsensical-values">Nonsensical values</a>).

   <p>The remainder of this section describes conventions for naming
expressions.  Those that cannot be named by simple C/Java expressions
are primarily related to arrays and sequences.  (In part, these special
expressions are necessary because Daikon can only handle variables of
scalar (integer, floating-point, boolean, String) and array-of-scalar
types.  Daikon cannot handle structs, classes, or multi-dimensional
arrays or structures, but such data structures can be represented as
scalars and arrays by choosing variable names that indicate their
relationship.)

     <ul>
<li><code>a[i]</code> array access. 
<code>a</code> and <code>i</code> are themselves
arbitrary variable names, of array and integral type, respectively.

     <li><a name="index-g_t_0040code_007b_002d1_007d-array-index-_0028counts-from-end-of-array_0029-59"></a><a name="index-negative-array-index-_0028counts-from-end-of-array_0029-60"></a><code>a[-1]</code> from-end array access. 
<code>a[-1]</code> denotes the last element of array <code>a</code>;
it is syntactic sugar for <code>a[a.length-1]</code>.

     <li><a name="index-g_t_0040code_007b_005b_005d_007d-variable-name-_0028array-contents_0029-61"></a><code>a[]</code> array contents. 
For array-valued expression <code>a</code>, all of its elements, as a
sequence.  Simply using the expression <code>a</code> means the identity
(address or hashcode) of the array, not a list of its elements.  For two
arrays <code>a</code> and <code>b</code>, &lsquo;<samp><span class="samp">a=b</span></samp>&rsquo; implies &lsquo;<samp><span class="samp">a[]=b[]</span></samp>&rsquo;, but
&lsquo;<samp><span class="samp">a[]=b[]</span></samp>&rsquo; does not imply &lsquo;<samp><span class="samp">a=b</span></samp>&rsquo;.

     <li><code>x.y</code>, <code>x-&gt;y</code> field access. 
When field access is applied to a structure/class, it has the usual
meaning of selecting one field from the structure/class.

     <p>When field access is applied to an array, it means to map the field
access across the elements of the array.  For example, if <code>a</code> is an
array, then <code>a[].foo</code> is the sequence consisting of the <code>foo</code>
fields of each of the elements of <code>a</code>.  Likewise,
<code>a[].foo.bar</code> contains the <code>bar</code> fields of <code>a[].foo</code>.  By
contrast, <code>a.foo</code> does not make sense, because one cannot ask for
the <code>foo</code> field of an address, and <code>a[].foo[]</code> would be a
two-dimensional array.

     <!-- This is valuable and true, but probably more than users need to know. -->
     <!-- In Mangel-Wurzel, fields of the @samp{this} parameter print as -->
     <!-- @samp{this->@var{fieldname}}. -->
     <li><a name="index-g_t_0040code_007b_002egetClass_0028_0029_007d-variable-62"></a>As in Java, <code>x.getClass()</code> is the runtime type of <code>x</code>, which may
differ from its declared type.

     <li><a name="index-g_t_0040code_007b_002elength_007d-variable-name-63"></a><code>a.length</code> is the length (number of elements) of array <code>a</code>;
this is not necessarily the number of initialized or used elements.

     <li><a name="index-g_t_0040code_007b_002etoString_007d-variable-64"></a><code>s.toString</code> is the string value of String <code>s</code>, namely a
sequence of characters.

     <li><code>Classname.varname</code> static class variable. 
Static variables of a class have names of the form
&lsquo;<samp><var>classname</var><span class="samp">.</span><var>varname</var></samp>&rsquo;

     <li><a name="index-g_t_0040code_007borig_0028_0029_007d-variable-_0028pre_002dstate-value_0029-65"></a><a name="index-pre_002dstate-variables-66"></a><code>orig(x)</code> refers to the value of variable <code>x</code> upon
entry to a procedure (because the procedure body might modify the value
of <code>x</code>).  These variables appear only at <code>:::EXIT</code> program
points.  Typically, <code>orig()</code> variables do not appear in the trace,
but are automatically created by Daikon when it matches up
<code>:::ENTER</code><var>[nn]</var> and <code>:::EXIT</code> program points. 
See <a href="#orig-variable-example">orig variable example</a>.

     <p>This variable prints as <code>orig</code> when using Daikon output format
(see <a href="#Invariant-syntax">Invariant syntax</a>), but may print differently in other formats
(such as <code>\old</code>).

     <li><a name="index-g_t_0040code_007bpost_0028_0029_007d-variable-_0028post_002dstate-value_0029-67"></a><a name="index-post_002dstate-variables-68"></a><code>post(x)</code> refers to the value of variable <code>x</code> upon exit from a
procedure.  Such a value is usually written simply <code>x</code>; the
<code>post</code> prefix is needed only within an <code>orig</code> expression, when
the post-state value needs to be referenced.  Just as <code>orig</code> may
be used only in a post-state context and specifies an expression to be
evaluated in the pre-state, <code>post</code> may be may be used only in a
pre-state context and specifies an expression to be evaluated in the
post-state.  See <a href="#orig-variable-example">orig variable example</a>.

     <!-- Old version.  Do any of the front ends still do this? -->
     <!-- @item -->
     <!-- @cindex @code{::} variable (C global) -->
     <!-- @code{::x} is the global variable @code{x}. -->
     <li><a name="index-g_t_0040code_007b_002f_007d-variable-_0028C-global-or-file_002dstatic_0029-69"></a><code>/globalVar</code> C global variable.  In C output, global variables with
external linkage are
prefixed with a slash.  For instance, global <code>/x</code> is distinct from
procedure parameter <code>/x</code>.  (In Java programs, variables can be
distinguished by prefixing them with <code>this.</code> or, for class-static
variables, a class name.)

     <li><code>myfile_c/staticVar</code> C static variable.  In C output, file-static
variables have names of the form &lsquo;<samp><var>filename</var><span class="samp">/</span><var>varname</var></samp>&rsquo;,
where periods (&lsquo;<samp><span class="samp">.</span></samp>&rsquo;) in the filename are converted into underscores
(&lsquo;<samp><span class="samp">_</span></samp>&rsquo;).  For example, &lsquo;<samp><span class="samp">Global_c/x</span></samp>&rsquo; is the name for a
file-static variable <code>x</code> declared in the file <samp><span class="file">Global.c</span></samp>).

     <li><a name="index-g_t_0040code_007b_0040_0040_007d-variable-_0028C-function_002dscoped-static_0029-70"></a><code>myfile_c@funcname/funcStaticVar</code> C function-scoped static variable. 
In C output, for static variables which are
declared within functions, an at-sign &lsquo;<samp><span class="samp">@</span></samp>&rsquo; separates the filename
and the function name and then a slash separates the function name and
variable name (e.g., &lsquo;<samp><span class="samp">Global_c@main/funcStaticVar</span></samp>&rsquo; for a static
variable <code>funcStaticVar</code> declared within the function <code>main</code>
in the file <samp><span class="file">Global.c</span></samp>).

   </ul>

   <p><a name="index-local-variables-71"></a><a name="index-variables_002c-local-72"></a><a name="index-temporary-_0028local_0029-variables-73"></a><a name="index-variables_002c-temporary-_0028local_0029-74"></a>Daikon's current front ends do not produce output for local variables,
only for variables visible from outside a procedure.  (Also see the
<samp><span class="option">--std-visibility</span></samp> option to Chicory, <a href="#Chicory-options">Chicory options</a>.) 
More generally, Daikon's front ends produce output at procedure exit and
entry, not within the procedure.  Thus,
Daikon's output forms a specification from the view of a client of a
procedure.  If you wish to compute invariants over local variables, you
can extend one of Daikon's front ends (or request us to do so). 
An alternative that permits computing invariants at arbitrary locations
is to call a dummy procedure, passing all the variables of interest. 
The dummy procedure's pre- and post-conditions will be identical and will
represent the invariants at the point of call.

   <p>The array introduction operator <code>[]</code> can made Daikon variables look
slightly odd, but it is intended to assist in interpreting the variables
and to provide an indication that the variable name cannot be
substituted directly in a program as an expression.

   <p>Each array introduction operator <code>[]</code> increases the dimensionality
of the variable, and each array indexing operation <code>[i]</code> decreases
it.  Since all Daikon variables are scalars or one-dimensional arrays,
these operators must be matched up, or have at most one more <code>[]</code>
than <code>[i]</code>.  (There is one exception:  according to a strict
interpretation of the rules, the C/Java expression <code>a[i]</code> would
turn into the Daikon variable <code>a[][i]</code>, since it does not change
the dimensionality of any expression it appears in.  However, that would
be even more confusing, and the point is to avoid confusion, so by
convention Daikon front ends use just <code>a[i]</code>, not <code>a[][i]</code>. 
Strictly speaking, none of the <code>[]</code> operators is necessary, since a
user with a perfect knowledge of the type of each program variable and
field could use that to infer the type of any Daikon expression.)

<ul class="menu">
<li><a accesskey="1" href="#orig-variable-example">orig variable example</a>
</ul>

<div class="node">
<p><hr>
<a name="orig-variable-example"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variable-names">Variable names</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variable-names">Variable names</a>

</div>

<h4 class="subsection">5.3.1 orig variable example</h4>

<p><a name="index-g_t_0040code_007borig_0028_0029_007d-variable-_0028pre_002dstate-value_0029-75"></a>
This section gives an example of use of <code>orig()</code> and <code>post()</code>
variables and arrays.

   <p>Suppose you have initially that (in Java syntax)
<pre class="example">     int i = 0;
     int[] a = new int[] { 22, 23 };
     int[] b = new int[] { 46, 47 };
</pre>
   <p class="noindent">and then you run the following:
<pre class="example">     // pre-state values at this point
     a[0] = 24;
     a[1] = 25
     a = b;
     a[0] = 48;
     a[1] = 49;
     i = 1;
     // post-state values at this point
</pre>
   <p>The values of various variables are as follows:

     <dl>
<dt><code>orig(a[i]) = 22</code><dd>The value of <code>a[i]</code> in the pre-state: {22, 23}[0]

     <br><dt><code>orig(a[])[orig(i)] = 22</code><dd>This is the same as orig(a[i]):   {22, 23}[0].

     <br><dt><code>orig(a[])[i] = 23</code><dd>The value of <code>a[]</code> in the pre-state (which is an array object, not
a reference), indexed by the post-state value of i:  {22, 23}[1]

     <br><dt><code>orig(a)[orig(i)] = 24</code><dd><code>orig(a)</code> is the original value of the reference <code>a</code>, not
<code>a</code>'s original elements: {24, 25}[0]

     <br><dt><code>orig(a)[i] = 25</code><dd>The original pointer value of a, indexed by the post-state value
of i:  {24, 25}[1]

     <br><dt><code>a[orig(i)] = 48</code><dd>In the post-state, <code>a</code> indexed by the original value of
<code>i</code>: {48, 49}[0]

     <br><dt><code>a[i] = 49</code><dd>The value of <code>a[i]</code> in the post-state.

     <br><dt><code>b = orig(b) = </code><var>some hashcode</var><dd>The identity of the array <code>b</code> has not changed.

     <br><dt><code>b[] = [48, 49]</code><dt><code>orig(b[]) = [46, 47]</code><dd>For an array <code>b</code>, &lsquo;<samp><span class="samp">b=orig(b)</span></samp>&rsquo; does not imply &lsquo;<samp><span class="samp">b[]=orig(b[])</span></samp>&rsquo;.

     <br><dt><code>orig(a[post(i)]) = 23</code><dd>The pre-state value of <code>a[1]</code> (because the post-state value of
<code>i</code> is 1):  {22, 23}[1]

   </dl>

<div class="node">
<p><hr>
<a name="Interpreting-output"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Invariant-list">Invariant list</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variable-names">Variable names</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-output">Daikon output</a>

</div>

<h3 class="section">5.4 Interpreting Daikon output</h3>

<p><a name="index-g_t_0040samp_007bExiting_007d_002c-in-Daikon-output-76"></a>
If nothing gets printed before the &lsquo;<samp><span class="samp">Exiting</span></samp>&rsquo; line, then Daikon
found no invariants.  You can get a little bit more information by using
the <samp><span class="option">--output_num_samples</span></samp> flag to Daikon
(see <a href="#Options-to-control-Daikon-output">Options to control Daikon output</a>).

   <p>Daikon's output is predicated on the assumption that all expressions
that get evaluated are sensible.  For instance, if Daikon prints
&lsquo;<samp><span class="samp">a.b == 0</span></samp>&rsquo;, then that means that if &lsquo;<samp><span class="samp">a.b</span></samp>&rsquo; is sensible (that
is, &lsquo;<samp><span class="samp">a</span></samp>&rsquo; is non-null), then its value is zero.  If you would like
the assumptions to be printed explicitly, then set the
<samp><span class="option">daikon.Daikon.guardNulls</span></samp> configuration option (see <a href="#General-configuration-options">General configuration options</a>).

<ul class="menu">
<li><a accesskey="1" href="#Redundant-invariants">Redundant invariants</a>
<li><a accesskey="2" href="#Equal-variables">Equal variables</a>
<li><a accesskey="3" href="#Has-only-one-value-variables">Has only one value variables</a>
</ul>

<div class="node">
<p><hr>
<a name="Redundant-invariants"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Equal-variables">Equal variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Interpreting-output">Interpreting output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interpreting-output">Interpreting output</a>

</div>

<h4 class="subsection">5.4.1 Redundant</h4>

<p>By default, Daikon does not display redundant invariants &mdash; those
that are implied by other invariants in the output &mdash; because such
results would merely clutter the output without adding any valuable
information.  For instance, if Daikon reports &lsquo;<samp><span class="samp">x==y</span></samp>&rsquo;, then it never
also reports &lsquo;<samp><span class="samp">x-1==y-1</span></samp>&rsquo;.  You can control this behavior to some extent by
disabling invariant filters; See <a href="#Invariant-filters">Invariant filters</a>. 
(You can also print all invariants, even
redundant ones, by saving the invariants to a <samp><span class="file">.inv</span></samp> file and
then using the PrintInvariants (see <a href="#Printing-invariants">Printing invariants</a>) or Diff
(see <a href="#Invariant-Diff">Invariant Diff</a>) programs to print the results.)

<div class="node">
<p><hr>
<a name="Equal-variables"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Has-only-one-value-variables">Has only one value variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Redundant-invariants">Redundant invariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interpreting-output">Interpreting output</a>

</div>

<h4 class="subsection">5.4.2 Equal variables</h4>

<p>When two or more variables are always equal, any invariant that
is true over one variable is true over all of the variables.  Daikon
prints invariants only over one variable (the leader) from the equal
set.

   <p>An equality invariant is printed for each non-leader in the equal set. 
For example, if the variables <code>a</code>, <code>b</code>, and <code>c</code> are all
equal and <code>a</code> is chosen as the leader, the printed invariants will
include any invariants over <code>a</code> and the equality invariants &lsquo;<samp><span class="samp">a=b</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">a=c</span></samp>&rsquo;.

   <p>You can control which variables are in an equality set; <a href="developer.html#Variable-comparability">Variable comparability</a>.

<div class="node">
<p><hr>
<a name="Has-only-one-value-variables"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Equal-variables">Equal variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Interpreting-output">Interpreting output</a>

</div>

<h4 class="subsection">5.4.3 Has only one value variables</h4>

<p><a name="index-has-only-one-value_002c-in-invariant-output-77"></a><a name="index-hashcode-type_002c-for-variables-78"></a>
The output &lsquo;<samp><var>var</var><span class="samp"> has only one value</span></samp>&rsquo; in Daikon's output means
that every time that variable <var>var</var> was encountered, it had the same
value.  Daikon ordinarily reports the actual value, as in
&lsquo;<samp><var>var</var><span class="samp"> == 22</span></samp>&rsquo;.  Typically this means that the variable is a
hashcode or address &mdash; that is, its declared type is &lsquo;<samp><span class="samp">hashcode</span></samp>&rsquo;
(see <a href="developer.html#Variable-declarations">Variable declarations</a>).  For example, &lsquo;<samp><var>var</var><span class="samp"> ==
0x38E8A</span></samp>&rsquo; is not very illuminating, but it is still interesting that
<var>var</var> was never rebound to a different object.

   <p>Note that &lsquo;<samp><var>var</var><span class="samp"> has only one value</span></samp>&rsquo; is different from
saying that <var>var</var> is unmodified.

   <p>A variable might have only one value but <em>not</em> be reported as unmodified
because the variable is not a parameter to a procedure &mdash; for instance,
if a routine always returns the same object, or in a class invariant.  A
variable can be reported as unmodified but <em>not</em> have only one value
because the variable is never modified during any execution of the
procedure, but has different values on different invocations of the
procedure.

<div class="node">
<p><hr>
<a name="Invariant-list"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Invariant-filters">Invariant filters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Interpreting-output">Interpreting output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-output">Daikon output</a>

</div>

<h3 class="section">5.5 Invariant list</h3>

<p><a name="index-invariant-list-79"></a><a name="index-invariants_002c-list-of-all-80"></a>The following is a list of all of the invariants that Daikon detects. 
Each invariant has a configuration enable switch.  By default most invariants
are enabled.  Any that are not enabled by default are indicated below. 
Some invariants also have additional configuration switches that control
their behavior.  These are indicated below as well. 
See <a href="#Options-to-enable_002fdisable-specific-invariants">Options to enable/disable specific invariants</a>.

     <dl>
<!-- BEGIN AUTO-GENERATED INVARIANTS LISTING -->
<!-- Automatically generated by class daikon.config.InvariantDoclet -->

     <dt>AndJoiner<dd>This is a special invariant used internally by Daikon to represent
an antecedent invariant in an implication where that antecedent
consists of two invariants anded together.

     <br><dt>CommonFloatSequence<dd>Represents sequences of double values that contain a common subset. 
Prints as &lsquo;<samp><span class="samp">{e1, e2, e3, ...} subset of x[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.CommonFloatSequence.enabled</span></samp>&rsquo;.

     <p>See also the following configuration option:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.CommonFloatSequence.hashcode_seqs</span></samp>&rsquo;
    </ul>

     <br><dt>CommonSequence<dd>Represents sequences of long values that contain a common subset. 
Prints as &lsquo;<samp><span class="samp">{e1, e2, e3, ...} subset of x[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.CommonSequence.enabled</span></samp>&rsquo;.

     <p>See also the following configuration option:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.CommonSequence.hashcode_seqs</span></samp>&rsquo;
    </ul>

     <br><dt>CommonStringSequence<dd>Represents string sequences that contain a common subset.  Prints as
"{s1, s2, s3, ...} subset of x[]".

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.stringsequence.CommonStringSequence.enabled</span></samp>&rsquo;.

     <br><dt>CompleteOneOfScalar<dd>Tracks every unique value and how many times it occurs.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.CompleteOneOfScalar.enabled</span></samp>&rsquo;.

     <br><dt>CompleteOneOfString<dd>Tracks every unique value and how many times it occurs.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.string.CompleteOneOfString.enabled</span></samp>&rsquo;.

     <br><dt>DummyInvariant<dd>This is a special invariant used internally by Daikon to represent
invariants whose meaning Daikon doesn't understand. The only
operation that can be performed on a DummyInvariant is to print it. 
For instance, dummy invariants can be created to correspond to
splitting conditions, when no other invariant in Daikon's grammar
is equivalent to the condition.

     <p>To use dummy invariants for splitting conditions, the configuration
option &lsquo;<samp><span class="samp">daikon.PptTopLevel.dummy_invariant_level</span></samp>&rsquo; must be set,
and formatting information must be supplied in the splitter info file.

     <br><dt>EltLowerBound<dd>Represents the invariant that each element of a sequence of long
values is greater than or equal to a constant. Prints as
&lsquo;<samp><span class="samp">x[] elements &gt;= c</span></samp>&rsquo;.

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltLowerBound.minimal_interesting</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltLowerBound.maximal_interesting</span></samp>&rsquo;
    </ul>

     <br><dt>EltLowerBoundFloat<dd>Represents the invariant that each element of a sequence of double
values is greater than or equal to a constant. Prints as
&lsquo;<samp><span class="samp">x[] elements &gt;= c</span></samp>&rsquo;.

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltLowerBoundFloat.minimal_interesting</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltLowerBoundFloat.maximal_interesting</span></samp>&rsquo;
    </ul>

     <br><dt>EltNonZero<dd>Represents the invariant "x != 0" where x represents all of the elements
of a sequence of long.  Prints as &lsquo;<samp><span class="samp">x[] elements != 0</span></samp>&rsquo;.

     <br><dt>EltNonZeroFloat<dd>Represents the invariant "x != 0" where x represents all of the elements
of a sequence of double.  Prints as &lsquo;<samp><span class="samp">x[] elements != 0</span></samp>&rsquo;.

     <br><dt>EltOneOf<dd>Represents sequences of long values where the elements of the sequence
take on only a few distinct values.  Prints as either
&lsquo;<samp><span class="samp">x[] == c</span></samp>&rsquo; (when there is only one value), or as
&lsquo;<samp><span class="samp">x[] one of {c1, c2, c3}</span></samp>&rsquo; (when there are multiple values).

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltOneOf.size</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltOneOf.omit_hashcode_values_Simplify</span></samp>&rsquo;
    </ul>

     <br><dt>EltOneOfFloat<dd>Represents sequences of double values where the elements of the sequence
take on only a few distinct values.  Prints as either
&lsquo;<samp><span class="samp">x[] == c</span></samp>&rsquo; (when there is only one value), or as
&lsquo;<samp><span class="samp">x[] one of {c1, c2, c3}</span></samp>&rsquo; (when there are multiple values).

     <p>See also the following configuration option:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltOneOfFloat.size</span></samp>&rsquo;
    </ul>

     <br><dt>EltOneOfString<dd>Represents sequences of String values where the elements of the sequence
take on only a few distinct values.  Prints as either
&lsquo;<samp><span class="samp">x[] == c</span></samp>&rsquo; (when there is only one value), or as
&lsquo;<samp><span class="samp">x[] one of {c1, c2, c3}</span></samp>&rsquo; (when there are multiple values).

     <p>See also the following configuration option:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.stringsequence.EltOneOfString.size</span></samp>&rsquo;
    </ul>

     <br><dt>EltRangeFloat.EqualMinusOne<dd>Internal invariant representing double scalars that are equal
to minus one.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing

     <br><dt>EltRangeFloat.EqualOne<dd>Internal invariant representing double scalars that are equal
to one.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing

     <br><dt>EltRangeFloat.EqualZero<dd>Internal invariant representing double scalars that are equal
to zero.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing.

     <br><dt>EltRangeFloat.GreaterEqual64<dd>Internal invariant representing double scalars that are greater
than or equal to 64.  Used for non-instantiating suppressions.  Will never
print since Bound accomplishes the same thing

     <br><dt>EltRangeFloat.GreaterEqualZero<dd>Internal invariant representing double scalars that are greater
than or equal to 0.  Used for non-instantiating suppressions.  Will never
print since Bound accomplishes the same thing

     <br><dt>EltRangeInt.BooleanVal<dd>Internal invariant representing longs whose values are always 0
or 1.  Used for non-instantiating suppressions.  Will never print
since OneOf accomplishes the same thing.

     <br><dt>EltRangeInt.Bound0_63<dd>Internal invariant representing longs whose values are between 0
and 63.  Used for non-instantiating suppressions.  Will never print
since Bound accomplishes the same thing.

     <br><dt>EltRangeInt.EqualMinusOne<dd>Internal invariant representing long scalars that are equal
to minus one.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing

     <br><dt>EltRangeInt.EqualOne<dd>Internal invariant representing long scalars that are equal
to one.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing

     <br><dt>EltRangeInt.EqualZero<dd>Internal invariant representing long scalars that are equal
to zero.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing.

     <br><dt>EltRangeInt.Even<dd>Invariant representing longs whose values are always even. 
Used for non-instantiating suppressions.  Since this is not
covered by the Bound or OneOf invariants it is printed.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltRangeInt.Even.enabled</span></samp>&rsquo;.

     <br><dt>EltRangeInt.GreaterEqual64<dd>Internal invariant representing long scalars that are greater
than or equal to 64.  Used for non-instantiating suppressions.  Will never
print since Bound accomplishes the same thing

     <br><dt>EltRangeInt.GreaterEqualZero<dd>Internal invariant representing long scalars that are greater
than or equal to 0.  Used for non-instantiating suppressions.  Will never
print since Bound accomplishes the same thing

     <br><dt>EltRangeInt.PowerOfTwo<dd>Invariant representing longs whose values are always a power of 2
(exactly one bit is set).  Used for non-instantiating
suppressions.  Since this is not covered by the Bound or OneOf
invariants it is printed.

     <br><dt>EltUpperBound<dd>Represents the invariant that each element of a sequence of long
values is less than or equal to a constant. Prints as
&lsquo;<samp><span class="samp">x[] elements &lt;= c</span></samp>&rsquo;.

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltUpperBound.minimal_interesting</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltUpperBound.maximal_interesting</span></samp>&rsquo;
    </ul>

     <br><dt>EltUpperBoundFloat<dd>Represents the invariant that each element of a sequence of double
values is less than or equal to a constant. Prints as
&lsquo;<samp><span class="samp">x[] elements &lt;= c</span></samp>&rsquo;.

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltUpperBoundFloat.minimal_interesting</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.EltUpperBoundFloat.maximal_interesting</span></samp>&rsquo;
    </ul>

     <br><dt>EltwiseFloatEqual<dd>Represents equality between adjacent elements (x[i], x[i+1]) of a
double sequence.  Prints as &lsquo;<samp><span class="samp">x[] elements are equal</span></samp>&rsquo;.

     <br><dt>EltwiseFloatGreaterEqual<dd>Represents the invariant "&gt;=" between adjacent elements
(x[i], x[i+1]) of a double sequence.  Prints as
&lsquo;<samp><span class="samp">x[] sorted by "&gt;="</span></samp>&rsquo;.

     <br><dt>EltwiseFloatGreaterThan<dd>Represents the invariant "&gt;" between adjacent elements
(x[i], x[i+1]) of a double sequence.  Prints as
&lsquo;<samp><span class="samp">x[] sorted by "&gt;"</span></samp>&rsquo;.

     <br><dt>EltwiseFloatLessEqual<dd>Represents the invariant "&lt;=" between adjacent elements
(x[i], x[i+1]) of a double sequence.  Prints as
&lsquo;<samp><span class="samp">x[] sorted by "&lt;="</span></samp>&rsquo;.

     <br><dt>EltwiseFloatLessThan<dd>Represents the invariant "&lt;" between adjacent elements
(x[i], x[i+1]) of a double sequence.  Prints as
&lsquo;<samp><span class="samp">x[] sorted by "&lt;"</span></samp>&rsquo;.

     <br><dt>EltwiseIntEqual<dd>Represents equality between adjacent elements (x[i], x[i+1]) of a
long sequence.  Prints as &lsquo;<samp><span class="samp">x[] elements are equal</span></samp>&rsquo;.

     <br><dt>EltwiseIntGreaterEqual<dd>Represents the invariant "&gt;=" between adjacent elements
(x[i], x[i+1]) of a long sequence.  Prints as
&lsquo;<samp><span class="samp">x[] sorted by "&gt;="</span></samp>&rsquo;.

     <br><dt>EltwiseIntGreaterThan<dd>Represents the invariant "&gt;" between adjacent elements
(x[i], x[i+1]) of a long sequence.  Prints as
&lsquo;<samp><span class="samp">x[] sorted by "&gt;"</span></samp>&rsquo;.

     <br><dt>EltwiseIntLessEqual<dd>Represents the invariant "&lt;=" between adjacent elements
(x[i], x[i+1]) of a long sequence.  Prints as
&lsquo;<samp><span class="samp">x[] sorted by "&lt;="</span></samp>&rsquo;.

     <br><dt>EltwiseIntLessThan<dd>Represents the invariant "&lt;" between adjacent elements
(x[i], x[i+1]) of a long sequence.  Prints as
&lsquo;<samp><span class="samp">x[] sorted by "&lt;"</span></samp>&rsquo;.

     <br><dt>Equality<dd>Keeps track of sets of variables that are equal.  Other invariants are
instantiated for only one member of the Equality set, the leader.  If
variables &lsquo;<samp><span class="samp">x</span></samp>&rsquo;, &lsquo;<samp><span class="samp">y</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">z</span></samp>&rsquo; are members
of the Equality set and &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is chosen as the leader, then
the Equality will internally convert into binary comparison invariants
that print as &lsquo;<samp><span class="samp">x == y</span></samp>&rsquo; and &lsquo;<samp><span class="samp">x == z</span></samp>&rsquo;.

     <br><dt>FloatEqual<dd>Represents an invariant of "==" between two
double scalars.

     <br><dt>FloatGreaterEqual<dd>Represents an invariant of "&gt;=" between two
double scalars.

     <br><dt>FloatGreaterThan<dd>Represents an invariant of "&gt;" between two
double scalars.

     <br><dt>FloatLessEqual<dd>Represents an invariant of "&lt;=" between two
double scalars.

     <br><dt>FloatLessThan<dd>Represents an invariant of "&lt;" between two
double scalars.

     <br><dt>FloatNonEqual<dd>Represents an invariant of "!=" between two
double scalars.

     <br><dt>FunctionBinary.BitwiseAndLong_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = BitwiseAnd (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinary.BitwiseOrLong_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = BitwiseOr (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinary.BitwiseXorLong_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = BitwiseXor (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinary.DivisionLong_{xyz, xzy, yxz, yzx, zxy, zyx}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Division (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is non-symmetric, all six permutations of the variables are checked.

     <br><dt>FunctionBinary.GcdLong_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Gcd (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinary.LogicalAndLong_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = LogicalAnd (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinary.LogicalOrLong_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = LogicalOr (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinary.LogicalXorLong_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = LogicalXor (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinary.LshiftLong_{xyz, xzy, yxz, yzx, zxy, zyx}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Lshift (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is non-symmetric, all six permutations of the variables are checked.

     <br><dt>FunctionBinary.MaximumLong_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Maximum (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinary.MinimumLong_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Minimum (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinary.ModLong_{xyz, xzy, yxz, yzx, zxy, zyx}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Mod (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is non-symmetric, all six permutations of the variables are checked.

     <br><dt>FunctionBinary.MultiplyLong_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Multiply (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinary.PowerLong_{xyz, xzy, yxz, yzx, zxy, zyx}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Power (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is non-symmetric, all six permutations of the variables are checked.

     <br><dt>FunctionBinary.RshiftSignedLong_{xyz, xzy, yxz, yzx, zxy, zyx}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = RshiftSigned (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is non-symmetric, all six permutations of the variables are checked.

     <br><dt>FunctionBinary.RshiftUnsignedLong_{xyz, xzy, yxz, yzx, zxy, zyx}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = RshiftUnsigned (y, z)</span></samp>&rsquo;
over three long scalars. 
Since the function is non-symmetric, all six permutations of the variables are checked.

     <br><dt>FunctionBinaryFloat.DivisionDouble_{xyz, xzy, yxz, yzx, zxy, zyx}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Division (y, z)</span></samp>&rsquo;
over three double scalars. 
Since the function is non-symmetric, all six permutations of the variables are checked.

     <br><dt>FunctionBinaryFloat.MaximumDouble_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Maximum (y, z)</span></samp>&rsquo;
over three double scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinaryFloat.MinimumDouble_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Minimum (y, z)</span></samp>&rsquo;
over three double scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>FunctionBinaryFloat.MultiplyDouble_{xyz, yxz, zxy}<dd>Represents the invariant &lsquo;<samp><span class="samp">x = Multiply (y, z)</span></samp>&rsquo;
over three double scalars. 
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.

     <br><dt>GuardingImplication<dd>This is a special implication invariant that guards any invariants that
 are over variables that are sometimes missing.  For example, if the
 invariant &lsquo;<samp><span class="samp">a.x = 0</span></samp>&rsquo; is true, the guarded implication is
 &lsquo;<samp><span class="samp">a != null =&gt; a.x = 0</span></samp>&rsquo;.

     <br><dt>Implication<dd>The Implication invariant class is used internally within Daikon to
handle invariants that are only true when certain other conditions are
also true (splitting).

     <br><dt>IntEqual<dd>Represents an invariant of "==" between two
long scalars.

     <br><dt>IntGreaterEqual<dd>Represents an invariant of "&gt;=" between two
long scalars.

     <br><dt>IntGreaterThan<dd>Represents an invariant of "&gt;" between two
long scalars.

     <br><dt>IntLessEqual<dd>Represents an invariant of "&lt;=" between two
long scalars.

     <br><dt>IntLessThan<dd>Represents an invariant of "&lt;" between two
long scalars.

     <br><dt>IntNonEqual<dd>Represents an invariant of "!=" between two
long scalars.

     <p>See also the following configuration option:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.binary.twoScalar.IntNonEqual.integral_only</span></samp>&rsquo;
    </ul>

     <br><dt>IsPointer<dd>IsPointer is an invariant that heuristically determines whether
an integer represents a pointer (a 32-bit memory address). 
Since both a 32-bit integer and an address have the same representation,
sometimes a a pointer can be mistaken for an integer. When this happens,
several scalar invariants are computed for integer variables. Most of them
would not make any sense for pointers. Determining whether a 32-bit variable
is a pointer can thus spare the computation of many irrelevant invariants.

     <p>The basic approach is to discard the invariant if any values that are
not valid pointers are encountered.  By default values between -100,000
and 100,00 (except 0) are considered to be invalid pointers.  This
approach has been experimentally confirmed on Windows x86 executables.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.IsPointer.enabled</span></samp>&rsquo;.

     <br><dt>LinearBinary<dd>Represents a Linear invariant between two long
scalars &lsquo;<samp><span class="samp">x</span></samp>&rsquo; and &lsquo;<samp><span class="samp">y</span></samp>&rsquo;, of the form
&lsquo;<samp><span class="samp">ax + by + c = 0</span></samp>&rsquo;. 
The constants &lsquo;<samp><span class="samp">a</span></samp>&rsquo;, &lsquo;<samp><span class="samp">b</span></samp>&rsquo; and &lsquo;<samp><span class="samp">c</span></samp>&rsquo; are
mutually relatively prime,
and the constant &lsquo;<samp><span class="samp">a</span></samp>&rsquo; is always positive.

     <br><dt>LinearBinaryFloat<dd>Represents a Linear invariant between two double
scalars &lsquo;<samp><span class="samp">x</span></samp>&rsquo; and &lsquo;<samp><span class="samp">y</span></samp>&rsquo;, of the form
&lsquo;<samp><span class="samp">ax + by + c = 0</span></samp>&rsquo;. 
The constants &lsquo;<samp><span class="samp">a</span></samp>&rsquo;, &lsquo;<samp><span class="samp">b</span></samp>&rsquo; and &lsquo;<samp><span class="samp">c</span></samp>&rsquo; are
mutually relatively prime,
and the constant &lsquo;<samp><span class="samp">a</span></samp>&rsquo; is always positive.

     <br><dt>LinearTernary<dd>Represents a Linear invariant over three long scalars &lsquo;<samp><span class="samp">x</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">y</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">z</span></samp>&rsquo;, of the form
&lsquo;<samp><span class="samp">ax + by + cz + d = 0</span></samp>&rsquo;. 
The constants &lsquo;<samp><span class="samp">a</span></samp>&rsquo;, &lsquo;<samp><span class="samp">b</span></samp>&rsquo;, &lsquo;<samp><span class="samp">c</span></samp>&rsquo;, and
&lsquo;<samp><span class="samp">d</span></samp>&rsquo; are mutually relatively prime, and the constant
&lsquo;<samp><span class="samp">a</span></samp>&rsquo; is always positive.

     <br><dt>LinearTernaryFloat<dd>Represents a Linear invariant over three double scalars &lsquo;<samp><span class="samp">x</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">y</span></samp>&rsquo;, and &lsquo;<samp><span class="samp">z</span></samp>&rsquo;, of the form
&lsquo;<samp><span class="samp">ax + by + cz + d = 0</span></samp>&rsquo;. 
The constants &lsquo;<samp><span class="samp">a</span></samp>&rsquo;, &lsquo;<samp><span class="samp">b</span></samp>&rsquo;, &lsquo;<samp><span class="samp">c</span></samp>&rsquo;, and
&lsquo;<samp><span class="samp">d</span></samp>&rsquo; are mutually relatively prime, and the constant
&lsquo;<samp><span class="samp">a</span></samp>&rsquo; is always positive.

     <br><dt>LowerBound<dd>Represents the invariant &lsquo;<samp><span class="samp">x &gt;= c</span></samp>&rsquo;, where &lsquo;<samp><span class="samp">c</span></samp>&rsquo;
is a constant and &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a long scalar.

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.LowerBound.minimal_interesting</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.LowerBound.maximal_interesting</span></samp>&rsquo;
    </ul>

     <br><dt>LowerBoundFloat<dd>Represents the invariant &lsquo;<samp><span class="samp">x &gt;= c</span></samp>&rsquo;, where &lsquo;<samp><span class="samp">c</span></samp>&rsquo;
is a constant and &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a double scalar.

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.LowerBoundFloat.minimal_interesting</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.LowerBoundFloat.maximal_interesting</span></samp>&rsquo;
    </ul>

     <br><dt>Member<dd>Represents long scalars that are always members of a sequence of long
values. 
Prints as &lsquo;<samp><span class="samp">x in y[]</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a long scalar
and &lsquo;<samp><span class="samp">y[]</span></samp>&rsquo; is a sequence of long.

     <br><dt>MemberFloat<dd>Represents double scalars that are always members of a sequence of double
values. 
Prints as &lsquo;<samp><span class="samp">x in y[]</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a double scalar
and &lsquo;<samp><span class="samp">y[]</span></samp>&rsquo; is a sequence of double.

     <br><dt>MemberString<dd>Represents String scalars that are always members of a sequence of String
values. 
Prints as &lsquo;<samp><span class="samp">x in y[]</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a String scalar
and &lsquo;<samp><span class="samp">y[]</span></samp>&rsquo; is a sequence of String.

     <br><dt>Modulus<dd>Represents the invariant &lsquo;<samp><span class="samp">x == r (mod m)</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo;
is a long scalar variable, &lsquo;<samp><span class="samp">r</span></samp>&rsquo; is the (constant) remainder,
and &lsquo;<samp><span class="samp">m</span></samp>&rsquo; is the (constant) modulus.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.Modulus.enabled</span></samp>&rsquo;.

     <br><dt>NoDuplicates<dd>Represents sequences of long that contain no duplicate elements. 
Prints as &lsquo;<samp><span class="samp">x[] contains no duplicates</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.NoDuplicates.enabled</span></samp>&rsquo;.

     <br><dt>NoDuplicatesFloat<dd>Represents sequences of double that contain no duplicate elements. 
Prints as &lsquo;<samp><span class="samp">x[] contains no duplicates</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.NoDuplicatesFloat.enabled</span></samp>&rsquo;.

     <br><dt>NonModulus<dd>Represents long scalars that are never equal to <code>r (mod m)</code>
where all other numbers in the same range (i.e., all the values that
<code>x</code> doesn't take from <code>min(x)</code> to
<code>max(x)</code>) are equal to <code>r (mod m)</code>. 
Prints as &lsquo;<samp><span class="samp">x != r (mod m)</span></samp>&rsquo;, where &lsquo;<samp><span class="samp">r</span></samp>&rsquo;
is the remainder and &lsquo;<samp><span class="samp">m</span></samp>&rsquo; is the modulus.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.NonModulus.enabled</span></samp>&rsquo;.

     <br><dt>NonZero<dd>Represents long scalars that are non-zero.  Prints as &lsquo;<samp><span class="samp">x != 0</span></samp>&rsquo;,
or as &lsquo;<samp><span class="samp">x != null</span></samp>&rsquo; for pointer types.

     <br><dt>NonZeroFloat<dd>Represents double scalars that are non-zero.  Prints as &lsquo;<samp><span class="samp">x != 0</span></samp>&rsquo;.

     <br><dt>NumericFloat.Divides<dd>Represents the divides without remainder invariant between
two double scalars.  Prints as &lsquo;<samp><span class="samp">x % y == 0</span></samp>&rsquo;.

     <br><dt>NumericFloat.Square<dd>Represents the square invariant between
two double scalars.  Prints as &lsquo;<samp><span class="samp">x = y**2</span></samp>&rsquo;.

     <br><dt>NumericFloat.ZeroTrack<dd>Represents the zero tracks invariant between
two double scalars; that is, when &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is zero,
&lsquo;<samp><span class="samp">y</span></samp>&rsquo; is also zero. 
Prints as &lsquo;<samp><span class="samp">x = 0 ==&gt; y = 0</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoScalar.NumericFloat.ZeroTrack.enabled</span></samp>&rsquo;.

     <br><dt>NumericInt.BitwiseAndZero<dd>Represents the BitwiseAnd == 0 invariant between
two long scalars; that is, &lsquo;<samp><span class="samp">x</span></samp>&rsquo; and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; have no
bits in common.  Prints as &lsquo;<samp><span class="samp">x &amp; y == 0</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoScalar.NumericInt.BitwiseAndZero.enabled</span></samp>&rsquo;.

     <br><dt>NumericInt.BitwiseComplement<dd>Represents the bitwise complement invariant between
two long scalars.  Prints as &lsquo;<samp><span class="samp">x = ~y</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoScalar.NumericInt.BitwiseComplement.enabled</span></samp>&rsquo;.

     <br><dt>NumericInt.BitwiseSubset<dd>Represents the bitwise subset invariant between
two long scalars; that is, the bits of &lsquo;<samp><span class="samp">y</span></samp>&rsquo; are a subset of the
bits of &lsquo;<samp><span class="samp">x</span></samp>&rsquo;.  Prints as &lsquo;<samp><span class="samp">x = y | x</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoScalar.NumericInt.BitwiseSubset.enabled</span></samp>&rsquo;.

     <br><dt>NumericInt.Divides<dd>Represents the divides without remainder invariant between
two long scalars.  Prints as &lsquo;<samp><span class="samp">x % y == 0</span></samp>&rsquo;.

     <br><dt>NumericInt.ShiftZero<dd>Represents the ShiftZero invariant between
two long scalars;
that is, &lsquo;<samp><span class="samp">x</span></samp>&rsquo; right-shifted by &lsquo;<samp><span class="samp">y</span></samp>&rsquo;
is always zero.  Prints as &lsquo;<samp><span class="samp">x &gt;&gt; y = 0</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoScalar.NumericInt.ShiftZero.enabled</span></samp>&rsquo;.

     <br><dt>NumericInt.Square<dd>Represents the square invariant between
two long scalars.  Prints as &lsquo;<samp><span class="samp">x = y**2</span></samp>&rsquo;.

     <br><dt>NumericInt.ZeroTrack<dd>Represents the zero tracks invariant between
two long scalars; that is, when &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is zero,
&lsquo;<samp><span class="samp">y</span></samp>&rsquo; is also zero. 
Prints as &lsquo;<samp><span class="samp">x = 0 ==&gt; y = 0</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoScalar.NumericInt.ZeroTrack.enabled</span></samp>&rsquo;.

     <br><dt>OneOfFloat<dd>Represents double variables that take on only a few distinct
values. Prints as either
&lsquo;<samp><span class="samp">x == c</span></samp>&rsquo; (when there is only one value)
or as &lsquo;<samp><span class="samp">x one of {c1, c2, c3}</span></samp>&rsquo; (when there are multiple values).

     <p>See also the following configuration option:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.OneOfFloat.size</span></samp>&rsquo;
    </ul>

     <br><dt>OneOfFloatSequence<dd>Represents double[] variables that take on only a few distinct
values. Prints as either
&lsquo;<samp><span class="samp">x == c</span></samp>&rsquo; (when there is only one value)
or as &lsquo;<samp><span class="samp">x one of {c1, c2, c3}</span></samp>&rsquo; (when there are multiple values).

     <p>See also the following configuration option:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.OneOfFloatSequence.size</span></samp>&rsquo;
    </ul>

     <br><dt>OneOfScalar<dd>Represents long scalars that take on only a few distinct values.  Prints
as either &lsquo;<samp><span class="samp">x == c</span></samp>&rsquo; (when there is only one value),
&lsquo;<samp><span class="samp">x one of {c1, c2, c3}</span></samp>&rsquo; (when there are multiple values),
or &lsquo;<samp><span class="samp">x has only one value</span></samp>&rsquo; (when &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is
a hashcode (pointer) - this is because the numerical value of the
hashcode (pointer) is uninteresting).

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.OneOfScalar.size</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.OneOfScalar.omit_hashcode_values_Simplify</span></samp>&rsquo;
    </ul>

     <br><dt>OneOfSequence<dd>Represents long[] variables that take on only a few distinct
values. Prints as either
&lsquo;<samp><span class="samp">x == c</span></samp>&rsquo; (when there is only one value)
or as &lsquo;<samp><span class="samp">x one of {c1, c2, c3}</span></samp>&rsquo; (when there are multiple values).

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.OneOfSequence.size</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.OneOfSequence.omit_hashcode_values_Simplify</span></samp>&rsquo;
    </ul>

     <br><dt>OneOfString<dd>Represents String variables that take on only a few distinct
values. Prints as either
&lsquo;<samp><span class="samp">x == c</span></samp>&rsquo; (when there is only one value)
or as &lsquo;<samp><span class="samp">x one of {c1, c2, c3}</span></samp>&rsquo; (when there are multiple values).

     <p>See also the following configuration option:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.string.OneOfString.size</span></samp>&rsquo;
    </ul>

     <br><dt>OneOfStringSequence<dd>Represents String[] variables that take on only a few distinct
values. Prints as either
&lsquo;<samp><span class="samp">x == c</span></samp>&rsquo; (when there is only one value)
or as &lsquo;<samp><span class="samp">x one of {c1, c2, c3}</span></samp>&rsquo; (when there are multiple values).

     <p>See also the following configuration option:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.stringsequence.OneOfStringSequence.size</span></samp>&rsquo;
    </ul>

     <br><dt>PairwiseFloatEqual<dd>Represents an invariant between corresponding elements of two
sequences of double values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] == y[]</span></samp>&rsquo;.

     <br><dt>PairwiseFloatGreaterEqual<dd>Represents an invariant between corresponding elements of two
sequences of double values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &gt;= y[]</span></samp>&rsquo;.

     <br><dt>PairwiseFloatGreaterThan<dd>Represents an invariant between corresponding elements of two
sequences of double values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &gt; y[]</span></samp>&rsquo;.

     <br><dt>PairwiseFloatLessEqual<dd>Represents an invariant between corresponding elements of two
sequences of double values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &lt;= y[]</span></samp>&rsquo;.

     <br><dt>PairwiseFloatLessThan<dd>Represents an invariant between corresponding elements of two
sequences of double values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &lt; y[]</span></samp>&rsquo;.

     <br><dt>PairwiseIntEqual<dd>Represents an invariant between corresponding elements of two
sequences of long values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] == y[]</span></samp>&rsquo;.

     <br><dt>PairwiseIntGreaterEqual<dd>Represents an invariant between corresponding elements of two
sequences of long values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &gt;= y[]</span></samp>&rsquo;.

     <br><dt>PairwiseIntGreaterThan<dd>Represents an invariant between corresponding elements of two
sequences of long values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &gt; y[]</span></samp>&rsquo;.

     <br><dt>PairwiseIntLessEqual<dd>Represents an invariant between corresponding elements of two
sequences of long values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &lt;= y[]</span></samp>&rsquo;.

     <br><dt>PairwiseIntLessThan<dd>Represents an invariant between corresponding elements of two
sequences of long values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &lt; y[]</span></samp>&rsquo;.

     <br><dt>PairwiseLinearBinary<dd>Represents a linear invariant (i.e., &lsquo;<samp><span class="samp">y = ax + b</span></samp>&rsquo;) between
the corresponding elements of two sequences of long values. 
Each &lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair is examined. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo; and so forth. 
Prints as &lsquo;<samp><span class="samp">y[] = a * x[] + b</span></samp>&rsquo;.

     <br><dt>PairwiseLinearBinaryFloat<dd>Represents a linear invariant (i.e., &lsquo;<samp><span class="samp">y = ax + b</span></samp>&rsquo;) between
the corresponding elements of two sequences of double values. 
Each &lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair is examined. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo; and so forth. 
Prints as &lsquo;<samp><span class="samp">y[] = a * x[] + b</span></samp>&rsquo;.

     <br><dt>PairwiseNumericFloat.Divides<dd>Represents the divides without remainder invariant between
corresponding elements of two sequences of double.  Prints as &lsquo;<samp><span class="samp">x[] % y[] == 0</span></samp>&rsquo;.

     <br><dt>PairwiseNumericFloat.Square<dd>Represents the square invariant between
corresponding elements of two sequences of double.  Prints as &lsquo;<samp><span class="samp">x[] = y[]**2</span></samp>&rsquo;.

     <br><dt>PairwiseNumericFloat.ZeroTrack<dd>Represents the zero tracks invariant between
corresponding elements of two sequences of double; that is, when &lsquo;<samp><span class="samp">x[]</span></samp>&rsquo; is zero,
&lsquo;<samp><span class="samp">y[]</span></samp>&rsquo; is also zero. 
Prints as &lsquo;<samp><span class="samp">x[] = 0 ==&gt; y[] = 0</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.PairwiseNumericFloat.ZeroTrack.enabled</span></samp>&rsquo;.

     <br><dt>PairwiseNumericInt.BitwiseAndZero<dd>Represents the BitwiseAnd == 0 invariant between
corresponding elements of two sequences of long; that is, &lsquo;<samp><span class="samp">x[]</span></samp>&rsquo; and &lsquo;<samp><span class="samp">y[]</span></samp>&rsquo; have no
bits in common.  Prints as &lsquo;<samp><span class="samp">x[] &amp; y[] == 0</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseAndZero.enabled</span></samp>&rsquo;.

     <br><dt>PairwiseNumericInt.BitwiseComplement<dd>Represents the bitwise complement invariant between
corresponding elements of two sequences of long.  Prints as &lsquo;<samp><span class="samp">x[] = ~y[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseComplement.enabled</span></samp>&rsquo;.

     <br><dt>PairwiseNumericInt.BitwiseSubset<dd>Represents the bitwise subset invariant between
corresponding elements of two sequences of long; that is, the bits of &lsquo;<samp><span class="samp">y[]</span></samp>&rsquo; are a subset of the
bits of &lsquo;<samp><span class="samp">x[]</span></samp>&rsquo;.  Prints as &lsquo;<samp><span class="samp">x[] = y[] | x[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseSubset.enabled</span></samp>&rsquo;.

     <br><dt>PairwiseNumericInt.Divides<dd>Represents the divides without remainder invariant between
corresponding elements of two sequences of long.  Prints as &lsquo;<samp><span class="samp">x[] % y[] == 0</span></samp>&rsquo;.

     <br><dt>PairwiseNumericInt.ShiftZero<dd>Represents the ShiftZero invariant between
corresponding elements of two sequences of long;
that is, &lsquo;<samp><span class="samp">x[]</span></samp>&rsquo; right-shifted by &lsquo;<samp><span class="samp">y[]</span></samp>&rsquo;
is always zero.  Prints as &lsquo;<samp><span class="samp">x[] &gt;&gt; y[] = 0</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.PairwiseNumericInt.ShiftZero.enabled</span></samp>&rsquo;.

     <br><dt>PairwiseNumericInt.Square<dd>Represents the square invariant between
corresponding elements of two sequences of long.  Prints as &lsquo;<samp><span class="samp">x[] = y[]**2</span></samp>&rsquo;.

     <br><dt>PairwiseNumericInt.ZeroTrack<dd>Represents the zero tracks invariant between
corresponding elements of two sequences of long; that is, when &lsquo;<samp><span class="samp">x[]</span></samp>&rsquo; is zero,
&lsquo;<samp><span class="samp">y[]</span></samp>&rsquo; is also zero. 
Prints as &lsquo;<samp><span class="samp">x[] = 0 ==&gt; y[] = 0</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.PairwiseNumericInt.ZeroTrack.enabled</span></samp>&rsquo;.

     <br><dt>PairwiseString.SubString<dd>Represents the substring invariant between
corresponding elements of two sequences of String.  Prints as &lsquo;<samp><span class="samp">x[] is a substring of y[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.PairwiseString.SubString.enabled</span></samp>&rsquo;.

     <br><dt>PairwiseStringEqual<dd>Represents an invariant between corresponding elements of two
sequences of String values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] == y[]</span></samp>&rsquo;.

     <br><dt>PairwiseStringGreaterEqual<dd>Represents an invariant between corresponding elements of two
sequences of String values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &gt;= y[]</span></samp>&rsquo;.

     <br><dt>PairwiseStringGreaterThan<dd>Represents an invariant between corresponding elements of two
sequences of String values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &gt; y[]</span></samp>&rsquo;.

     <br><dt>PairwiseStringLessEqual<dd>Represents an invariant between corresponding elements of two
sequences of String values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &lt;= y[]</span></samp>&rsquo;.

     <br><dt>PairwiseStringLessThan<dd>Represents an invariant between corresponding elements of two
sequences of String values.  The length of the sequences must match for
the invariant to hold.  A comparison is made over each
&lsquo;<samp><span class="samp">(x[i], y[i])</span></samp>&rsquo; pair. 
Thus, &lsquo;<samp><span class="samp">x[0]</span></samp>&rsquo; is compared to &lsquo;<samp><span class="samp">y[0]</span></samp>&rsquo;,
&lsquo;<samp><span class="samp">x[1]</span></samp>&rsquo; to &lsquo;<samp><span class="samp">y[1]</span></samp>&rsquo;, and so forth. 
Prints as &lsquo;<samp><span class="samp">x[] &lt; y[]</span></samp>&rsquo;.

     <br><dt>Positive<dd>Represents the invariant &lsquo;<samp><span class="samp">x &amp;gt; 0</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo;
is a long scalar.  This exists
only as an example for the purposes of the manual.  It isn't actually
used (it is replaced by the more general invariant LowerBound).

     <br><dt>PrintableString<dd>Represents a string that contains only printable ascii characters
(values 32 through 126 plus 9 (tab)

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.string.PrintableString.enabled</span></samp>&rsquo;.

     <br><dt>RangeFloat.EqualMinusOne<dd>Internal invariant representing double scalars that are equal
to minus one.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing

     <br><dt>RangeFloat.EqualOne<dd>Internal invariant representing double scalars that are equal
to one.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing

     <br><dt>RangeFloat.EqualZero<dd>Internal invariant representing double scalars that are equal
to zero.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing.

     <br><dt>RangeFloat.GreaterEqual64<dd>Internal invariant representing double scalars that are greater
than or equal to 64.  Used for non-instantiating suppressions.  Will never
print since Bound accomplishes the same thing

     <br><dt>RangeFloat.GreaterEqualZero<dd>Internal invariant representing double scalars that are greater
than or equal to 0.  Used for non-instantiating suppressions.  Will never
print since Bound accomplishes the same thing

     <br><dt>RangeInt.BooleanVal<dd>Internal invariant representing longs whose values are always 0
or 1.  Used for non-instantiating suppressions.  Will never print
since OneOf accomplishes the same thing.

     <br><dt>RangeInt.Bound0_63<dd>Internal invariant representing longs whose values are between 0
and 63.  Used for non-instantiating suppressions.  Will never print
since Bound accomplishes the same thing.

     <br><dt>RangeInt.EqualMinusOne<dd>Internal invariant representing long scalars that are equal
to minus one.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing

     <br><dt>RangeInt.EqualOne<dd>Internal invariant representing long scalars that are equal
to one.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing

     <br><dt>RangeInt.EqualZero<dd>Internal invariant representing long scalars that are equal
to zero.  Used for non-instantiating suppressions.  Will never
print since OneOf accomplishes the same thing.

     <br><dt>RangeInt.Even<dd>Invariant representing longs whose values are always even. 
Used for non-instantiating suppressions.  Since this is not
covered by the Bound or OneOf invariants it is printed.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.RangeInt.Even.enabled</span></samp>&rsquo;.

     <br><dt>RangeInt.GreaterEqual64<dd>Internal invariant representing long scalars that are greater
than or equal to 64.  Used for non-instantiating suppressions.  Will never
print since Bound accomplishes the same thing

     <br><dt>RangeInt.GreaterEqualZero<dd>Internal invariant representing long scalars that are greater
than or equal to 0.  Used for non-instantiating suppressions.  Will never
print since Bound accomplishes the same thing

     <br><dt>RangeInt.PowerOfTwo<dd>Invariant representing longs whose values are always a power of 2
(exactly one bit is set).  Used for non-instantiating
suppressions.  Since this is not covered by the Bound or OneOf
invariants it is printed.

     <br><dt>Reverse<dd>Represents two sequences of long where one is in the reverse order
of the other.  Prints as &lsquo;<samp><span class="samp">x[] is the reverse of y[]</span></samp>&rsquo;.

     <br><dt>ReverseFloat<dd>Represents two sequences of double where one is in the reverse order
of the other.  Prints as &lsquo;<samp><span class="samp">x[] is the reverse of y[]</span></samp>&rsquo;.

     <br><dt>SeqFloatEqual<dd>Represents an invariant between a double scalar and a
a sequence of double values. 
Prints as &lsquo;<samp><span class="samp">x[] elements == y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a
double sequence and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; is a double scalar.

     <br><dt>SeqFloatGreaterEqual<dd>Represents an invariant between a double scalar and a
a sequence of double values. 
Prints as &lsquo;<samp><span class="samp">x[] elements &gt;= y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a
double sequence and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; is a double scalar.

     <br><dt>SeqFloatGreaterThan<dd>Represents an invariant between a double scalar and a
a sequence of double values. 
Prints as &lsquo;<samp><span class="samp">x[] elements &gt; y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a
double sequence and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; is a double scalar.

     <br><dt>SeqFloatLessEqual<dd>Represents an invariant between a double scalar and a
a sequence of double values. 
Prints as &lsquo;<samp><span class="samp">x[] elements &lt;= y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a
double sequence and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; is a double scalar.

     <br><dt>SeqFloatLessThan<dd>Represents an invariant between a double scalar and a
a sequence of double values. 
Prints as &lsquo;<samp><span class="samp">x[] elements &lt; y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a
double sequence and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; is a double scalar.

     <br><dt>SeqIndexFloatEqual<dd>Represents an invariant over sequences of double values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] == i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexFloatEqual.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexFloatGreaterEqual<dd>Represents an invariant over sequences of double values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] &gt;= i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexFloatGreaterEqual.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexFloatGreaterThan<dd>Represents an invariant over sequences of double values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] &gt; i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexFloatGreaterThan.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexFloatLessEqual<dd>Represents an invariant over sequences of double values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] &lt;= i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexFloatLessEqual.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexFloatLessThan<dd>Represents an invariant over sequences of double values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] &lt; i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexFloatLessThan.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexFloatNonEqual<dd>Represents an invariant over sequences of double values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] != i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexFloatNonEqual.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexIntEqual<dd>Represents an invariant over sequences of long values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] == i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexIntEqual.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexIntGreaterEqual<dd>Represents an invariant over sequences of long values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] &gt;= i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexIntGreaterEqual.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexIntGreaterThan<dd>Represents an invariant over sequences of long values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] &gt; i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexIntGreaterThan.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexIntLessEqual<dd>Represents an invariant over sequences of long values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] &lt;= i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexIntLessEqual.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexIntLessThan<dd>Represents an invariant over sequences of long values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] &lt; i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexIntLessThan.enabled</span></samp>&rsquo;.

     <br><dt>SeqIndexIntNonEqual<dd>Represents an invariant over sequences of long values between the
index of an element of the sequence and the element itself. 
Prints as &lsquo;<samp><span class="samp">x[i] != i</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.unary.sequence.SeqIndexIntNonEqual.enabled</span></samp>&rsquo;.

     <br><dt>SeqIntEqual<dd>Represents an invariant between a long scalar and a
a sequence of long values. 
Prints as &lsquo;<samp><span class="samp">x[] elements == y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a
long sequence and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; is a long scalar.

     <br><dt>SeqIntGreaterEqual<dd>Represents an invariant between a long scalar and a
a sequence of long values. 
Prints as &lsquo;<samp><span class="samp">x[] elements &gt;= y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a
long sequence and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; is a long scalar.

     <br><dt>SeqIntGreaterThan<dd>Represents an invariant between a long scalar and a
a sequence of long values. 
Prints as &lsquo;<samp><span class="samp">x[] elements &gt; y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a
long sequence and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; is a long scalar.

     <br><dt>SeqIntLessEqual<dd>Represents an invariant between a long scalar and a
a sequence of long values. 
Prints as &lsquo;<samp><span class="samp">x[] elements &lt;= y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a
long sequence and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; is a long scalar.

     <br><dt>SeqIntLessThan<dd>Represents an invariant between a long scalar and a
a sequence of long values. 
Prints as &lsquo;<samp><span class="samp">x[] elements &lt; y</span></samp>&rsquo; where &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a
long sequence and &lsquo;<samp><span class="samp">y</span></samp>&rsquo; is a long scalar.

     <br><dt>SeqSeqFloatEqual<dd>Represents invariants between two sequences of double values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] == y[] lexically</span></samp>&rsquo;.

     <p>If order doesn't matter for each variable, then the sequences
are compared to see if they are set equivalent.  Prints as
&lsquo;<samp><span class="samp">x[] == y[]</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqFloatGreaterEqual<dd>Represents invariants between two sequences of double values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &gt;= y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqFloatGreaterThan<dd>Represents invariants between two sequences of double values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &gt; y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqFloatLessEqual<dd>Represents invariants between two sequences of double values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &lt;= y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqFloatLessThan<dd>Represents invariants between two sequences of double values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &lt; y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqIntEqual<dd>Represents invariants between two sequences of long values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] == y[] lexically</span></samp>&rsquo;.

     <p>If order doesn't matter for each variable, then the sequences
are compared to see if they are set equivalent.  Prints as
&lsquo;<samp><span class="samp">x[] == y[]</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqIntGreaterEqual<dd>Represents invariants between two sequences of long values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &gt;= y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqIntGreaterThan<dd>Represents invariants between two sequences of long values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &gt; y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqIntLessEqual<dd>Represents invariants between two sequences of long values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &lt;= y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqIntLessThan<dd>Represents invariants between two sequences of long values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &lt; y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqStringEqual<dd>Represents invariants between two sequences of String values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] == y[] lexically</span></samp>&rsquo;.

     <p>If order doesn't matter for each variable, then the sequences
are compared to see if they are set equivalent.  Prints as
&lsquo;<samp><span class="samp">x[] == y[]</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqStringGreaterEqual<dd>Represents invariants between two sequences of String values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &gt;= y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqStringGreaterThan<dd>Represents invariants between two sequences of String values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &gt; y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqStringLessEqual<dd>Represents invariants between two sequences of String values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &lt;= y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>SeqSeqStringLessThan<dd>Represents invariants between two sequences of String values.  If order
matters for each variable (which it does by default), then the
sequences are compared lexically. 
Prints as &lsquo;<samp><span class="samp">x[] &lt; y[] lexically</span></samp>&rsquo;.

     <p>If the auxiliary information (e.g., order matters)
doesn't match between two variables, then this invariant cannot
apply to those variables.

     <br><dt>StdString.SubString<dd>Represents the substring invariant between
two String scalars.  Prints as &lsquo;<samp><span class="samp">x is a substring of y</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoString.StdString.SubString.enabled</span></samp>&rsquo;.

     <br><dt>StringEqual<dd>Represents an invariant of "==" between two
String scalars.

     <br><dt>StringGreaterEqual<dd>Represents an invariant of "&gt;=" between two
String scalars.

     <br><dt>StringGreaterThan<dd>Represents an invariant of "&gt;" between two
String scalars.

     <br><dt>StringLessEqual<dd>Represents an invariant of "&lt;=" between two
String scalars.

     <br><dt>StringLessThan<dd>Represents an invariant of "&lt;" between two
String scalars.

     <br><dt>StringNonEqual<dd>Represents an invariant of "!=" between two
String scalars.

     <br><dt>SubSequence<dd>Represents two sequences of long values where one sequence is a
subsequence of the other.  Prints as
&lsquo;<samp><span class="samp">x[] is a subsequence of y[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.SubSequence.enabled</span></samp>&rsquo;.

     <br><dt>SubSequenceFloat<dd>Represents two sequences of double values where one sequence is a
subsequence of the other.  Prints as
&lsquo;<samp><span class="samp">x[] is a subsequence of y[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.SubSequenceFloat.enabled</span></samp>&rsquo;.

     <br><dt>SubSet<dd>Represents two sequences of long values where one of the sequences is a
subset of the other; that is each element of one sequence appears in the
other. 
Prints as either &lsquo;<samp><span class="samp">x[] is a subset of y[]</span></samp>&rsquo; or as
&lsquo;<samp><span class="samp">x[] is a superset of y[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.SubSet.enabled</span></samp>&rsquo;.

     <br><dt>SubSetFloat<dd>Represents two sequences of double values where one of the sequences is a
subset of the other; that is each element of one sequence appears in the
other. 
Prints as either &lsquo;<samp><span class="samp">x[] is a subset of y[]</span></samp>&rsquo; or as
&lsquo;<samp><span class="samp">x[] is a superset of y[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.SubSetFloat.enabled</span></samp>&rsquo;.

     <br><dt>SuperSequence<dd>Represents two sequences of long values where one sequence is a
subsequence of the other.  Prints as
&lsquo;<samp><span class="samp">x[] is a subsequence of y[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.SuperSequence.enabled</span></samp>&rsquo;.

     <br><dt>SuperSequenceFloat<dd>Represents two sequences of double values where one sequence is a
subsequence of the other.  Prints as
&lsquo;<samp><span class="samp">x[] is a subsequence of y[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.SuperSequenceFloat.enabled</span></samp>&rsquo;.

     <br><dt>SuperSet<dd>Represents two sequences of long values where one of the sequences is a
subset of the other; that is each element of one sequence appears in the
other. 
Prints as either &lsquo;<samp><span class="samp">x[] is a subset of y[]</span></samp>&rsquo; or as
&lsquo;<samp><span class="samp">x[] is a superset of y[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.SuperSet.enabled</span></samp>&rsquo;.

     <br><dt>SuperSetFloat<dd>Represents two sequences of double values where one of the sequences is a
subset of the other; that is each element of one sequence appears in the
other. 
Prints as either &lsquo;<samp><span class="samp">x[] is a subset of y[]</span></samp>&rsquo; or as
&lsquo;<samp><span class="samp">x[] is a superset of y[]</span></samp>&rsquo;.

     <p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp><span class="samp">daikon.inv.binary.twoSequence.SuperSetFloat.enabled</span></samp>&rsquo;.

     <br><dt>UpperBound<dd>Represents the invariant &lsquo;<samp><span class="samp">x &lt;= c</span></samp>&rsquo;, where &lsquo;<samp><span class="samp">c</span></samp>&rsquo;
is a constant and &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a long scalar.

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.UpperBound.minimal_interesting</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.UpperBound.maximal_interesting</span></samp>&rsquo;
    </ul>

     <br><dt>UpperBoundFloat<dd>Represents the invariant &lsquo;<samp><span class="samp">x &lt;= c</span></samp>&rsquo;, where &lsquo;<samp><span class="samp">c</span></samp>&rsquo;
is a constant and &lsquo;<samp><span class="samp">x</span></samp>&rsquo; is a double scalar.

     <p>See also the following configuration options:
          <ul>
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.UpperBoundFloat.minimal_interesting</span></samp>&rsquo;
    <li>&lsquo;<samp><span class="samp">daikon.inv.unary.scalar.UpperBoundFloat.maximal_interesting</span></samp>&rsquo;
    </ul>

     <!-- END AUTO-GENERATED INVARIANTS LISTING -->
   </dl>

<div class="node">
<p><hr>
<a name="Invariant-filters"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Invariant-list">Invariant list</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-output">Daikon output</a>

</div>

<h3 class="section">5.6 Invariant filters</h3>

<p><a name="index-invariant-filters-81"></a><a name="index-filters-82"></a>
Invariant filters are used to suppress the printing of invariants that
are true, but not considered &ldquo;interesting&rdquo; &mdash; usually
because the invariants are considered obvious or redundant in a given
context.

   <p>The following is a list of the invariant filters that Daikon supports. 
Each of these filters has a corresponding configuration enable switch;
by default, all filters are enabled.  See <a href="#Options-to-enable_002fdisable-filters">Options to enable/disable filters</a>,
for details.

     
<a name="index-DerivedParameterFilter-83"></a>
<ul><li>DerivedParameterFilter:  suppress parameter-derived postcondition invariants

     <p>This filter suppresses invariants at procedure exit points that are
uninteresting because they refer to prestate variables derived from
pass-by-value parameters.  For example, suppose that <code>param</code> is a
parameter to a
Java method.  If <code>param</code> itself is modified, that change won't be
visible to a caller, so it's uninteresting to print.  If <code>param</code> points
to an object, and that object is changed, that is visible, but
only if <code>param</code> hasn't changed; otherwise, the invariant would report a
change in some object other than the one that was passed in.

     <p><a name="index-ObviousFilter-84"></a><li>ObviousFilter:  suppress obvious invariants

     <p>This filter suppresses invariants because they are obvious from looking
at other invariants.  Some examples are:

          <ul>
<li>If &lsquo;<samp><span class="samp">size(args[])==0</span></samp>&rsquo; is shown, then &lsquo;<samp><span class="samp">size(args[])-1==-1</span></samp>&rsquo; is
obvious and will not be displayed by default. 
<li>If &lsquo;<samp><span class="samp">this.topOfStack &lt; size(this.theArray[])-1</span></samp>&rsquo; is shown, then
&lsquo;<samp><span class="samp">this.topOfStack &lt; size(this.theArray[])</span></samp>&rsquo; is obvious and will not be
displayed by default.

     </ul>

     <p><a name="index-OnlyConstantVariablesFilter-85"></a><li>OnlyConstantVariablesFilter:  suppress invariants containing only constants

     <p>This filter suppresses comparison invariants in which all of the
variables being compared were observed to be constant.  In the current
version of Daikon, most such invariants are not even created in the
first place, because constants are detected on an early pass over the
data.  However, Daikon will note that all of the invariants that had
any particular constant value were also equal to each other: such
invariants will be suppressed by this filter.

     <p><a name="index-ParentFilter-86"></a><li>ParentFilter:  filter invariants that match a parent program point invariant

     <p>A controlled invariant is an invariant that is &ldquo;controlled&rdquo; &mdash; or
implied &mdash; by a parent program point in the dataflow hierarchy. 
For example, for Java instrumented
code each class is associated with an object program point, which
contain invariants that are found at the entry and exit of all public
methods.  So in addition to the usual program points such as
<code>StackAr.StackAr(int):::ENTER</code> and
<code>StackAr.isEmpty():::EXIT48</code>, daikon outputs invariants for the
artificial program point <code>StackAr:::OBJECT</code>.  The invariants for
<code>StackAr:::OBJECT</code> control the invariants for
<code>StackAr.StackAr(int):::ENTER</code> and
<code>StackAr.isEmpty():::EXIT48</code>, because the former imply the latter. 
Because of this redundancy, controlled invariants are not displayed by
default.  Note that if for some reason, the controlling invariant is not
displayed (for example, because it's unjustified), then the controlled
invariant <em>will</em> be displayed.

     <p><a name="index-SimplifyFilter-87"></a><li>SimplifyFilter:  eliminate redundant invariants using Simplify

     <p>Daikon contains built-in test that remove most redundant (logically
implied) invariants from its output; see

     <p>Daikon can use the Simplify theorem-prover to eliminate even more
implied invariants than Daikon's built-in tests are able to eliminate. 
Simplify must be separately obtained (from
<a href="http://www.hpl.hp.com/downloads/crl/jtk/">http://www.hpl.hp.com/downloads/crl/jtk/</a>) and installed in
order to take advantage of this filter.

     <p>If you don't also specify the <samp><span class="option">--suppress_redundant</span></samp> command-line
option (see <a href="#Options-to-control-invariant-detection">Options to control invariant detection</a>) to enable
Simplify processing, this filter doesn't do anything.

     <p><a name="index-UnjustifiedFilter-88"></a><li>UnjustifiedFilter:  suppress unjustified invariants

     <p>For every invariant, Daikon estimates the probability of that invariant
happening by chance.  If that probability is less than the limit, then
the invariant is deemed to be an actual invariant, not just a chance
occurrence.  Currently the limit is .01.  So by default, only invariants
with probabilities of less than 1% are shown.  See the <samp><span class="option">--conf_limit</span></samp>
option (see <a href="#Options-to-control-invariant-detection">Options to control invariant detection</a>).

     <p><a name="index-UnmodifiedVariableEqualityFilter-89"></a><li>UnmodifiedVariableEqualityFilter:  suppress invariants that merely indicate that a variable was unmodified

     <p>This filter is only useful for ESC output.

   </ul>

<div class="node">
<p><hr>
<a name="Enhancing-Daikon-output"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Daikon-output">Daikon output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Enhancing Daikon output</h2>

<ul class="menu">
<li><a accesskey="1" href="#Configuration-options">Configuration options</a>
<li><a accesskey="2" href="#Conditional-invariants">Conditional invariants</a>
<li><a accesskey="3" href="#Enhancing-conditional-invariant-detection">Enhancing conditional invariant detection</a>
<li><a accesskey="4" href="#Dynamic-abstract-type-inference-_0028DynComp_0029">Dynamic abstract type inference (DynComp)</a>
<li><a accesskey="5" href="#Loop-invariants">Loop invariants</a>
</ul>

<div class="node">
<p><hr>
<a name="Configuration-options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Conditional-invariants">Conditional invariants</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Enhancing-Daikon-output">Enhancing Daikon output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enhancing-Daikon-output">Enhancing Daikon output</a>

</div>

<h3 class="section">6.1 Configuration options</h3>

<p><a name="index-configuration-options-90"></a><a name="index-dkconfig_005f-variables-91"></a>
Many aspects of Daikon's behavior can be controlled by setting various
configuration parameters.  These configuration parameters control which
invariants are checked and reported, the statistical tests for
invariants, which derived variables are created, and more.

   <p>The configuration options are set by creating a configuration file and
supplying it to Daikon on the command line using the <samp><span class="option">--config
</span><var>filename</var></samp> option.  Daikon reads all supplied configuration files
in order, overriding the defaults.  You may wish to use the supplied
example configuration file
<samp><span class="file">daikon/java/daikon/config/example-settings.txt</span></samp> as an example when
creating your own configuration files.  (If you did not download
Daikon's sources, you must extract the example from
<samp><span class="file">daikon.jar</span></samp> to read it.)

   <p>You can also control Daikon's output via its command-line options
(see <a href="#Running-Daikon">Running Daikon</a>) and via the command-line options to its front
ends such as Chicory (see <a href="#Chicory-options">Chicory options</a>) or Kvasir (see <a href="#Kvasir-options">Kvasir options</a>).

   <p>You may also specify a configuration setting directly on the command line,
using the <samp><span class="option">--config_option </span><var>name</var><span class="option">=</span><var>value</var></samp> option.

   <p>The configuration options are different from the debugging flags
<samp><span class="option">--debug</span></samp> and <samp><span class="option">--dbg </span><var>category</var></samp>
(see <a href="#Daikon-debugging-options">Daikon debugging options</a>). 
The debugging flags permit Daikon to produce debugging
output, but they do not affect the invariants that Daikon computes.

<ul class="menu">
<li><a accesskey="1" href="#List-of-configuration-options">List of configuration options</a>
</ul>

<div class="node">
<p><hr>
<a name="List-of-configuration-options"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Configuration-options">Configuration options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Configuration-options">Configuration options</a>

</div>

<h4 class="subsection">6.1.1 List of configuration options</h4>

<p>This is a list of all Daikon configuration options. 
The configuration option name contains the
Java class in which it is defined.  (In the Daikon source code, the
configuration value is stored in a variable whose name contains a
<code>dkconfig_</code> prefix, but that should be irrelevant to users.) 
To learn more about a specific invariant or derived variable than
appears in this manual, see its source code.

<!-- The config options are categorized into sections by pattern-matching -->
<!-- their names.  If you are adding new options, you might want to choose -->
<!-- names similar to those of similar options. -->
<!-- Currently the categories are: -->
<!-- daikon.inv.filter.*.enabled  -> turn filters on/off -->
<!-- daikon.inv.*.enabled -> turn invariant detection on/off -->
<!-- daikon.inv.* -> other invariant configuration -->
<!-- daikon.derive.* -> turn derived parameters on/off -->
<!-- daikon.simplify.* -> options for Simplify -->
<!-- * -> general options -->
<!-- See ParameterDoclet.java for details. -->
<!-- BEGIN AUTO-GENERATED CONFIG OPTIONS LISTING -->
<ul class="menu">
<li><a accesskey="1" href="#Options-to-enable_002fdisable-filters">Options to enable/disable filters</a>
<li><a accesskey="2" href="#Options-to-enable_002fdisable-specific-invariants">Options to enable/disable specific invariants</a>
<li><a accesskey="3" href="#Other-invariant-configuration-parameters">Other invariant configuration parameters</a>
<li><a accesskey="4" href="#Options-to-enable_002fdisable-derived-variables">Options to enable/disable derived variables</a>
<li><a accesskey="5" href="#Simplify-interface-configuration-options">Simplify interface configuration options</a>
<li><a accesskey="6" href="#General-configuration-options">General configuration options</a>
</ul>

<div class="node">
<p><hr>
<a name="Options-to-enable%2fdisable-filters"></a>
<a name="Options-to-enable_002fdisable-filters"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Options-to-enable_002fdisable-specific-invariants">Options to enable/disable specific invariants</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#List-of-configuration-options">List of configuration options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#List-of-configuration-options">List of configuration options</a>

</div>

<h5 class="subsubsection">6.1.1.1 Options to enable/disable filters</h5>

<p><a name="index-filters_002c-enabling_002fdisabling-92"></a>These configuration options enable or disable filters that suppress printing of certain invariants.  Invariants are filtered if they are found to be true but are considered uninteresting or redundant.  See <a href="#Invariant-filters">Invariant filters</a>, for more information.

     <dl>
<dt><samp><span class="option">daikon.inv.filter.DerivedParameterFilter.enabled</span></samp><dd>Boolean. If true, DerivedParameterFilter is initially turned on. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.filter.ObviousFilter.enabled</span></samp><dd>Boolean. If true, ObviousFilter is initially turned on. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.filter.OnlyConstantVariablesFilter.enabled</span></samp><dd>Boolean. If true, OnlyConstantVariablesFilter is initially turned on. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.filter.ParentFilter.enabled</span></samp><dd>Boolean. If true, ParentFilter is initially turned on. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.filter.SimplifyFilter.enabled</span></samp><dd>Boolean. If true, SimplifyFilter is initially turned on. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.filter.UnjustifiedFilter.enabled</span></samp><dd>Boolean. If true, UnjustifiedFilter is initially turned on. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.filter.UnmodifiedVariableEqualityFilter.enabled</span></samp><dd>Boolean. If true, UnmodifiedVariableEqualityFilter is initially turned on. 
The default value is `true'.

   </dl>

<div class="node">
<p><hr>
<a name="Options-to-enable%2fdisable-specific-invariants"></a>
<a name="Options-to-enable_002fdisable-specific-invariants"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Other-invariant-configuration-parameters">Other invariant configuration parameters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Options-to-enable_002fdisable-filters">Options to enable/disable filters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#List-of-configuration-options">List of configuration options</a>

</div>

<h5 class="subsubsection">6.1.1.2 Options to enable/disable specific invariants</h5>

<p><a name="index-invariants_002c-enabling_002fdisabling-93"></a>These options control whether Daikon looks for specific kinds of invariants.  See <a href="#Invariant-list">Invariant list</a>, for more information about the corresponding invariants.

     <dl>
<dt><samp><span class="option">daikon.inv.binary.sequenceScalar.Member.enabled</span></samp><dd>Boolean.  True iff Member invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.MemberFloat.enabled</span></samp><dd>Boolean.  True iff Member invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.SeqFloatEqual.enabled</span></samp><dd>Boolean.  True iff SeqFloatEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.SeqFloatGreaterEqual.enabled</span></samp><dd>Boolean.  True iff SeqFloatGreaterEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.SeqFloatGreaterThan.enabled</span></samp><dd>Boolean.  True iff SeqFloatGreaterThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.SeqFloatLessEqual.enabled</span></samp><dd>Boolean.  True iff SeqFloatLessEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.SeqFloatLessThan.enabled</span></samp><dd>Boolean.  True iff SeqFloatLessThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.SeqIntEqual.enabled</span></samp><dd>Boolean.  True iff SeqIntEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.SeqIntGreaterEqual.enabled</span></samp><dd>Boolean.  True iff SeqIntGreaterEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.SeqIntGreaterThan.enabled</span></samp><dd>Boolean.  True iff SeqIntGreaterThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.SeqIntLessEqual.enabled</span></samp><dd>Boolean.  True iff SeqIntLessEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceScalar.SeqIntLessThan.enabled</span></samp><dd>Boolean.  True iff SeqIntLessThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.sequenceString.MemberString.enabled</span></samp><dd>Boolean.  True iff Member invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.FloatEqual.enabled</span></samp><dd>Boolean.  True iff FloatEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.FloatGreaterEqual.enabled</span></samp><dd>Boolean.  True iff FloatGreaterEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.FloatGreaterThan.enabled</span></samp><dd>Boolean.  True iff FloatGreaterThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.FloatLessEqual.enabled</span></samp><dd>Boolean.  True iff FloatLessEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.FloatLessThan.enabled</span></samp><dd>Boolean.  True iff FloatLessThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.FloatNonEqual.enabled</span></samp><dd>Boolean.  True iff FloatNonEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.IntEqual.enabled</span></samp><dd>Boolean.  True iff IntEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.IntGreaterEqual.enabled</span></samp><dd>Boolean.  True iff IntGreaterEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.IntGreaterThan.enabled</span></samp><dd>Boolean.  True iff IntGreaterThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.IntLessEqual.enabled</span></samp><dd>Boolean.  True iff IntLessEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.IntLessThan.enabled</span></samp><dd>Boolean.  True iff IntLessThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.IntNonEqual.enabled</span></samp><dd>Boolean.  True iff IntNonEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.LinearBinary.enabled</span></samp><dd>Boolean.  True iff LinearBinary invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.LinearBinaryFloat.enabled</span></samp><dd>Boolean.  True iff LinearBinary invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.NumericFloat.Divides.enabled</span></samp><dd>Boolean.  True iff divides invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.NumericFloat.Square.enabled</span></samp><dd>Boolean.  True iff square invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.NumericFloat.ZeroTrack.enabled</span></samp><dd>Boolean.  True iff zero-track invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.NumericInt.BitwiseAndZero.enabled</span></samp><dd>Boolean.  True iff BitwiseAndZero invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.NumericInt.BitwiseComplement.enabled</span></samp><dd>Boolean.  True iff bitwise complement invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.NumericInt.BitwiseSubset.enabled</span></samp><dd>Boolean.  True iff bitwise subset invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.NumericInt.Divides.enabled</span></samp><dd>Boolean.  True iff divides invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.NumericInt.ShiftZero.enabled</span></samp><dd>Boolean.  True iff ShiftZero invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.NumericInt.Square.enabled</span></samp><dd>Boolean.  True iff square invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.NumericInt.ZeroTrack.enabled</span></samp><dd>Boolean.  True iff zero-track invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseFloatEqual.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseFloatGreaterEqual.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseFloatGreaterThan.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseFloatLessEqual.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseFloatLessThan.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseIntEqual.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseIntGreaterEqual.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseIntGreaterThan.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseIntLessEqual.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseIntLessThan.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseLinearBinary.enabled</span></samp><dd>Boolean.  True iff PairwiseLinearBinary invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseLinearBinaryFloat.enabled</span></samp><dd>Boolean.  True iff PairwiseLinearBinary invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseNumericFloat.Divides.enabled</span></samp><dd>Boolean.  True iff divides invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseNumericFloat.Square.enabled</span></samp><dd>Boolean.  True iff square invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseNumericFloat.ZeroTrack.enabled</span></samp><dd>Boolean.  True iff zero-track invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseAndZero.enabled</span></samp><dd>Boolean.  True iff BitwiseAndZero invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseComplement.enabled</span></samp><dd>Boolean.  True iff bitwise complement invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseSubset.enabled</span></samp><dd>Boolean.  True iff bitwise subset invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseNumericInt.Divides.enabled</span></samp><dd>Boolean.  True iff divides invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseNumericInt.ShiftZero.enabled</span></samp><dd>Boolean.  True iff ShiftZero invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseNumericInt.Square.enabled</span></samp><dd>Boolean.  True iff square invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseNumericInt.ZeroTrack.enabled</span></samp><dd>Boolean.  True iff zero-track invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseString.SubString.enabled</span></samp><dd>Boolean.  True iff SubString invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseStringEqual.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseStringGreaterEqual.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseStringGreaterThan.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseStringLessEqual.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.PairwiseStringLessThan.enabled</span></samp><dd>Boolean.  True iff PairwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.Reverse.enabled</span></samp><dd>Boolean.  True iff Reverse invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.ReverseFloat.enabled</span></samp><dd>Boolean.  True iff Reverse invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqFloatEqual.enabled</span></samp><dd>Boolean.  True iff SeqSeqFloatEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqFloatGreaterEqual.enabled</span></samp><dd>Boolean.  True iff SeqSeqFloatGreaterEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqFloatGreaterThan.enabled</span></samp><dd>Boolean.  True iff SeqSeqFloatGreaterThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqFloatLessEqual.enabled</span></samp><dd>Boolean.  True iff SeqSeqFloatLessEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqFloatLessThan.enabled</span></samp><dd>Boolean.  True iff SeqSeqFloatLessThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqIntEqual.enabled</span></samp><dd>Boolean.  True iff SeqSeqIntEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqIntGreaterEqual.enabled</span></samp><dd>Boolean.  True iff SeqSeqIntGreaterEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqIntGreaterThan.enabled</span></samp><dd>Boolean.  True iff SeqSeqIntGreaterThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqIntLessEqual.enabled</span></samp><dd>Boolean.  True iff SeqSeqIntLessEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqIntLessThan.enabled</span></samp><dd>Boolean.  True iff SeqSeqIntLessThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqStringEqual.enabled</span></samp><dd>Boolean.  True iff SeqSeqStringEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqStringGreaterEqual.enabled</span></samp><dd>Boolean.  True iff SeqSeqStringGreaterEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqStringGreaterThan.enabled</span></samp><dd>Boolean.  True iff SeqSeqStringGreaterThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqStringLessEqual.enabled</span></samp><dd>Boolean.  True iff SeqSeqStringLessEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SeqSeqStringLessThan.enabled</span></samp><dd>Boolean.  True iff SeqSeqStringLessThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SubSequence.enabled</span></samp><dd>Boolean.  True iff SubSequence invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SubSequenceFloat.enabled</span></samp><dd>Boolean.  True iff SubSequence invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SubSet.enabled</span></samp><dd>Boolean.  True iff SubSet invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SubSetFloat.enabled</span></samp><dd>Boolean.  True iff SubSet invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SuperSequence.enabled</span></samp><dd>Boolean.  True iff SubSequence invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SuperSequenceFloat.enabled</span></samp><dd>Boolean.  True iff SubSequence invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SuperSet.enabled</span></samp><dd>Boolean.  True iff SubSet invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoSequence.SuperSetFloat.enabled</span></samp><dd>Boolean.  True iff SubSet invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoString.StdString.SubString.enabled</span></samp><dd>Boolean.  True iff SubString invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoString.StringEqual.enabled</span></samp><dd>Boolean.  True iff StringEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoString.StringGreaterEqual.enabled</span></samp><dd>Boolean.  True iff StringGreaterEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoString.StringGreaterThan.enabled</span></samp><dd>Boolean.  True iff StringGreaterThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoString.StringLessEqual.enabled</span></samp><dd>Boolean.  True iff StringLessEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoString.StringLessThan.enabled</span></samp><dd>Boolean.  True iff StringLessThan invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoString.StringNonEqual.enabled</span></samp><dd>Boolean.  True iff StringNonEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.ternary.threeScalar.FunctionBinary.enabled</span></samp><dd>Boolean. True if FunctionBinary invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.ternary.threeScalar.FunctionBinaryFloat.enabled</span></samp><dd>Boolean. True if FunctionBinaryFloat invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.ternary.threeScalar.LinearTernary.enabled</span></samp><dd>Boolean.  True iff LinearTernary invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.ternary.threeScalar.LinearTernaryFloat.enabled</span></samp><dd>Boolean.  True iff LinearTernary invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.CompleteOneOfScalar.enabled</span></samp><dd>Boolean.  True iff CompleteOneOfScalar invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.IsPointer.enabled</span></samp><dd>Boolean. True iff IsPointer invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.LowerBound.enabled</span></samp><dd>Boolean.  True iff LowerBound invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.LowerBoundFloat.enabled</span></samp><dd>Boolean.  True iff LowerBoundFloat invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.Modulus.enabled</span></samp><dd>Boolean.  True iff Modulus invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.NonModulus.enabled</span></samp><dd>Boolean.  True iff NonModulus invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.NonZero.enabled</span></samp><dd>Boolean.  True iff NonZero invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.NonZeroFloat.enabled</span></samp><dd>Boolean.  True iff NonZeroFloat invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.OneOfFloat.enabled</span></samp><dd>Boolean.  True iff OneOf invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.OneOfScalar.enabled</span></samp><dd>Boolean.  True iff OneOf invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.Positive.enabled</span></samp><dd>Boolean.  True iff Positive invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.RangeInt.Even.enabled</span></samp><dd>Boolean.  True if Even invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.RangeInt.PowerOfTwo.enabled</span></samp><dd>Boolean.  True if PowerOfTwo invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.UpperBound.enabled</span></samp><dd>Boolean.  True iff UpperBound invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.UpperBoundFloat.enabled</span></samp><dd>Boolean.  True iff UpperBoundFloat invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.CommonFloatSequence.enabled</span></samp><dd>Boolean.  True iff CommonSequence invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.CommonSequence.enabled</span></samp><dd>Boolean.  True iff CommonSequence invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltLowerBound.enabled</span></samp><dd>Boolean.  True iff EltLowerBound invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltLowerBoundFloat.enabled</span></samp><dd>Boolean.  True iff EltLowerBoundFloat invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltNonZero.enabled</span></samp><dd>Boolean.  True iff EltNonZero invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltNonZeroFloat.enabled</span></samp><dd>Boolean.  True iff EltNonZero invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltOneOf.enabled</span></samp><dd>Boolean.  True iff OneOf invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltOneOfFloat.enabled</span></samp><dd>Boolean.  True iff OneOf invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltRangeInt.Even.enabled</span></samp><dd>Boolean.  True if Even invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltRangeInt.PowerOfTwo.enabled</span></samp><dd>Boolean.  True if PowerOfTwo invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltUpperBound.enabled</span></samp><dd>Boolean.  True iff EltUpperBound invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltUpperBoundFloat.enabled</span></samp><dd>Boolean.  True iff EltUpperBoundFloat invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltwiseFloatEqual.enabled</span></samp><dd>Boolean.  True iff EltwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltwiseFloatGreaterEqual.enabled</span></samp><dd>Boolean.  True iff EltwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltwiseFloatGreaterThan.enabled</span></samp><dd>Boolean.  True iff EltwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltwiseFloatLessEqual.enabled</span></samp><dd>Boolean.  True iff EltwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltwiseFloatLessThan.enabled</span></samp><dd>Boolean.  True iff EltwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltwiseIntEqual.enabled</span></samp><dd>Boolean.  True iff EltwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltwiseIntGreaterEqual.enabled</span></samp><dd>Boolean.  True iff EltwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltwiseIntGreaterThan.enabled</span></samp><dd>Boolean.  True iff EltwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltwiseIntLessEqual.enabled</span></samp><dd>Boolean.  True iff EltwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltwiseIntLessThan.enabled</span></samp><dd>Boolean.  True iff EltwiseIntComparison invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.NoDuplicates.enabled</span></samp><dd>Boolean.  True iff NoDuplicates invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.NoDuplicatesFloat.enabled</span></samp><dd>Boolean.  True iff NoDuplicates invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.OneOfFloatSequence.enabled</span></samp><dd>Boolean.  True iff OneOf invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.OneOfSequence.enabled</span></samp><dd>Boolean.  True iff OneOf invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexFloatEqual.enabled</span></samp><dd>Boolean.  True iff SeqIndexFloatEqual invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexFloatGreaterEqual.enabled</span></samp><dd>Boolean.  True iff SeqIndexFloatGreaterEqual invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexFloatGreaterThan.enabled</span></samp><dd>Boolean.  True iff SeqIndexFloatGreaterThan invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexFloatLessEqual.enabled</span></samp><dd>Boolean.  True iff SeqIndexFloatLessEqual invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexFloatLessThan.enabled</span></samp><dd>Boolean.  True iff SeqIndexFloatLessThan invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexFloatNonEqual.enabled</span></samp><dd>Boolean.  True iff SeqIndexFloatNonEqual invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexIntEqual.enabled</span></samp><dd>Boolean.  True iff SeqIndexIntEqual invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexIntGreaterEqual.enabled</span></samp><dd>Boolean.  True iff SeqIndexIntGreaterEqual invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexIntGreaterThan.enabled</span></samp><dd>Boolean.  True iff SeqIndexIntGreaterThan invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexIntLessEqual.enabled</span></samp><dd>Boolean.  True iff SeqIndexIntLessEqual invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexIntLessThan.enabled</span></samp><dd>Boolean.  True iff SeqIndexIntLessThan invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SeqIndexIntNonEqual.enabled</span></samp><dd>Boolean.  True iff SeqIndexIntNonEqual invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.string.CompleteOneOfString.enabled</span></samp><dd>Boolean.  True iff PrintableString invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.string.OneOfString.enabled</span></samp><dd>Boolean.  True iff OneOf invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.string.PrintableString.enabled</span></samp><dd>Boolean.  True iff PrintableString invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.stringsequence.CommonStringSequence.enabled</span></samp><dd>Boolean.  True iff CommonStringSequence invariants should be considered. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.stringsequence.EltOneOfString.enabled</span></samp><dd>Boolean.  True iff OneOf invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.unary.stringsequence.OneOfStringSequence.enabled</span></samp><dd>Boolean.  True iff OneOf invariants should be considered. 
The default value is `true'.

   </dl>

<div class="node">
<p><hr>
<a name="Other-invariant-configuration-parameters"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Options-to-enable_002fdisable-derived-variables">Options to enable/disable derived variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Options-to-enable_002fdisable-specific-invariants">Options to enable/disable specific invariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#List-of-configuration-options">List of configuration options</a>

</div>

<h5 class="subsubsection">6.1.1.3 Other invariant configuration parameters</h5>

<p><a name="index-invariants_002c-configuring-94"></a>The configuration options listed in this section parameterize the behavior of certain invariants.  See <a href="#Invariant-list">Invariant list</a>, for more information about the invariants.

     <dl>
<dt><samp><span class="option">daikon.inv.Invariant.confidence_limit</span></samp><dd>Floating-point number between 0 and 1.  Invariants are displayed only if
the confidence that the invariant did not occur by chance is
greater than this.  (May also be set
via &lsquo;<samp><span class="samp">--conf_limit</span></samp>&rsquo; switch to Daikon; refer to manual.) 
The default value is `0.99'.

     <br><dt><samp><span class="option">daikon.inv.Invariant.fuzzy_ratio</span></samp><dd>Floating-point number between 0 and 0.1, representing the maximum
relative difference
between two floats for fuzzy comparisons.  Larger values will
result in floats that are relatively farther apart being treated
as equal.  A value of 0 essentially disables fuzzy comparisons. 
Specifically, if <code>abs (1 - f1/f2)</code> is less than or equal
to this value, then the two doubles (<code>f1</code> and <code>f2</code>)
will be treated as equal by
Daikon. 
The default value is `1.0E-4'.

     <br><dt><samp><span class="option">daikon.inv.Invariant.simplify_define_predicates</span></samp><dd>A boolean value.  If true, Daikon's Simplify output (printed when
the &lsquo;<samp><span class="samp">--format simplify</span></samp>&rsquo; flag is enabled, and used internally by
&lsquo;<samp><span class="samp">--suppress_redundant</span></samp>&rsquo;)
will include new predicates representing
some complex relationships in invariants, such as lexical
ordering among sequences.  If false, some complex relationships
will appear in the output as complex quantified formulas, while
others will not appear at all.  When enabled, Simplify may be able
to make more inferences, allowing &lsquo;<samp><span class="samp">--suppress_redundant</span></samp>&rsquo; to
suppress more redundant invariants, but Simplify may also run
more slowly. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.binary.twoScalar.IntNonEqual.integral_only</span></samp><dd>Boolean.  True iff IntNonEqual invariants should be considered. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.inv.filter.DerivedVariableFilter.class_re</span></samp><dd>Regular expression to match against the class name of derived
variables.  Invariants that contain derived variables that match will
be filtered out.  If null, nothing will be filtered out. 
The default value is `null'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.LowerBound.maximal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>minimal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
LowerBound invariants whose cutoff was one of (-1,0,1,2). 
The default value is `2'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.LowerBound.minimal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>maximal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
LowerBound invariants whose cutoff was one of (-1,0,1,2). 
The default value is `-1'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.LowerBoundFloat.maximal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>minimal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
LowerBoundFloat invariants whose cutoff was one of (-1,0,1,2). 
The default value is `2'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.LowerBoundFloat.minimal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>maximal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
LowerBoundFloat invariants whose cutoff was one of (-1,0,1,2). 
The default value is `-1'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.OneOfFloat.size</span></samp><dd>Positive integer.  Specifies the maximum set size for this type
of invariant (x is one of <code>size</code> items). 
The default value is `3'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.OneOfScalar.omit_hashcode_values_Simplify</span></samp><dd>Boolean.  If true, invariants describing hashcode-typed variables
as having any particular value will have an artificial value
substituted for the exact hashhode values.  The artificial values
will stay the same from run to run even if the actual hashcode
values change (as long as the OneOf invariants remain the same). 
If false, hashcodes will be formatted as the application of a
hashcode uninterpreted function to an integer representing the
bit pattern of the hashcode.  One might wish to omit the exact
values of the hashcodes because they are usually uninteresting;
this is the same reason they print in the native Daikon format,
for instance, as &lsquo;<samp><span class="samp">var has only one value</span></samp>&rsquo; rather than
&lsquo;<samp><span class="samp">var == 150924732</span></samp>&rsquo;. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.OneOfScalar.size</span></samp><dd>Positive integer.  Specifies the maximum set size for this type
of invariant (x is one of <code>size</code> items). 
The default value is `3'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.UpperBound.maximal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>minimal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
UpperBound invariants whose cutoff was one of (-1,0,1,2). 
The default value is `2'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.UpperBound.minimal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>maximal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
UpperBound invariants whose cutoff was one of (-1,0,1,2). 
The default value is `-1'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.UpperBoundFloat.maximal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>minimal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
UpperBoundFloat invariants whose cutoff was one of (-1,0,1,2). 
The default value is `2'.

     <br><dt><samp><span class="option">daikon.inv.unary.scalar.UpperBoundFloat.minimal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>maximal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
UpperBoundFloat invariants whose cutoff was one of (-1,0,1,2). 
The default value is `-1'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.CommonFloatSequence.hashcode_seqs</span></samp><dd>Boolean.  Set to true to consider common sequences over hashcodes (pointers). 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.CommonSequence.hashcode_seqs</span></samp><dd>Boolean.  Set to true to consider common sequences over hashcodes (pointers). 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltLowerBound.maximal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>minimal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
EltLowerBound invariants whose cutoff was one of (-1,0,1,2). 
The default value is `2'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltLowerBound.minimal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>maximal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
EltLowerBound invariants whose cutoff was one of (-1,0,1,2). 
The default value is `-1'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltLowerBoundFloat.maximal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>minimal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
EltLowerBoundFloat invariants whose cutoff was one of (-1,0,1,2). 
The default value is `2'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltLowerBoundFloat.minimal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>maximal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
EltLowerBoundFloat invariants whose cutoff was one of (-1,0,1,2). 
The default value is `-1'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltOneOf.omit_hashcode_values_Simplify</span></samp><dd>Boolean.  If true, invariants describing hashcode-typed variables
as having any particular value will have an artificial value
substituted for the exact hashhode values.  The artificial values
will stay the same from run to run even if the actual hashcode
values change (as long as the OneOf invariants remain the same). 
If false, hashcodes will be formatted as the application of a
hashcode uninterpreted function to an integer representing the
bit pattern of the hashcode.  One might wish to omit the exact
values of the hashcodes because they are usually uninteresting;
this is the same reason they print in the native Daikon format,
for instance, as &lsquo;<samp><span class="samp">var has only one value</span></samp>&rsquo; rather than
&lsquo;<samp><span class="samp">var == 150924732</span></samp>&rsquo;. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltOneOf.size</span></samp><dd>Positive integer.  Specifies the maximum set size for this type
of invariant (x is one of <code>size</code> items). 
The default value is `3'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltOneOfFloat.size</span></samp><dd>Positive integer.  Specifies the maximum set size for this type
of invariant (x is one of <code>size</code> items). 
The default value is `3'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltUpperBound.maximal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>minimal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
EltUpperBound invariants whose cutoff was one of (-1,0,1,2). 
The default value is `2'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltUpperBound.minimal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>maximal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
EltUpperBound invariants whose cutoff was one of (-1,0,1,2). 
The default value is `-1'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltUpperBoundFloat.maximal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>minimal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
EltUpperBoundFloat invariants whose cutoff was one of (-1,0,1,2). 
The default value is `2'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.EltUpperBoundFloat.minimal_interesting</span></samp><dd>Long integer.  Together with the corresponding
<code>maximal_interesting</code> parameter, specifies the
range of the computed constant that is &ldquo;interesting&rdquo; &mdash; the range
that should be reported.  For instance, setting
<code>minimal_interesting</code>
to -1 and <code>maximal_interesting</code>
to 2 would only permit output of
EltUpperBoundFloat invariants whose cutoff was one of (-1,0,1,2). 
The default value is `-1'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.OneOfFloatSequence.size</span></samp><dd>Positive integer.  Specifies the maximum set size for this type
of invariant (x is one of <code>size</code> items). 
The default value is `3'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.OneOfSequence.omit_hashcode_values_Simplify</span></samp><dd>Boolean.  If true, invariants describing hashcode-typed variables
as having any particular value will have an artificial value
substituted for the exact hashhode values.  The artificial values
will stay the same from run to run even if the actual hashcode
values change (as long as the OneOf invariants remain the same). 
If false, hashcodes will be formatted as the application of a
hashcode uninterpreted function to an integer representing the
bit pattern of the hashcode.  One might wish to omit the exact
values of the hashcodes because they are usually uninteresting;
this is the same reason they print in the native Daikon format,
for instance, as &lsquo;<samp><span class="samp">var has only one value</span></samp>&rsquo; rather than
&lsquo;<samp><span class="samp">var == 150924732</span></samp>&rsquo;. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.OneOfSequence.size</span></samp><dd>Positive integer.  Specifies the maximum set size for this type
of invariant (x is one of <code>size</code> items). 
The default value is `3'.

     <br><dt><samp><span class="option">daikon.inv.unary.sequence.SingleSequence.SeqIndexDisableAll</span></samp><dd>Boolean.  Set to true to disable all SeqIndex invariants
(SeqIndexIntEqual, SeqIndexFloatLessThan, etc).  This overrides the
settings of the individual SeqIndex enable configuration options. 
To disable only some options, the options must be disabled
individually. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.inv.unary.string.OneOfString.size</span></samp><dd>Positive integer.  Specifies the maximum set size for this type
of invariant (x is one of <code>size</code> items). 
The default value is `3'.

     <br><dt><samp><span class="option">daikon.inv.unary.stringsequence.EltOneOfString.size</span></samp><dd>Positive integer.  Specifies the maximum set size for this type
of invariant (x is one of <code>size</code> items). 
The default value is `3'.

     <br><dt><samp><span class="option">daikon.inv.unary.stringsequence.OneOfStringSequence.size</span></samp><dd>Positive integer.  Specifies the maximum set size for this type
of invariant (x is one of <code>size</code> items). 
The default value is `2'.

   </dl>

<div class="node">
<p><hr>
<a name="Options-to-enable%2fdisable-derived-variables"></a>
<a name="Options-to-enable_002fdisable-derived-variables"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Simplify-interface-configuration-options">Simplify interface configuration options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Other-invariant-configuration-parameters">Other invariant configuration parameters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#List-of-configuration-options">List of configuration options</a>

</div>

<h5 class="subsubsection">6.1.1.4 Options to enable/disable derived variables</h5>

<p><a name="index-derived-variables_002c-enabling_002fdisabling-95"></a>These options control whether Daikon looks for invariants involving certain forms of derived variables.  Also see <a href="#Variable-names">Variable names</a>.

     <dl>
<dt><samp><span class="option">daikon.derive.Derivation.disable_derived_variables</span></samp><dd>Boolean.  If true, Daikon will not create any derived variables. 
Derived variables, which are combinations of variables that appeared in
the program, like <code>array[index]</code> if <code>array</code> and
<code>index</code> appeared, can
increase the number of properties Daikon finds, especially over
sequences. However, derived variables increase Daikon's time and
memory usage, sometimes dramatically. If false, individual kinds of
derived variables can be enabled or disabled individually using
configuration options under &lsquo;<samp><span class="samp">daikon.derive</span></samp>&rsquo;. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceFloatIntersection.enabled</span></samp><dd>Boolean.  True iff SequenceFloatIntersection derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceFloatSubscript.enabled</span></samp><dd>Boolean.  True iff SequenceFloatSubscript derived variables should be
generated. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceFloatSubsequence.enabled</span></samp><dd>Boolean.  True iff SequenceFloatSubsequence derived variables
should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceFloatUnion.enabled</span></samp><dd>Boolean.  True iff SequenceFloatUnion derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceScalarIntersection.enabled</span></samp><dd>Boolean.  True iff SequenceScalarIntersection derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceScalarSubscript.enabled</span></samp><dd>Boolean.  True iff SequenceScalarSubscript derived variables should be
generated. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceScalarSubsequence.enabled</span></samp><dd>Boolean.  True iff SequenceScalarSubsequence derived variables
should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceScalarUnion.enabled</span></samp><dd>Boolean.  True iff SequenceScalarUnion derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceStringIntersection.enabled</span></samp><dd>Boolean.  True iff SequenceStringIntersection derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceStringSubscript.enabled</span></samp><dd>Boolean.  True iff SequenceStringSubscript derived variables should be
generated. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceStringSubsequence.enabled</span></samp><dd>Boolean.  True iff SequenceStringSubsequence derived variables
should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequenceStringUnion.enabled</span></samp><dd>Boolean.  True iff SequenceStringUnion derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequencesConcat.enabled</span></samp><dd>Boolean.  True iff SequencesConcat derived variables should be created. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequencesJoin.enabled</span></samp><dd>Boolean.  True iff SequencesJoin derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequencesJoinFloat.enabled</span></samp><dd>Boolean.  True iff SequencesJoin derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequencesPredicate.boolOnly</span></samp><dd>Boolean.  True if Daikon should only generate derivations on boolean
predicates. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequencesPredicate.enabled</span></samp><dd>Boolean.  True iff SequencesPredicate derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequencesPredicate.fieldOnly</span></samp><dd>Boolean.  True if Daikon should only generate derivations on fields
of the same data structure. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequencesPredicateFloat.boolOnly</span></samp><dd>Boolean.  True if Daikon should only generate derivations on boolean
predicates. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequencesPredicateFloat.enabled</span></samp><dd>Boolean.  True iff SequencesPredicate derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.binary.SequencesPredicateFloat.fieldOnly</span></samp><dd>Boolean.  True if Daikon should only generate derivations on fields
of the same data structure. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.derive.ternary.SequenceFloatArbitrarySubsequence.enabled</span></samp><dd>Boolean.  True iff SequenceFloatArbitrarySubsequence derived variables
should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.ternary.SequenceScalarArbitrarySubsequence.enabled</span></samp><dd>Boolean.  True iff SequenceScalarArbitrarySubsequence derived variables
should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.ternary.SequenceStringArbitrarySubsequence.enabled</span></samp><dd>Boolean.  True iff SequenceStringArbitrarySubsequence derived variables
should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.unary.SequenceInitial.enabled</span></samp><dd>Boolean.  True iff SequenceInitial derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.unary.SequenceInitialFloat.enabled</span></samp><dd>Boolean.  True iff SequenceInitial derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.unary.SequenceLength.enabled</span></samp><dd>Boolean.  True iff SequenceLength derived variables should be generated. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.derive.unary.SequenceMax.enabled</span></samp><dd>Boolean.  True iff SequencesMax derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.unary.SequenceMin.enabled</span></samp><dd>Boolean.  True iff SequenceMin derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.unary.SequenceSum.enabled</span></samp><dd>Boolean.  True iff SequenceSum derived variables should be generated. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.derive.unary.StringLength.enabled</span></samp><dd>Boolean.  True iff StringLength derived variables should be generated. 
The default value is `false'.

   </dl>

<div class="node">
<p><hr>
<a name="Simplify-interface-configuration-options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#General-configuration-options">General configuration options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Options-to-enable_002fdisable-derived-variables">Options to enable/disable derived variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#List-of-configuration-options">List of configuration options</a>

</div>

<h5 class="subsubsection">6.1.1.5 Simplify interface configuration options</h5>

<p><a name="index-Simplify-theorem-prover_002c-configuring-96"></a>The configuration options in this section are used to customize the interface to the Simplify theorem prover.  See the description of the <samp><span class="option">--suppress_redundant</span></samp> command-line option in <a href="#Options-to-control-invariant-detection">Options to control invariant detection</a>.

     <dl>
<dt><samp><span class="option">daikon.simplify.LemmaStack.print_contradictions</span></samp><dd>Boolean. Controls Daikon's response when inconsistent invariants
are discovered while running Simplify. If true, Daikon will print
an error message to the standard error stream listing the
contradictory invariants. This is mainly intended for debugging
Daikon itself, but can sometimes be helpful in tracing down other
problems. For more information, see the section on
troubleshooting contradictory invariants in the Daikon manual. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.simplify.LemmaStack.remove_contradictions</span></samp><dd>Boolean. Controls Daikon's response when inconsistent invariants
are discovered while running Simplify. If false, Daikon will give
up on using Simplify for that program point. If true, Daikon will
try to find a small subset of the invariants that cause the
contradiction and avoid them, to allow processing to
continue. For more information, see the section on
troubleshooting contradictory invariants in the Daikon manual. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.simplify.LemmaStack.synchronous_errors</span></samp><dd>Boolean. If true, ask Simplify to check a simple proposition
after each assumption is pushed, providing an opportunity to wait
for output from Simplify and potentially receive error messages
about the assumption. When false, long sequences of assumptions
may be pushed in a row, so that by the time an error message
arrives, it's not clear which input caused the error. Of course,
Daikon's input to Simplify isn't supposed to cause errors, so
this option should only be needed for debugging. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.simplify.Session.simplify_max_iterations</span></samp><dd>A non-negative integer, representing the largest number of
iterations for which Simplify should be allowed to run on any
single conjecture before giving up.  Larger values may cause
Simplify to run longer, but will increase the number
of invariants that can be recognized as redundant. The default
value is small enough to keep Simplify from running for more than
a few seconds on any one conjecture, allowing it to verify most
simple facts without getting bogged down in long searches. A
value of 0 means not to bound the number of iterations at all,
though see also the <code>simplify_timeout</code> parameter.. 
The default value is `1000'.

     <br><dt><samp><span class="option">daikon.simplify.Session.simplify_timeout</span></samp><dd>A non-negative integer, representing the longest time period (in
seconds) Simplify should be allowed to run on any single
conjecture before giving up.  Larger values may cause
Simplify to run longer, but will increase the number
of invariants that can be recognized as redundant.  Roughly
speaking, the time spent in Simplify will be bounded
by this value, times the number of invariants generated, though
it can be much less. A value of 0 means to not bound Simplify at
all by time, though also see the option
<code>simplify_max_iterations</code>. 
Beware that using this option might make Daikon's output depend
on the speed of the machine it's run on. 
The default value is `0'.

     <br><dt><samp><span class="option">daikon.simplify.Session.trace_input</span></samp><dd>Boolean. If true, the input to the Simplify theorem prover will
also be directed to a file named simplifyN.in (where N is a
number starting from 0) in the current directory. Simplify's
operation can then be reproduced with a command like
&lsquo;<samp><span class="samp">Simplify -nosc &lt;simplify0.in</span></samp>&rsquo;. 
This is intended primarily for debugging
when Simplify fails. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.simplify.Session.verbose_progress</span></samp><dd>Positive values mean to print extra indications as each candidate
invariant is passed to Simplify during the
<code>--suppress_redundant</code>
check.  If the value is 1 or higher, a hyphen will be printed when
each invariant is passed to Simplify, and then replaced by a
&lsquo;<samp><span class="samp">T</span></samp>&rsquo;
if the invariant was redundant,
&lsquo;<samp><span class="samp">F</span></samp>&rsquo; if it was not found to be,
and &lsquo;<samp><span class="samp">?</span></samp>&rsquo; if Simplify gave up because of a time limit. 
If the value
is 2 or higher, a &lsquo;<samp><span class="samp">&lt;</span></samp>&rsquo; or &lsquo;<samp><span class="samp">&gt;</span></samp>&rsquo;
will also be printed for each
invariant that is pushed onto or popped from from Simplify's
assumption stack. This option is mainly intended for debugging
purposes, but can also provide something to watch when Simplify
takes a long time. 
The default value is `0'.

   </dl>

<div class="node">
<p><hr>
<a name="General-configuration-options"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Simplify-interface-configuration-options">Simplify interface configuration options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#List-of-configuration-options">List of configuration options</a>

</div>

<h5 class="subsubsection">6.1.1.6 General configuration options</h5>

<p>This section lists miscellaneous configuration options for Daikon.

     <dl>
<dt><samp><span class="option">daikon.Daikon.calc_possible_invs</span></samp><dd>Boolean.  Just print the total number of possible invariants
and exit. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.Daikon.disable_splitting</span></samp><dd>Boolean.  Controls whether or not splitting based on the built-in
splitting rules is disabled.  The built-in rules look for implications
based on boolean return values and also when there are exactly two
exit points from a method. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.Daikon.enable_floats</span></samp><dd>Boolean.  Controls whether invariants are reported over floating-point
values. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.Daikon.guardNulls</span></samp><dd>If "always", then invariants are always guarded. 
If "never", then invariants are never guarded. 
If "missing", then invariants are guarded only for variables that
were missing ("can be missing") in the dtrace (the observed executions). 
<br><br>

     <p>Guarding means adding predicates that ensure that variables can be
dereferenced.  For instance, if <code>a</code> can be null &mdash; that is,
if <code>a.b</code> can be nonsensical &mdash; then the guarded version of
&lsquo;<samp><span class="samp">a.b == 5</span></samp>&rsquo;
is
&lsquo;<samp><span class="samp">(a != null) ==&gt; (a.b == 5)</span></samp>&rsquo;. 
<br><br>

     <p>(To do:  Some configuration option (maybe this one) should add guards for
other reasons that lead to nonsensical values (see <a href="#Variable-names">Variable names</a>).) 
<a name="index-nonsensical-values-for-variables_002c-guarding_002e-97"></a>The default value is `default'.

     <br><dt><samp><span class="option">daikon.Daikon.internal_check</span></samp><dd>When true, perform detailed internal checking. 
These are essentially additional, possibly costly assert statements. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.Daikon.output_conditionals</span></samp><dd>Boolean.  Controls whether conditional program points
are displayed. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.Daikon.ppt_perc</span></samp><dd>Integer. Percentage of program points to process.  All program points
are sorted by name, and all samples for
the first <code>ppt_perc</code> program points are processed. 
A percentage of 100 matches all program points. 
The default value is `100'.

     <br><dt><samp><span class="option">daikon.Daikon.print_sample_totals</span></samp><dd>Boolean.  Controls whether or not the total samples read and processed
are printed at the end of processing. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.Daikon.progress_delay</span></samp><dd>The amount of time to wait between updates of the progress
display, measured in milliseconds. A value of -1 means do not
print the progress display at all. 
The default value is `1000'.

     <br><dt><samp><span class="option">daikon.Daikon.progress_display_width</span></samp><dd>The number of columns of progress information to display. In many
Unix shells, this can be set to an appropriate value by
&lsquo;<samp><span class="samp">--config_option daikon.Daikon.progress_display_width=$COLUMNS</span></samp>&rsquo;. 
The default value is `80'.

     <br><dt><samp><span class="option">daikon.Daikon.quiet</span></samp><dd>Boolean.  Controls whether or not processing information is printed out. 
Setting this variable to true also automatically sets
<code>progress_delay</code> to -1. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.Daikon.show_stack_trace</span></samp><dd>If true, show stack traces for errors such as file format errors. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.Daikon.suppressSplitterErrors</span></samp><dd>When true compilation errors during splitter file generation
will not be reported to the user. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.Daikon.undo_opts</span></samp><dd>Boolean.  Controls whether the Daikon optimizations (equality
sets, suppressions) are undone at the end to create a more
complete set of invariants.  Output does not include
conditional program points, implications, reflexive and
partially reflexive invariants. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.Daikon.use_dynamic_constant_optimization</span></samp><dd>Whether to use the dynamic constants optimization.  This
optimization doesn't instantiate invariants over constant
variables (i.e., that that have only seen one value).  When the
variable receives a second value, invariants are instantiated and
are given the sample representing the previous constant value. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.Debug.logDetail</span></samp><dd>Determines whether or not detailed info (such as from
<code>add_modified</code>) is printed. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.Debug.showTraceback</span></samp><dd>Determines whether or not traceback information is printed for each
call to log. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.DynamicConstants.OneOf_only</span></samp><dd>Boolean. If true only create OneOf invariants for variables that
are constant for the entire run.  If false, all possible invariants
are created between constants.  Note that setting this to true only
fails to create invariants between constants.  Invariants between
constants and non-constants are created regardless.

     <p>A problem occurs with merging when this is turned on.  If a var_info
is constant at one child slice, but not constant at the other child
slice, interesting invariants may not be merged because they won't
exist on the slice with the constant.  This is thus currently
defaulted to false. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.FileIO.add_changed</span></samp><dd>Boolean.  When false, set modbits to 1 iff the printed
representation has changed.  When true, set modbits to 1 if the
printed representation has changed; leave other modbits as is. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.FileIO.check_bb_connections</span></samp><dd>If true, check all of the basic blocks that make up a function
to ensure that there is a path from function entry to the block. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.FileIO.continue_after_file_exception</span></samp><dd>Boolean.  When true, suppress exceptions related to file reading. 
This permits Daikon to continue even if there is a malformed trace
file.  Use this with care:  in general, it is better to fix the
problem that caused a bad trace file, rather than to suppress the
exception. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.FileIO.count_lines</span></samp><dd>Boolean. When false, don't count the number of lines in the dtrace file
before reading.  This will disable the percentage progress printout. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.FileIO.dtrace_line_count</span></samp><dd>Long integer. If non-zero, this value will be used as the number
of lines in (each) dtrace file input for the purposes of the
progress display, and the counting of the lines in the file will
be suppressed. 
The default value is `0'.

     <br><dt><samp><span class="option">daikon.FileIO.ignore_missing_enter</span></samp><dd>When true, just ignore exit ppts that don't have a matching enter
ppt rather than exiting with an error.  Unmatched exits can occur
if only a portion of a dtrace file is processed. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.FileIO.max_line_number</span></samp><dd>Integer.  Maximum number of lines to read from the dtrace file.  If
0, reads the entire file. 
The default value is `0'.

     <br><dt><samp><span class="option">daikon.FileIO.merge_basic_blocks</span></samp><dd>If true, variables from basic blocks which predominate a basic block X
will be included when X is processed.  This allows Daikon to find
invariants between variables in different program points (basic blocks
in this case). 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.FileIO.read_samples_only</span></samp><dd>Boolean.  When true, only read the samples, but don't process them. 
Used to gather timing information. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.FileIO.rm_stack_dups</span></samp><dd>If true, modified all ppt names to remove duplicate routine
names within the ppt name.  This is used when a stack trace
(of active methods) is used as the ppt name.  The routine names
must be separated by vertical bars (|). 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.FileIO.unmatched_procedure_entries_quiet</span></samp><dd>Boolean.  When true, don't print a warning about unmatched procedure
entries, which are ignored by Daikon (unless the &ndash;nohierarchy switch
is provided). 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.FileIO.verbose_unmatched_procedure_entries</span></samp><dd>Boolean.  If true, prints the unmatched procedure entries
verbosely. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.PptCombined.asm_path_name</span></samp><dd>If non-null, we will compute redundant binary variables
when creating a CombinedProgramPoint, using
the assembly information in the file specified. 
The default value is `null'.

     <br><dt><samp><span class="option">daikon.PptCombined.rvars_file</span></samp><dd>If redundant variables are being computed, the results
of the redundancy analysis are printed to this stream. 
See dkconfig_asm_path_name above. 
The default value is `null'.

     <br><dt><samp><span class="option">daikon.PptRelation.enable_object_user</span></samp><dd>Boolean.  Controls whether the object-user relation is created in the
variable hierarchy. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.PptSliceEquality.set_per_var</span></samp><dd>If true, create one equality set for each variable. 
This has the effect of turning
the equality optimization off, without actually removing the sets
themselves (which are presumed to exist in many parts of the code). 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.PptSplitter.dummy_invariant_level</span></samp><dd>Integer. A value of zero indicates that DummyInvariant objects should
not be created. A value of one indicates that dummy invariants
should be created only when no suitable condition was found in
the regular output. A value of two indicates that dummy
invariants should be created for each splitting condition. 
The default value is `0'.

     <br><dt><samp><span class="option">daikon.PptSplitter.split_bi_implications</span></samp><dd>Split bi-implications into two separate invariants. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.PptTopLevel.pairwise_implications</span></samp><dd>Boolean.  If true, create implications for all pairwise
combinations of conditions, and all pairwise combinations of exit
points.  If false, create implications for only the first
two conditions, and create implications only if there are
exactly two exit points. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.PptTopLevel.remove_merged_invs</span></samp><dd>Remove invariants at lower program points when a matching invariant is
created at a higher program point. For experimental purposes only. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.PrintInvariants.old_array_names</span></samp><dd>In the new decl format, print array names without as 'a[]' as
opposed to 'a[..]'  This creates names that are more compatible
with the old output.  This option has no effect in the old decl
format. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.PrintInvariants.print_all</span></samp><dd>If true, print all invariants without any filtering. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.PrintInvariants.print_inv_class</span></samp><dd>Print invariant classname with invariants in output of
<code>format()</code> method, normally used only for debugging output
rather than ordinary printing of invariants. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.PrintInvariants.remove_post_vars</span></samp><dd>If true, remove as many variables as possible that need to be indicated
as 'post'.  Post variables occur when the subscript for a derived
variable with an orig sequence is not orig.  For example: orig(a[post(i)])
An equivalent expression involving only orig variables is substitued
for the post variable when one exists. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.PrintInvariants.replace_prestate</span></samp><dd>This option must be given with "&ndash;format Java" option.

     <p>Instead of outputting prestate expressions as "\old(E)" within an
invariant, output a variable names (e.g. `v1'). At the end of
each program point, output the list of variable-to-expression
mappings. For example: with this option set to false, a program
point might print like this:

     <p>&lt;pre&gt;
foo.bar.Bar(int):::EXIT
\old(capacity) == sizeof(this.theArray)
&lt;/pre&gt;

     <p>With the option set to true, it would print like this:

     <p>&lt;pre&gt;
foo.bar.Bar(int):::EXIT
v0 == sizeof(this.theArray)
prestate assignment: v0=capacity
&lt;/pre&gt;
The default value is `true'.

     <br><dt><samp><span class="option">daikon.PrintInvariants.static_const_infer</span></samp><dd>This enables a different way of treating static constant variables. 
They are not created into invariants into slices.  Instead, they are
examined during print time.  If a unary invariant contains a value
which matches the value of a static constant varible, the value
will be replaced by the name of the variable, "if it makes sense". 
For example, if there is a static constant variable a = 1.  And there
exists an invariant x &lt;= 1, x &lt;= a would be the result printed. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.PrintInvariants.true_inv_cnt</span></samp><dd>If true, print the total number of true invariants.  This includes
invariants that are redundant and would normally not be printed
or even created due to optimizations. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.ProglangType.convert_to_signed</span></samp><dd>If true, treat 32 bit values whose high bit is on, as a negative
number (rather than as a 32 bit unsigned). 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.VarInfo.constant_fields_simplify</span></samp><dd>If true, the treat static constants (such as MapQuick.GeoPoint.FACTOR)
as fields within an object rather than as a single name.  Not correct,
but used to obtain compatibility with VarInfoName. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.VarInfo.declared_type_comparability</span></samp><dd>If true, then variables are only considered comparable if they
are declared with the same type.  For example, java.util.List
is not comparable to java.util.ArrayList and float is not
comparable to double.  This may miss valid invariants, but
significant time can be saved and many variables with
different declared types are not comparable (e.g., java.util.Date
and java.util.ArrayList). 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.chicory.DaikonVariableInfo.constant_infer</span></samp><dd>Enable experimental techniques on static constants. 
The default value is `false'.

     <br><dt><samp><span class="option">daikon.split.ContextSplitterFactory.granularity</span></samp><dd>Enumeration (integer).  Specifies the granularity to use for
callsite splitter processing.  0 is line-level granularity; 1 is
method-level granularity; 2 is class-level granularity. 
The default value is `1'.

     <br><dt><samp><span class="option">daikon.split.SplitterFactory.compile_timeout</span></samp><dd>Positive integer.  Specifies the Splitter compilation timeout, in
seconds, after which the compilation process is terminated and
retried, on the assumption that it has hung. 
The default value is `6'.

     <br><dt><samp><span class="option">daikon.split.SplitterFactory.compiler</span></samp><dd>String.  Specifies which Java compiler is used to compile
Splitters.  This can be the full path name or whatever is used on
the commandline. 
The default value is `javac'.

     <br><dt><samp><span class="option">daikon.split.SplitterFactory.delete_splitters_on_exit</span></samp><dd>Boolean. Specifies whether or not the temporary Splitter files
should be deleted on exit. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.split.SplitterList.all_splitters</span></samp><dd>Boolean.  Enables indiscriminate splitting
(see Daikon manual, <a href="#Indiscriminate-splitting">Indiscriminate splitting</a>,
for an explanation of this technique). 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.suppress.NIS.enabled</span></samp><dd>Boolean.  If true, enable non-instantiating suppressions. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.suppress.NIS.hybrid_threshhold</span></samp><dd>Int.  Less and equal to this number means use the falsified method in
the hybrid method of processing falsified invariants, while greater
than this number means use the antecedent method.  Empirical data shows that
number should not be more than 10000. 
The default value is `2500'.

     <br><dt><samp><span class="option">daikon.suppress.NIS.skip_hashcode_type</span></samp><dd>Boolean.  If true, skip variables of file rep type hashcode when creating
invariants over constants in the antecedent method. 
The default value is `true'.

     <br><dt><samp><span class="option">daikon.suppress.NIS.suppression_processor</span></samp><dd>Specifies the algorithm that NIS uses to process suppressions. 
Possible selections are 'HYBRID', 'ANTECEDENT', and 'FALSIFIED'. 
The default is the hybrid algorithm which uses the falsified
algorithm when only a small number of suppressions need to be processed
and the antecedent algorithm when a large number of suppressions
are processed. 
The default value is `HYBRID'.

     <br><dt><samp><span class="option">daikon.suppress.NIS.suppressor_list</span></samp><dd>Boolean.  If true, use the specific list of suppressor related
invariant prototypes when creating constant invariants in the
antecedent method. 
The default value is `true'.

   </dl>

<!-- END AUTO-GENERATED CONFIG OPTIONS LISTING -->
<div class="node">
<p><hr>
<a name="Conditional-invariants"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Enhancing-conditional-invariant-detection">Enhancing conditional invariant detection</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Configuration-options">Configuration options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enhancing-Daikon-output">Enhancing Daikon output</a>

</div>

<h3 class="section">6.2 Conditional invariants and implications</h3>

<p><a name="index-splitting-98"></a><a name="index-splitting-condition-99"></a><a name="index-conditional-invariant-100"></a><a name="index-invariant_002c-conditional-101"></a><a name="index-implication-invariant-102"></a><a name="index-invariant_002c-implication-103"></a>
Conditional invariants are invariants that are true only part of the time. 
For instance, the postcondition for the absolute value procedure is
<pre class="example">     if arg &lt; 0
       then return == -arg
       else return == arg
</pre>
   <p class="noindent">The invariant <code>return == -arg</code> is a conditional invariant because
it depends on the predicate <code>arg &lt; 0</code> being true.  An
<em>implication</em> is a compound invariant that includes both the
predicate and the conditional invariant (also called the consequent).

   <p><a name="index-context_002dsensitive-invariant-104"></a><a name="index-call_002dsite_002ddependent-invariant-105"></a>
Another type of implication is a <i>context-sensitive</i> invariant &mdash; a
fact about method A that is true only when A is called by method B, but
not true in general about A.  Implications can be used to construct
context-sensitive invariants:  set a variable that depends on the call
site, then compute an implication whose predicate tests that variable. 
For an example, see the paper &ldquo;Selecting, refining, and evaluating
predicates for program analysis&rdquo;
(<a href="http://groups.csail.mit.edu/pag/daikon/pubs/predicates-tr914-abstract.html">http://groups.csail.mit.edu/pag/daikon/pubs/predicates-tr914-abstract.html</a>).

   <p>Daikon must be supplied with the predicate for an implication.  Daikon has
certain built-in predicates that it uses for finding conditional invariants;
examples are which return statement was executed in a procedure and whether a
boolean procedure returns true or false.  Additionally, Daikon can read
predicates from a file called a splitter info (<samp><span class="file">.spinfo</span></samp>) file and find
implications based on those predicates.  The splitter info file can be produced
automatically, such as by static analysis of the program using the CreateSpinfo
and CreateSpinfoC programs or by cluster analysis of the
traced values in the data trace file.  Details of these techniques and usage
guides can be found in <a href="#Enhancing-conditional-invariant-detection">Enhancing conditional invariant detection</a>.  Users
can also create splitter info files by hand or manually augment
automatically-created ones.

   <p>To detect conditional invariants and implications:
     <ol type=1 start=1>
<li>Create the splitter info file, either automatically or by hand. 
<li>Run Daikon with the <samp><span class="file">.spinfo</span></samp> file as one of its arguments. 
(The order of arguments does not matter.) 
For example,
     <pre class="example">          java daikon.Daikon Foo.decls Foo.spinfo Foo.dtrace
</pre>
     </ol>

   <p>The term &ldquo;splitter&rdquo; comes from Daikon's technique for detecting
implications and conditional invariants.  For each predicate, Daikon
creates two conditional program points &mdash; one for program executions
that satisfy the condition and one for those that don't &mdash; and splits
the data trace into two parts.  Invariant detection is then performed
on the conditional program points (that is, the parts of the data
trace) separately and any invariants detected are reported as
conditional invariants (as implications).

   <p>To be precise, we say that an invariant holds exclusively if it is
discovered on one side of a split, and its negation is discovered on
the opposite side.  Daikon creates conditional invariants whose
predicates are invariants that hold exclusively on one side of a
split, and whose consequents are invariants that hold on that side of
the split but not on the un-split program point.  If Daikon finds
multiple exclusive conditions, it will create biconditional (&ldquo;if and
only if&rdquo;) invariants between the equivalent conditions.  Within the
context of the program, each of the exclusive conditions is equivalent
to the splitting condition.  In particular, if both the splitting
condition and its negation are within the grammar of invariants that
Daikon detects, the splitting condition may appear as the predicate of
the generated conditional invariants.  On the other hand, if other
equivalent conditions are found, or if the splitting condition is not
expressible in Daikon's grammar, it might not appear in the generated
implications.

   <p><a name="index-dummy-invariant-106"></a><a name="index-invariant_002c-dummy-107"></a>
In some cases, the default policy of selecting predicates from
Daikon's output may be insufficient.  For instance, Daikon might not
detect any invariant equivalent to the splitting condition, if it is
sufficiently complex or application-specific.  In such situations,
Daikon can also use the splitting condition itself as the predicate of
an implication, as what is called a &ldquo;dummy invariant&rdquo;.  A &ldquo;dummy
invariant&rdquo; is one whose meaning is not dealt with directly by Daikon;
instead Daikon knows only how to print the invariant in its output. 
When a tool or a user writes a splitter info file, the file can
specify a way to print the condition represented by the splitter in
any of Daikon's output formats.  If the use of dummy invariants is
enabled, invariants with the supplied output formats will be used as
the predicates of conditional invariants.

   <p>To use dummy invariants, a condition's formatting must be specified in
the splitter info file, and the configuration option
<samp><span class="option">daikon.PptTopLevel.dummy_invariant_level</span></samp> must be set to a
non-zero value (see <a href="#List-of-configuration-options">List of configuration options</a>).

<ul class="menu">
<li><a accesskey="1" href="#Splitter-info-file">Splitter info file</a>
<li><a accesskey="2" href="#Indiscriminate-splitting">Indiscriminate splitting</a>
<li><a accesskey="3" href="#Example-splitter-info-file">Example splitter info file</a>
</ul>

<div class="node">
<p><hr>
<a name="Splitter-info-file"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Indiscriminate-splitting">Indiscriminate splitting</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Conditional-invariants">Conditional invariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Conditional-invariants">Conditional invariants</a>

</div>

<h4 class="subsection">6.2.1 Splitter info file</h4>

<p><a name="index-splitter-info-file-108"></a><a name="index-g_t_002espinfo-file-109"></a><a name="index-spinfo-file-110"></a>
A splitter info file contains the conditions that Daikon should use to
create conditional invariants.  Each section in the <samp><span class="file">.spinfo</span></samp>
file consists of a sequence of non-blank lines; sections are separated
by blank lines.  There are two types of sections:  program point
sections and replacement sections. 
See <a href="#Example-splitter-info-file">Example splitter info file</a>, for an example splitter info file.

<ul class="menu">
<li><a accesskey="1" href="#Program-point-sections">Program point sections</a>
<li><a accesskey="2" href="#Replacement-sections">Replacement sections</a>
</ul>

<div class="node">
<p><hr>
<a name="Program-point-sections"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Replacement-sections">Replacement sections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Splitter-info-file">Splitter info file</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Splitter-info-file">Splitter info file</a>

</div>

<h5 class="subsubsection">6.2.1.1 Program point sections</h5>

<p>Program point sections have a line specifying a program point name
followed by lines specifying the condition(s) associated with that
program point, each condition on its own line.  Additional information
about a condition may be specified on indented lines.  For example, a
typical entry is

<pre class="example">     PPT_NAME <var>pptname</var>
     <var>condition1</var>
     <var>condition2</var>
         DAIKON_FORMAT <var>output string</var>
         ESC_FORMAT <var>output string</var>
     <var>condition3</var>
     ...
</pre>
   <p class="noindent"><var>pptname</var> can be any string that matches a part of the desired
program point name as printed in the decls file.  In finding matching
program points, Daikon uses the first program point that matches
<var>pptname</var>.  Caution is necessary when dealing with method names
that are prefixes of other method names.  For instance, if the class
<code>List</code> has methods <code>add</code> and <code>addAll</code>, specifying
&lsquo;<samp><span class="samp">PPT_NAME List.add</span></samp>&rsquo; might select either method, depending on
which was encountered first.  Instead writing &lsquo;<samp><span class="samp">PPT_NAME
List.add(</span></samp>&rsquo; will match only the <code>add</code> method.

   <p>Each condition is a Java expression of boolean type.  All variables
that appear in the condition must also appear in the declaration of
the program point in the <samp><span class="file">.decls</span></samp> file.  (In other words, all the
variables must be in scope at the program point(s) where the Splitter
is intended to operate.)  The automatically generated Splitter source
code fails to compile (but Daikon proceeds without it) if a variable
name in a condition is not found at the matching program point.

   <p>Indented lines beginning with <samp><span class="option">DAIKON_FORMAT</span></samp>,
<samp><span class="option">JAVA_FORMAT</span></samp>, <samp><span class="option">ESC_FORMAT</span></samp>, or <samp><span class="option">SIMPLIFY_FORMAT</span></samp>
may be used to specify how to represent the
condition specified by the splitter in each of Daikon's output
formats, to allow the splitting condition to be used as a dummy
invariant.

<div class="node">
<p><hr>
<a name="Replacement-sections"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Program-point-sections">Program point sections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Splitter-info-file">Splitter info file</a>

</div>

<h5 class="subsubsection">6.2.1.2 Replacement sections</h5>

<p>Ordinarily, a splitting condition may not invoke user-defined methods,
because when Daikon reads data trace files, it does not have access to the
program source.  A replace section of the splitter info file can specify
the bodies of methods, permitting conditions to invoke those methods.  The
format is as follows:
<pre class="example">     REPLACE
     <var>procedure1</var>
     <var>replacement1</var>
     <var>procedure2</var>
     <var>replacement2</var>
     ...
</pre>
   <p class="noindent">where <var>replacementi</var> is a Java expression for the body
of <var>procedurei</var>.  In each condition, Daikon replaces procedure
calls by their replacements.  A replace section may appear anywhere in
the splitter info file.

<div class="node">
<p><hr>
<a name="Indiscriminate-splitting"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Example-splitter-info-file">Example splitter info file</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Splitter-info-file">Splitter info file</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Conditional-invariants">Conditional invariants</a>

</div>

<h4 class="subsection">6.2.2 Indiscriminate splitting</h4>

<p>Ordinarily, each condition in an <samp><span class="file">.spinfo</span></samp> file gives rise to
conditional invariants only at the program point in whose section the
condition appears.  Alternately, every condition can be used at every
program point, regardless of where in the <samp><span class="file">.spinfo</span></samp> file the
condition appeared; this latter approach is called &ldquo;indiscriminate
splitting&rdquo;.

   <p>The advantage of indiscriminate splitting is that a condition that is
useful at one program point may also be useful at another &mdash; if the
same variables are in scope or other variables of the same name are in
scope.  The disadvantage of indiscriminate splitting is that often the
condition is not applicable everywhere, and when it is, it may not be
useful at all such locations, so checking for many conditional
invariants may slow down Daikon without a corresponding benefit. 
Indiscriminate splitting can result in Daikon attempting
to use many conditions that are inappropriate at certain program
points, for instance because the program point does not have (in
scope) all the variables that are used in the condition.  For example,
the condition <code>myArray.length == x</code> is inapplicable at a program
point if either of <code>myArray</code> and <code>x</code> is not in scope at that
program point.  In this case, Daikon prints a warning message and
proceeds, using conditions wherever they are valid.

   <p>By default, Daikon uses indiscriminate splitting.  To use
non-indiscriminate splitting, place the following line in a file that is
passed to Daikon via the <samp><span class="option">--config</span></samp> flag
(see <a href="#Daikon-configuration-options">Daikon configuration options</a>):
<pre class="example">     daikon.split.SplitterList.all_splitters = false
</pre>
   <div class="node">
<p><hr>
<a name="Example-splitter-info-file"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Indiscriminate-splitting">Indiscriminate splitting</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Conditional-invariants">Conditional invariants</a>

</div>

<h4 class="subsection">6.2.3 Example splitter info file</h4>

<p>Below is an implementation of a simple Queue for positive integers and
a corresponding <samp><span class="file">.spinfo</span></samp> file.  The splitter info file is like
the one that <samp><span class="command">CreateSpinfo</span></samp> would create for that class, but
also demonstrates some other features.

<ul class="menu">
<li><a accesskey="1" href="#Example-class">Example class</a>
<li><a accesskey="2" href="#Resulting-_002espinfo-file">Resulting .spinfo file</a>
</ul>

<div class="node">
<p><hr>
<a name="Example-class"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Resulting-_002espinfo-file">Resulting .spinfo file</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Example-splitter-info-file">Example splitter info file</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Example-splitter-info-file">Example splitter info file</a>

</div>

<h5 class="subsubsection">6.2.3.1 Example class</h5>

<pre class="smallexample">     class simpleStack {
     
       private int[] myArray;
       private int currentSize;
     
       public simpleStack(int capacity) {
         myArray = new int[capacity];
         currentSize = 0;
       }
     
       /** Adds an element to the back of the stack, if the stack is
         * not full.
         * Returns true if this succeeds, false otherwise.  **/
       public String push(int x) {
         if ( !isFull() &amp;&amp; x &gt;= 0) {
           myArray[currentSize] = x;
           currentSize++;
           return true;
         } else {
           return false;
         }
       }
     
       /** Returns the most recently inserted stack element.
         * Returns -1 if the stack is empty. **/
       public int pop() {
         if ( !isEmpty() ) {
           currentSize--;
           return myArray[currentSize];
         } else {
           return -1;
         }
       }
     
      /** Returns true if the stack is empty, false otherwise. **/
       private boolean isEmpty() {
         return (currentSize == 0);
       }
     
       /** Returns true if the stack is full, false otherwise. **/
       private boolean isFull() {
         return (currentSize == myArray.length);
       }
     }
</pre>
<div class="node">
<p><hr>
<a name="Resulting-.spinfo-file"></a>
<a name="Resulting-_002espinfo-file"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Example-class">Example class</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Example-splitter-info-file">Example splitter info file</a>

</div>

<h5 class="subsubsection">6.2.3.2 Resulting .spinfo file</h5>

<pre class="smallexample">     REPLACE
     isFull()
     currentSize == myArray.length
     isEmpty()
     currentSize == 0
     
     PPT_NAME  simpleStack.push
     !isFull() &amp;&amp; x &gt;= 0
         DAIKON_FORMAT !isFull() and x &gt;= 0
         SIMPLIFY_FORMAT (AND (NOT (isFull this)) (&gt;= x 0))
     
     PPT_NAME  simpleStack.pop
     !isEmpty()
     
     PPT_NAME  simpleStack.isFull
     currentSize == myArray.length - 1
     
     PPT_NAME  simpleStack.isEmpty
     currentSize == 0
</pre>
<div class="node">
<p><hr>
<a name="Enhancing-conditional-invariant-detection"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Dynamic-abstract-type-inference-_0028DynComp_0029">Dynamic abstract type inference (DynComp)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Conditional-invariants">Conditional invariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enhancing-Daikon-output">Enhancing Daikon output</a>

</div>

<h3 class="section">6.3 Enhancing conditional invariant detection</h3>

<p>The built-in mechanisms (see <a href="#Conditional-invariants">Conditional invariants</a>) have
limitations in the invariants they can find.  By supplying splitting
conditions to Daikon via a splitter info file, the user can infer more
conditional invariants.  To ease this task, there are two methods to
automatically create splitter info files for use by Daikon.

<ul class="menu">
<li><a accesskey="1" href="#Static-analysis-for-splitters">Static analysis for splitters</a>
<li><a accesskey="2" href="#Cluster-analysis-for-splitters">Cluster analysis for splitters</a>
<li><a accesskey="3" href="#Random-selection-for-splitters">Random selection for splitters</a>
</ul>

<div class="node">
<p><hr>
<a name="Static-analysis-for-splitters"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Cluster-analysis-for-splitters">Cluster analysis for splitters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Enhancing-conditional-invariant-detection">Enhancing conditional invariant detection</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enhancing-conditional-invariant-detection">Enhancing conditional invariant detection</a>

</div>

<h4 class="subsection">6.3.1 Static analysis for splitters</h4>

<p><a name="index-splitting-conditions_002c-static-analysis-111"></a><a name="index-static-analysis-for-splitters-112"></a><a name="index-CreateSpinfo-113"></a><a name="index-CreateSpinfoC-114"></a>
In static analysis, all explicitly stated boolean statements in the program
source are extracted and used as splitting conditions.  The assumption is that
conditions that are explicitly tested in the program are likely to affect the
program's behavior and could lead to useful conditional invariants.

   <p>The CreateSpinfo program takes Java source code as input and creates a
splitter info file for each input file; for instance,
<pre class="example">     java daikon.tools.jtb.CreateSpinfo Foo.java Bar.java
</pre>
   <p class="noindent">creates the splitter info files <samp><span class="file">Foo.spinfo</span></samp> and
<samp><span class="file">Bar.spinfo</span></samp>. 
Given an <samp><span class="option">-o </span><var>filename</var></samp> argument, CreateSpinfo puts all the
splitters in the specified file instead. 
The resulting splitter info file(s) contains each
boolean expression that appears in the source code.  The conditional
statements that the programmer used in the source code are likely to
have important semantic properties.  This simple heuristic of using
these conditional statements as predicates for conditional invariant
detection is often quite effective.

   <p>If you get an error such as
<pre class="example">     jtb.ParseException: Encountered ";" at line 253, column 8.
     Was expecting one of: "abstract" ...
</pre>
   <p class="noindent">then you may have encountered a bug in the JTB library on which
CreateSpinfo is built.  It does not permit empty declarations in a
class body.  Remove the extra semicolon in your Java file (at the
indicated position) and re-rerun CreateSpinfo.

   <p>The <samp><span class="command">CreateSpinfoC</span></samp> program performs the same function, for
C source code.  It can only be run on postprocessed source
files&mdash;that is, source files contain no CPP commands.  CPP commands
are lines starting with &lsquo;<samp><span class="samp">#</span></samp>&rsquo;, such as &lsquo;<samp><span class="samp">#include</span></samp>&rsquo;.  To
expand CPP commands into legal C, run either <samp><span class="command">cpp -P</span></samp> or
<samp><span class="command">gcc -P -E</span></samp>.  For instance, here is how you could use it.
<pre class="example">     cpp -P foo.c foo.c-expanded
     cpp -P bar.c bar.c-expanded
     java daikon.tools.jtb.CreateSpinfoC \
          foo.c-expanded bar.c-expanded
</pre>
   <p class="noindent">If you get an error such as
<pre class="example">     ... Lexical error at line 5, column 1.
     Encountered: "#" (35), after : ""
</pre>
   <p class="noindent">then you forgot to run CPP before running CreateSpinfoC.

<div class="node">
<p><hr>
<a name="Cluster-analysis-for-splitters"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Random-selection-for-splitters">Random selection for splitters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Static-analysis-for-splitters">Static analysis for splitters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enhancing-conditional-invariant-detection">Enhancing conditional invariant detection</a>

</div>

<h4 class="subsection">6.3.2 Cluster analysis for splitters</h4>

<p><a name="index-splitting-conditions_002c-cluster-analysis-115"></a><a name="index-cluster-analysis-for-splitters-116"></a><a name="index-runcluster_002epl-program-117"></a>
Cluster analysis is a statistical method that finds groups or clusters
in data.  The clusters may indicate conditional properties in the
program.  A conditional property at a program point separates the data
into those that satisfy it and those that do not, and conditional
invariants can be induced by clustering.  Any invariant that is
discovered over one cluster but not over another is a conditional
invariant&mdash;the predicate for the conditional invariant being
membership in the cluster in which the invariant was found.  The
cluster analysis mechanism finds clusters in the data trace file,
infers invariants over any clusters that it finds, and writes these
invariants into a splitter info file for conditional invariant
detection.

   <p>To find splitting conditions using cluster analysis, run the
<samp><span class="command">runcluster.pl</span></samp> program (found in the <samp><span class="file">$DAIKONDIR/bin</span></samp>
directory) in the following way:
<pre class="example">     runcluster.pl [<var>options</var>] <var>dtrace_file ...</var> <var>decls_files ...</var>
</pre>
   <p>The <var>options</var> are:
     
<a name="index-kmeans-cluster-analysis-118"></a>
<a name="index-hierarchical-cluster-analysis-119"></a>
<a name="index-xm-cluster-analysis-120"></a>
<dl><dt><samp><span class="option">-a </span><var>ALG</var></samp><dt><samp><span class="option">--algorithm </span><var>ALG</var></samp><dd><var>ALG</var> specifies a clustering algorithm. 
Current options are &lsquo;<samp><span class="samp">km</span></samp>&rsquo; (for kmeans), &lsquo;<samp><span class="samp">hierarchical</span></samp>&rsquo;,
and &lsquo;<samp><span class="samp">xm</span></samp>&rsquo; (for xmeans).  The default is &lsquo;<samp><span class="samp">xm</span></samp>&rsquo;.

     <br><dt><samp><span class="option">-k</span></samp><dd>The number of clusters to use (for algorithms which require
this input, which is everything except xmeans).  The default is 4.

     <br><dt><samp><span class="option">--keep</span></samp><dd>Don't delete the temporary files created by the clustering
process.  This is a debugging flag. 
</dl>

   <p>The <samp><span class="command">runcluster.pl</span></samp> script currently supports three clustering
programs.  They are implementations of the kmeans algorithm,
hierarchical clustering and the xmeans algorithm (kmeans algorithm
with efficient discovery of the number of clusters).  The kmeans and
hierarchical clustering tools are provided in the Daikon
distribution.  The xmeans code and executable are publicly available at
<a href="http://www.cs.cmu.edu/~dpelleg/kmeans.html">http://www.cs.cmu.edu/~dpelleg/kmeans.html</a> (fill in the license
form and mail it in).

<div class="node">
<p><hr>
<a name="Random-selection-for-splitters"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Cluster-analysis-for-splitters">Cluster analysis for splitters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enhancing-conditional-invariant-detection">Enhancing conditional invariant detection</a>

</div>

<h4 class="subsection">6.3.3 Random selection for splitters</h4>

<p><a name="index-splitting-conditions_002c-random-selection-121"></a><a name="index-random-selection-for-splitters-122"></a><a name="index-TraceSelect-tool-123"></a>
Random selection can create representative samples of a data set with
the added benefit of finding conditional properties and eliminating
outliers.  Given traced data, the TraceSelect tool creates several
small subsets of the data by randomly selecting parts of the original
trace file.  Any invariant that is discovered in the smaller samples but
not found over the entire data is a conditional invariant.

   <p>To find splitting conditions using random selection, run the
<samp><span class="command">daikon.tools.TraceSelect</span></samp> program in the following way:
<pre class="example">     java daikon.tools.TraceSelect <var>num_reps</var> <var>sample_size</var> [<var>options</var>] \
         <var>dtrace_file</var> <var>decls_files ...</var> [<var>daikon_options</var>]
</pre>
   <p><var>num_reps</var> is the number of subsets to create, and <var>sample_size</var> is the
number of invocations to collect for each method.

   <p>The <var>daikon_options</var> are the same options that can be provided to the
daikon.Daikon program.

   <p>The <var>options</var> for TraceSelect are:
     <dl>
<dt><samp><span class="option">-NOCLEAN</span></samp><dd>Don't delete the temporary trace samples created by the random
selection process.  This can help for debugging or for using the tool
solely to create trace samples instead of calculating invariants over
the samples.

     <br><dt><samp><span class="option">-INCLUDE_UNRETURNED</span></samp><dd>Allows random selection to choose method invocations that entered the
method successfully but did not exit normally; either from a thrown
Exception or abnormal termination.

     <br><dt><samp><span class="option">-DO_DIFFS</span></samp><dd>Creates an spinfo file for generating conditional invariants and
implications by reporting the invariants that appear in at least one
of the samples but not over the entire data set.

   </dl>

<div class="node">
<p><hr>
<a name="Dynamic-abstract-type-inference-(DynComp)"></a>
<a name="Dynamic-abstract-type-inference-_0028DynComp_0029"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Loop-invariants">Loop invariants</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Enhancing-conditional-invariant-detection">Enhancing conditional invariant detection</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enhancing-Daikon-output">Enhancing Daikon output</a>

</div>

<h3 class="section">6.4 Dynamic abstract type inference (DynComp)</h3>

<p>Abstract types group variables that are used for related purposes in a
program. 
For example, suppose that some <code>int</code> variables in your program
are array lengths or indices, and other <code>int</code> variables
represent time.  Even thought these variables have the same type
(<code>int</code>) in the programming language, they have different abstract
types.

   <p>Abstract types can be provided as additional input to Daikon, so that it
only infers invariants between values of the same abstract type. 
This can improve Daikon's performance, because it reduces the number of
potential invariants that must be checked, and also improve the
relevance of its output, since invariants over unrelated variables are
superfluous for many tasks. 
The Daikon distribution includes a tool named DynComp that dynamically
infers abstract types (also called comparability types) from program
executions. 
(In fact, there are two implementations of DynComp that use the same
algorithm, one for Java programs and one for binaries compiled from C
and C++ source code. 
When confusion would otherwise arise, we distinguish them as DynCompJ
(or DynComp for Java)
and DynCompB (or Dyncomp for C/C++) respectively.)

   <p>Because abstract type inference must be performed before Daikon runs, it
is integrated with the front-ends rather than directly as part of
Daikon.

     <ul>
<li>The Java DynComp tool produces a comparability file that must then be
supplied to the Chicory Java front-end.  For examples of using DynComp
with Java programs, see <a href="#Using-DynComp-with-Java-programs">Using DynComp with Java programs</a>.  For
full details about the DynComp tool for Java, see <a href="#DynComp-for-Java">DynComp for Java</a>.

     <li>The Kvasir front-end for C/C++ binaries has a DynComp mode in which it
produces a separate <samp><span class="file">.decls</span></samp> file containing comparability
information, which must be supplied to Daikon along with the
<samp><span class="file">.dtrace</span></samp> file.  For examples of using DynComp with C programs, see
<a href="#Using-DynComp-with-C-programs">Using DynComp with C programs</a>.  For full details about the DynComp
tool for C/C++, see <a href="#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a>.

   </ul>

<div class="node">
<p><hr>
<a name="Loop-invariants"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Dynamic-abstract-type-inference-_0028DynComp_0029">Dynamic abstract type inference (DynComp)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enhancing-Daikon-output">Enhancing Daikon output</a>

</div>

<h3 class="section">6.5 Loop invariants</h3>

<p><a name="index-loop-invariants-124"></a><a name="index-local-variables-125"></a>
Daikon does not by default output loop invariants.  Daikon can detect
invariants at any location where it is provided with variable values,
but currently Daikon's front ends do not supply Daikon with variable values
at loop heads.

   <p>You could extend a front end to output more variable values, or you
could write a new front end.

   <p>Alternately, here is a way to use the current front ends to produce loop
invariants.  This workaround requires you to change your program, but it
requires no change to Daikon or its front ends.

   <p>At the top of a loop (or at any other location in the program at which
you would like to obtain invariants), insert a call to a dummy procedure
that does no work but returns immediately.  Pass, as arguments to the
dummy procedure, all variables of interest (including local variables). 
Daikon will produce (identical) preconditions and postconditions for the
dummy procedure; these are properties that held at the call site.

   <p>For instance, you might change the original code
<pre class="example">       public void calculate(int x) {
         int tmp = 0;
         while (x &gt; 0) {
           // you desire to compute an invariant here
           tmp=tmp+x;
           x=x-1;
         }
       }
</pre>
   <p class="noindent">into
<pre class="example">       public void calculate(int x) {
         int tmp = 0;
         while (x &gt; 0) {
           calculate_loophead(x, tmp);
           tmp=tmp+x;
           x=x-1;
         }
       }
     
       // dummy procedure
       public void calculate_loophead(int x, int tmp) {
       }
</pre>
   <div class="node">
<p><hr>
<a name="Front-ends-(instrumentation)"></a>
<a name="Front-ends-_0028instrumentation_0029"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tools">Tools</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Enhancing-Daikon-output">Enhancing Daikon output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Front ends (instrumentation)</h2>

<p><a name="index-front-end-126"></a><a name="index-instrumentation-127"></a>
The Daikon invariant detector is a machine learning tool that finds
patterns (invariants) in data.  That data can come from any source, but
Daikon is typically used to find invariants over variable values in
running programs.  A front end is a tool that converts data from some
other format into Daikon's input format.  The most common type of front
end is an instrumenter, which causes your program to output a
<samp><span class="file">.dtrace</span></samp> file that Daikon can process.

   <p>This chapter describes several front ends (instrumenters) that are part
of Daikon.  It
is relatively easy to build your own front end, if these do not serve
your purpose; we are aware of a number of users who have done so.  For
more information about building a new front end, see <a href="developer.html#New-front-ends">New front ends</a>.

<ul class="menu">
<li><a accesskey="1" href="#Chicory">Chicory</a>
<li><a accesskey="2" href="#DynComp-for-Java">DynComp for Java</a>
<li><a accesskey="3" href="#Kvasir">Kvasir</a>
<li><a accesskey="4" href="#Mangel_002dWurzel">Mangel-Wurzel</a>
<li><a accesskey="5" href="#dfepl">dfepl</a>
<li><a accesskey="6" href="#convertcsv_002epl">convertcsv.pl</a>
<li><a accesskey="7" href="#Other-front-ends">Other front ends</a>
</ul>

<div class="node">
<p><hr>
<a name="Chicory"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DynComp-for-Java">DynComp for Java</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>

</div>

<h3 class="section">7.1 Java front end Chicory</h3>

<p><a name="index-front-end-for-Java-128"></a><a name="index-Java-front-end-129"></a><a name="index-instrumentation_002c-of-Java-programs-130"></a><a name="index-Chicory-_0028front-end-for-Java_0029-131"></a>
The Daikon front end for Java, named Chicory, executes Java programs,
creates data trace (<samp><span class="file">.dtrace</span></samp>) files, and optionally runs Daikon on
them.  Chicory is named after the chicory plant, whose root is sometimes
used as a coffee substitute or flavor enhancer.

   <p>To use Chicory, run your program as you normally would, but
replace the <samp><span class="command">java</span></samp> command with <samp><span class="command">java daikon.Chicory</span></samp>.  For
instance, if you usually run
<pre class="example">     java mypackage.MyClass arg1 arg2 arg3
</pre>
   <p class="noindent">then instead you would run
<pre class="example">     java daikon.Chicory mypackage.MyClass arg1 arg2 arg3
</pre>
   <p class="noindent">This runs your program and creates file <samp><span class="file">MyClass.dtrace</span></samp>
in the current directory. 
Furthermore, a single command can both create a trace file and run Daikon:
<pre class="example">     java daikon.Chicory --daikon mypackage.MyClass arg1 arg2 arg3
</pre>
   <p class="noindent">See below for more options.

   <p>That's all there is to it!  Since Chicory instruments class files
directly as they are loaded into Java,
you do not need to perform separate instrumentation and recompilation steps. 
However, you should compile your program with debugging information
enabled (the <samp><span class="option">-g</span></samp> command-line switch to <samp><span class="command">javac</span></samp>);
otherwise, Chicory uses the names <code>arg0</code>, <code>arg1</code>, <small class="dots">...</small> as
the names of method arguments.

   <p>Chicory must be run in a version 5.0 JVM, but it is backward-compatible
with older versions of Java code.

<ul class="menu">
<li><a accesskey="1" href="#Chicory-options">Chicory options</a>
<li><a accesskey="2" href="#Static-fields-_0028global-variables_0029">Static fields (global variables)</a>
</ul>

<div class="node">
<p><hr>
<a name="Chicory-options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Static-fields-_0028global-variables_0029">Static fields (global variables)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Chicory">Chicory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Chicory">Chicory</a>

</div>

<h4 class="subsection">7.1.1 Chicory options</h4>

<p>Chicory is invoked as follows:
<pre class="example">     java daikon.Chicory <var>chicory-args</var> <var>classname</var> <var>args</var>
</pre>
   <p class="noindent">where
<pre class="example">     java <var>classname</var> <var>args</var>
</pre>
   <p class="noindent">is a valid invocation of Java.

   <p>This section lists the optional command-line arguments to Chicory, which
appear before the <var>classname</var> on the Chicory command line.

<ul class="menu">
<li><a accesskey="1" href="#Program-points-in-Chicory-output">Program points in Chicory output</a>
<li><a accesskey="2" href="#Variables-in-Chicory-output">Variables in Chicory output</a>
<li><a accesskey="3" href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a>
</ul>

<div class="node">
<p><hr>
<a name="Program-points-in-Chicory-output"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Variables-in-Chicory-output">Variables in Chicory output</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Chicory-options">Chicory options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Chicory-options">Chicory options</a>

</div>

<h5 class="subsubsection">7.1.1.1 Program points in Chicory output</h5>

<!-- Perhaps explain why -trace-percent doesn't appear here:  it doesn't -->
<!-- affect the .decls structure. -->
<p>This section lists options that control which program points appear in
Chicory's output.

     <dl>
<dt><samp><span class="option">--ppt-select-pattern=</span><var>regexp</var></samp><dd>Only produce trace output for classes/procedures/program points whose
names match the
given regular expression.  This option may be supplied multiple times,
and may be used in conjunction with <samp><span class="option">--ppt-omit-pattern</span></samp>.

     <p>When this switch is supplied, filtering occurs in the following way:
for each program point, Chicory checks the fully
qualified class name, the method name, and the
the program point name against each <var>regexp</var> that
was supplied.  If any of these match, then the program point is included
in the instrumentation.

     <p>Suppose that method <code>bar</code> is defined only in class <code>C</code>.  Then to
traces only <code>bar</code>, you could match the method name (in any class)
with regular expression
&lsquo;<samp><span class="samp">bar$</span></samp>&rsquo;, or you could match the program point name with &lsquo;<samp><span class="samp">C\.bar\(</span></samp>&rsquo;.

     <p>Using Unix shell syntax, you would execute
     <pre class="example">          java daikon.Chicory --ppt-select-pattern='bar$' ...
          java daikon.Chicory --ppt-select-pattern='C\.bar\(' ...
</pre>
     <p>From the Windows command line, you would execute
     <pre class="example">          java daikon.Chicory --ppt-select-pattern='bar$' ...
          java daikon.Chicory --ppt-select-pattern='C\.bar\(' ...
</pre>
     <br><dt><samp><span class="option">--ppt-omit-pattern=</span><var>regexp</var></samp><dd>Do not produce data trace output for classes/procedures/program points
whose names match the given regular expression.  This
reduces the size of the data trace file and also may make the
instrumented program run faster, since it need not output those variables.

     <p>This option works just like <samp><span class="option">--ppt-select-pattern</span></samp> does, except
that matching program points are excluded, not included.

     <p>The <samp><span class="option">--ppt-omit-pattern</span></samp> argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its fully qualified class, procedure name, or
complete program point name matches one of the omitting criteria.

     <p>The <samp><span class="option">--ppt-omit-pattern</span></samp> argument may be supplied multiple times, in
order to specify multiple omitting criteria.  A program point is omitted
if its fully qualified class, fully qualified procedure name, or
complete program point name exactly matches one of the omitting criteria. 
A regular expression matches if it matches any portion of the program
point name.  Note that currently only classes are matched, not each full
program point name.  Thus, either all of a class's methods are traced,
or none of
them are.

     <p>Here are examples of how to avoid detecting invariants over various
parts of your program.

          <ul>
<li>omit a whole package:
          <pre class="smallexample">               java daikon.Chicory '--ppt-omit-pattern=^junit\.' ...
</pre>
          <pre class="smallexample">               java daikon.Chicory '--ppt-omit-pattern=^daikon\.util\..*' ...
</pre>
          <li>omit a single class:
          <pre class="smallexample">               java daikon.Chicory '--ppt-omit-pattern=HashSetLinear\$HslIterator' ...
</pre>
          <li>omit a single method:
          <pre class="smallexample">               java daikon.Chicory '--ppt-omit-pattern=StackAr.topAndPop()' ...
</pre>
          <li>omit a single program point:
          <pre class="smallexample">               java daikon.Chicory '--ppt-omit-pattern=StackAr.&lt;init&gt;(int):::EXIT33' ...
</pre>
          </ul>

     <br><dt><samp><span class="option">--sample-start=</span><var>sample-cnt</var></samp><dd><a name="index-sampling-of-program-point-executions-132"></a>When this option is chosen, Chicory will record each program point until
that program point has been executed <var>sample-cnt</var> times.  Chicory will
then begin sampling.  Sampling starts at 10% and decreases by a factor
of 10 each time another <var>sample-cnt</var> samples have been recorded.  If
<var>sample-cnt</var> is 0, then all calls will be recorded.

     <br><dt><samp><span class="option">--boot-classes=</span><var>regex</var></samp><dd>Chicory treats  classes that match the <var>regex</var> as boot classes. 
Such classes are not instrumented.

   </dl>

<div class="node">
<p><hr>
<a name="Variables-in-Chicory-output"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Program-points-in-Chicory-output">Program points in Chicory output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Chicory-options">Chicory options</a>

</div>

<h5 class="subsubsection">7.1.1.2 Variables in Chicory output</h5>

<!-- Perhaps explain why -trace-percent doesn't appear here:  it doesn't -->
<!-- affect the .decls structure. -->
<p>This section lists options that control which variables appear in
Chicory's output.

     <dl>
<dt><samp><span class="option">--nesting-depth=</span><var>n</var></samp><dd>Depth to which to examine structure components (default 2). 
This parameter determines which variables the front end causes to be output at
runtime.  For instance, suppose that a program contained the following
data structures and variables:
     <pre class="example">          class A {
            int x;
            B b;
          }
          class B {
            int y;
            int z;
          }
          A myA;
          
          class Link {
            int val;
            Link next;
          }
          Link myList;
</pre>
          <ul>
<li>If depth=0, only the identities (hashcodes) of <code>myA</code> and
<code>myList</code> would be examined; those variables could be determined to
be equal or not equal to other variables. 
<li>If depth=1, then also <code>MyA.b</code>, <code>myList.next</code>, and the integers
<code>myA.x</code> and <code>myList.val</code> would be examined. 
<li>If depth=2, then also <code>MyA.b.y</code>, <code>MyA.b.y</code>,
<code>myList.next.next</code>, and <code>myList.next.val</code> would be examined. 
</ul>

     <p>Values whose value is undefined are not examined.  For instance, if <code>myA</code>
is <code>null</code> on a particular execution of a program point, then
<code>myA.b</code> is not accessed on that execution regardless of the depth
parameter.  That variable appears in the <samp><span class="file">.dtrace</span></samp> file, but its
value is marked as nonsensical.

     <br><dt><samp><span class="option">--omit-var=</span><var>regex</var></samp><dd><a name="index-variables_002c-omit-133"></a>Do not include variables whose name matches the regular expression.  Variables
will be omitted from each program point in which they appear.

     <br><dt><samp><span class="option">--std-visibility</span></samp><dd><a name="index-private-variables-134"></a><a name="index-variables_002c-private-135"></a>When this switch is on, Chicory will traverse exactly those fields that are
visible from a given program point.  For instance, only the public
fields of class <code>pack1.B</code> will be included at a program point for
class <code>pack2.A</code> whether or not <code>pack1.B</code> is instrumented. 
By default, Chicory outputs all fields in instrumented classes (even
those that would not be accessible in Java code at the given program point)
and outputs no fields from uninstrumented classes (even those that are
accessible).  When you supply
<samp><span class="option">--std-visibility</span></samp>, consider also supplying <samp><span class="option">--purity-file</span></samp> to
enrich the set of expressions in Daikon's output.

     <br><dt><samp><span class="option">--purity-file=</span><var>pure-methods-file</var></samp><dd><a name="index-pure-methods-136"></a><a name="index-observer-methods_002c-as-synonym-for-pure-methods-137"></a>File <var>pure-methods-file</var> lists the pure methods (sometimes called
observer methods) in a Java program.  Pure methods have no externally
side effects, such as setting variables or producing output.  For
example, most implementations of the <code>hashCode()</code>,
<code>toString()</code>, and <code>equals()</code> methods are pure.

     <p>For each variable, Chicory adds to the trace new &ldquo;fields&rdquo; that
represent invoking each pure method on the variable.  (Currently,
Chicory does so only for pure methods that take no parameters, and
obviously this mechanism is only useful for methods that return a value:
a pure method that returns no value does nothing!)

     <p>Here is an example:

     <pre class="example">          class Point {
            private int x, y;
            public int radiusSquared() {
              return x*x + y*y;
            }
          }
</pre>
     <p>I <code>radiusSquared()</code> has been specified as pure, then for each point
<var>p</var>, Chicory will output the variables <var>p</var><code>.x</code>,
<var>p</var><code>.y</code>, and <var>p</var><code>.radiusSquared()</code>.  Use of pure
methods can improve the Daikon output, since they represent information
that the programmer considered important but that is not necessarily
stored in a variable.

     <p>Invoking a pure method at any time in an application should not change
the application's behavior.  If a non-pure method is listed in a purity
file, then application behavior can change.  Chicory does not verify the
purity of methods listed in the purity file.

     <p>The purity file lists a set of methods, one per line.  The format of
each method is given by the Sun JDK API:
<blockquote>
The string is formatted as the method access modifiers, if any, followed
by the method return type, followed by a space, followed by the class
declaring the method, followed by a period, followed by the method name,
followed by a parenthesized, comma-separated list of the method's formal
parameter types.  If the method throws checked exceptions, the parameter
list is followed by a space, followed by the word throws followed by a
comma-separated list of the thrown exception types.  For example:
          <pre class="example">               public boolean java.lang.Object.equals(java.lang.Object)
</pre>
          <p>The access modifiers are placed in canonical order as specified by "The
Java Language Specification".  This is public, protected or private
first, and then other modifiers in the following order: abstract,
static, final, synchronized native. 
</blockquote>

     <p>By convention, <var>pure-methods-file</var> has the suffix <samp><span class="file">.pure</span></samp>.  If
<var>pure-methods-file</var> is specified as a relative (not absolute) file
name, it is searched for in the configuration directory specified via
<samp><span class="option">--configs=</span><var>directory</var></samp>, or in the current directory if no
configuration directory is specified.

     <p>One way to create a <samp><span class="file">.pure</span></samp> file is to run the Purity Analysis Kit
(<a href="http://jppa.sourceforge.net/">http://jppa.sourceforge.net/</a>).  If you supply
the <samp><span class="option">--daikon-purity-file</span></samp> when running the Purity Analysis Kit,
it writes a file that can be supplied to Chicory.

     <br><dt><samp><span class="option">--linked-lists</span></samp><dd><a name="index-linked-lists_002c-in-Chicory-138"></a>This boolean option (default: true) causes user-defined linked lists to
be output as sequences, much like Java &lsquo;<samp><span class="samp">List</span></samp>&rsquo;s and arrays are. 
A user-defined data structure is considered to be a linked list if it
has one instance field that is of its own type.

   </dl>

<div class="node">
<p><hr>
<a name="Chicory-miscellaneous-options"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variables-in-Chicory-output">Variables in Chicory output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Chicory-options">Chicory options</a>

</div>

<h5 class="subsubsection">7.1.1.3 Chicory miscellaneous options</h5>

<p>This section lists all other Chicory options &mdash; that is, all options
that do not control which program points and variables appear in
Chicory's output.

     <dl>
<dt><samp><span class="option">--help</span></samp><dd>Print a help message.

     <br><dt><samp><span class="option">--debug</span></samp><dd>Produce debugging information.  For other debugging options, run Chicory
with the <samp><span class="option">--help</span></samp> option.

     <br><dt><samp><span class="option">--default-bcel</span></samp><dd>Chicory uses the Byte Code Engineering Library (BCEL) to instrument
classfiles.  Errors can occur if the application uses an incompatible
version of BCEL.  By default, Chicory identifies and loads its
copy of BCEL when multiple copies of BCEL are in the classpath.  It will
also issue a warning if multiple copies of BCEL are in the classpath and
the application version is not the first one.  When this option is
chosen, Chicory will simply use whatever version of BCEL is found on
the classpath.

     <br><dt><samp><span class="option">--dtrace-file=</span><var>filename</var></samp><dd><a name="index-DTRACEFILE-environment-variable-139"></a><a name="index-environment-variable-DTRACEFILE-140"></a><a name="index-DTRACEAPPEND-environment-variable-141"></a><a name="index-environment-variable-DTRACEAPPEND-142"></a><a name="index-trace-file-name-143"></a><a name="index-dtrace-file-name-144"></a><a name="index-file-name_002c-for-dtrace-file-145"></a>Specifies the default name for the trace output (<samp><span class="file">.dtrace</span></samp>) file. 
If this is not specified, then the value of the <samp><span class="env">DTRACEFILE</span></samp>
environment variable (at the time the instrumented program runs) is
used.  If that environment variable is not used, then the default is
<samp><span class="file">./</span><var>CLASSNAME</var><span class="file">.dtrace</span></samp>.

     <p>If the <samp><span class="env">DTRACEAPPEND</span></samp> environment
variable is set to any value, the dtrace file will be appended to
instead of overwritten.  Compressed data trace files may not be appended
to.  In some cases you may find a single large data trace file more
convenient; in other cases, a collection of smaller data trace files may
give you more control over which subsets of runs to invoke Daikon on.

     <br><dt><samp><span class="option">--comparability-file=</span><var>filename</var></samp><dd>This option specifies a declaration file (see <a href="developer.html#Declarations">Declarations</a>)
that contains comparability information.  This information will be
incorporated in the output of Chicory.  Any variables not included in
the comparability file will have their comparability set so that they
are comparable to all other variables of the same type.

     <br><dt><samp><span class="option">--output-dir=</span><var>directory</var></samp><dd>Write the <samp><span class="file">.dtrace</span></samp> trace output file to the specified directory. 
The default is the current directory.

     <br><dt><samp><span class="option">--config-dir=</span><var>directory</var></samp><dd>Chicory will use this location to search for configuration files. 
Currently, this only includes <samp><span class="file">*.pure</span></samp> files.

     <br><dt><samp><span class="option">--daikon</span></samp><dd>After creating a data trace (<samp><span class="file">.dtrace</span></samp>) file, run Daikon on it. 
To specify arguments to Daikon use the <samp><span class="option">--daikon-args</span></samp> option. 
Also see the
<samp><span class="option">--daikon-online</span></samp> option.

     <p>This option supplies Daikon with a single trace from one execution of
your program.  By contrast to this option (and
<samp><span class="option">--daikon-online</span></samp>), if you invoke Daikon from the command line,
you can supply Daikon with as many trace files as you wish.

     <br><dt><samp><span class="option">--daikon-online</span></samp><dd>This option is like <samp><span class="option">--daikon</span></samp>, except that no <samp><span class="file">.dtrace</span></samp>
data trace file is produced.  Instead, Chicory sends trace information
over a socket to Daikon, which processes the information incrementally
(&ldquo;online&rdquo;), as Chicory produces it.

     <p>Just like with the <samp><span class="option">--daikon</span></samp> option, Daikon is only given a
single trace from one execution of your program.

     <p>The Kvasir front end also supports online execution, via use of (normal or
named) Unix pipes (see <a href="#Online-execution">Online execution</a>).

     <br><dt><samp><span class="option">--daikon-args=</span><var>arguments</var></samp><dd>Specifies arguments to be passed to Daikon if the <samp><span class="option">--daikon</span></samp> or
<samp><span class="option">--daikon-online</span></samp> options are used.

     <br><dt><samp><span class="option">--premain=</span><var>path</var></samp><dd>Specifies the absolute pathname to the <samp><span class="file">ChicoryPremain.jar</span></samp> file. 
Chicory requires this jar file in order to execute.  By default Chicory
looks for the jar file in the classpath and in <samp><span class="file">$(DAIKONDIR)/java</span></samp>
(where <samp><span class="env">DAIKONDIR</span></samp> is an environment variable that points to the
complete installation of Daikon).

     <p>Chicory can also use the <samp><span class="file">daikon.jar</span></samp> file for this purpose.  If it
doesn't find <samp><span class="file">ChicoryPremain.jar</span></samp> above, it will use <samp><span class="file">daikon.jar</span></samp>
itself (if a file named <samp><span class="file">daikon.jar</span></samp> appears in the classpath).  If
the Daikon jar file is not named <samp><span class="file">daikon.jar</span></samp>, you can use this
switch to specify its name.  For example:
     <pre class="example">          --premain=C:\lib\daikon-4.1.3.jar
</pre>
     <br><dt><samp><span class="option">--heap-size=</span><var>max_heap</var></samp><dd>Specifies the maximum size, in bytes, of the memory allocation pool for
the target program.  The size is specified in the same manner as the
-Xmx switch to java.

   </dl>

<div class="node">
<p><hr>
<a name="Static-fields-(global-variables)"></a>
<a name="Static-fields-_0028global-variables_0029"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Chicory-options">Chicory options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Chicory">Chicory</a>

</div>

<h4 class="subsection">7.1.2 Static fields (global variables)</h4>

<p><a name="index-Static-fields-_0028global-variables_0029-in-Java-programs-146"></a>
Chicory (Daikon's front end for Java) outputs the values of static
fields in the current class, but not in other classes.  That means that
Daikon cannot report properties over static fields in other classes,
because it never sees their values.  (By contrast, Kvasir
(see <a href="#Kvasir">Kvasir</a>) supplies the values of C/C++ global variables to
Daikon.)

   <p>If you need Daikon to include all static variables when processing each
class, then ask the maintainers to add that feature to
Chicory (or work with them to implement the enhancement).  In the
meanwhile, here are two workarounds.

     <ol type=1 start=1>
<li>Add a static field whose type is the class containing the fields of
interest.  You don't have to ever assign to the new field.  A
disadvantage of this approach is that it gives you properties over the
global variables as observed by each class (which might be different).

     <li>At the beginning and end of each method, add a call to a dummy method
that has access to all the globals (via adding the field mentioned above). 
This produces a single formula that is valid for all global variables at
all times.
        </ol>

<div class="node">
<p><hr>
<a name="DynComp-for-Java"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Kvasir">Kvasir</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Chicory">Chicory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>

</div>

<h3 class="section">7.2 DynComp dynamic comparability (abstract type) analysis for Java</h3>

<p><a name="index-DynComp_002c-for-Java-147"></a><a name="index-abstract-types_002c-for-Java-148"></a><a name="index-comparability_002c-for-Java-149"></a><a name="index-dynamic-comparability_002c-for-Java-150"></a>
The DynComp dynamic comparability analysis tool performs dynamic type
inference to group variables at each program point into comparability
sets (see <a href="developer.html#Program-point-declarations">Program point declarations</a> for the numeric
representation format of these sets).  All variables in each
comparability set belong to the same &ldquo;abstract type&rdquo; of data that the
programmer likely intended to represent, which is a richer set of types
than the few basic declared types (e.g., int, float) provided by the
language.  Consider the example below:

<pre class="example">     public class Year {
         public static void main(String[] args) {
             int year = 2005;
             int winterDays = 58;
             int summerDays = 307;
             compute(year, winterDays, summerDays);
         }
     
         public static int compute(int yr, int d1, int d2) {
             if (0 != yr % 4)
                 return d1 + d2;
             else
                 return d1 + d2 + 1;
         }
     }
</pre>
   <p>The three variables in <code>main()</code> all have the same Java
representation type, <code>int</code>, but two of them hold related quantities
(numbers of days), as can be determined by the fact that they interact
when the program adds them, whereas the other contains a conceptually
distinct quantity (a year).  The abstract types 'day' and 'year' are
both represented as <code>int</code>, but DynComp can differentiate them with
its dynamic analysis.  For example, DynComp can infer that
<code>winterDays</code> and <code>summerDays</code> are comparable (belong to the
same abstract type) because the program adds their values together
within the compute() function.

   <p>Without comparability information, Daikon attempts to find invariants
over all pairs (and sometimes triples) of variables present at every
program point.  This can lead to two negative consequences: First, it
may take lots of time and memory to infer all of these invariants,
especially when there are many global or derived variables present. 
Second, many of those invariants are true but meaningless because they
relate variables which conceptually represent different types (e.g., an
invariant such as <code>winterDays &lt; year</code> is true but meaningless
because days and years are not comparable).

   <p>To use DynComp, run your program as you normally would, but replace the
<samp><span class="command">java</span></samp> command with <samp><span class="command">java daikon.DynComp</span></samp>.  For instance,
if you usually run
<pre class="example">     java mypackage.MyClass arg1 arg2 arg3
</pre>
   <p class="noindent">then instead you would run
<pre class="example">     java daikon.DynComp mypackage.MyClass arg1 arg2 arg3
</pre>
   <p class="noindent">This runs your program and creates the file <samp><span class="file">MyClass.decls-DynComp</span></samp>
in the current directory.  DynComp also creates <samp><span class="file">MyClass.txt-cset</span></samp>,
which contains the same information and a further level of detail in an
easier-to-read format.  The <samp><span class="file">.decls</span></samp> file may be passed to Chicory,
as described in <a href="#Using-DynComp-with-Java-programs">Using DynComp with Java programs</a>.
<pre class="example">     java daikon.Chicory --comparability-file=MyClass.decls-DynComp \
          mypackage.MyClass arg1 arg2 arg3
</pre>
   <p>See below for more options.

   <p>While you may run DynComp with the standard JDK, using the
<samp><span class="option">--no-jdk</span></samp> switch, you can obtain more accurate results by using a
copy of the JDK that has been instrumented with DynComp.  See
<a href="#Instrumenting-the-JDK-with-DynComp">Instrumenting the JDK with DynComp</a>, below, for instructions.

   <p>This is part of a sample <samp><span class="file">.decls</span></samp> file generated by running DynComp on the example above:

<pre class="example">     DECLARE
     Year.compute(int, int, int):::ENTER
     yr
     int # isParam=true
     int
     3
     d1
     int # isParam=true
     int
     2
     d2
     int # isParam=true
     int
     2
     
     DECLARE
     Year.compute(int, int, int):::EXIT11
     yr
     int # isParam=true
     int
     3
     d1
     int # isParam=true
     int
     2
     d2
     int # isParam=true
     int
     2
     return
     int
     int
     2
</pre>
   <p class="noindent">The declarations file format is described in <a href="developer.html#Program-point-declarations">Program point declarations</a>.

   <p>DynComp creates two representations of the comparability information in
the files <samp><span class="file">foo.txt-cset</span></samp> and <samp><span class="file">foo.txt-trace</span></samp>.  In the <samp><span class="file">cset</span></samp>
file, DynComp outputs comparability sets as sets.  The above <samp><span class="file">.decls</span></samp>
output corresponds to the following in <samp><span class="file">cset</span></samp>:

<pre class="example">     Daikon Variable sets for Year.compute(I yr, I d1, I d2) enter
       [1] [daikon.chicory.ParameterInfo:d1]
       [1] [daikon.chicory.ParameterInfo:d2]
       [1] [daikon.chicory.ParameterInfo:yr]
     Daikon Variable sets for Year.compute(I yr, I d1, I d2) exit
       [3] [daikon.chicory.ParameterInfo:d1, daikon.chicory.ParameterInfo:
            d2, daikon.chicory.ReturnInfo:return]
       [1] [daikon.chicory.ParameterInfo:yr]
</pre>
   <p>In the <samp><span class="file">trace</span></samp> file, DynComp outputs comparability sets as trees,
structured such that each variable in the tree has interacted with its
children.  The lack of a parent-child relationship between two variables
in a set does not imply anything about whether they interacted. 
The above <samp><span class="file">.decls</span></samp> output corresponds to the following in
<samp><span class="file">trace</span></samp>:

<pre class="example">     Daikon Traced Tree for Year.compute(I yr, I d1, I d2) enter
     
     daikon.chicory.ParameterInfo:d1
     
     daikon.chicory.ParameterInfo:d2
     
     daikon.chicory.ParameterInfo:yr
     
     
     Daikon Traced Tree for Year.compute(I yr, I d1, I d2) exit
     
     daikon.chicory.ParameterInfo:d2
     --daikon.chicory.ParameterInfo:d1 ([Year:compute()-11])
     --daikon.chicory.ReturnInfo:return ([Year:compute()-11])
     
     daikon.chicory.ParameterInfo yr
</pre>
   <p class="noindent">The file here shows that <code>d1</code>, <code>d2</code>, and the return value of
the <code>compute</code> method are in the same comparability set; this is
correct, as they are all of the abstract type `days'.  The variable
<code>yr</code> is in its own comparability set; it has abstract type `year',
and so is not comparable to the other variables.  In addition, the structure
of the <code>[d1, d2, return]</code> set shows that at some point, <code>d1</code> interacted
with <code>d2</code>, and that <code>d2</code> interacted with <code>return</code>.  The absence of
a <code>d1 -- return</code> edge does not imply that <code>d1</code> and <code>return</code> never
interacted directly.

   <p>In addition, non-root nodes in the <samp><span class="file">trace</span></samp> trees can indicate a list of class names,
method names, and line numbers at which values interacted, resulting in comparability
between the preceding child node and its parent.  In the above example, <code>d1</code>
interacted with <code>d2</code> on line 11 of the <code>compute</code> method of the <code>Year</code>
class.

   <p>Duplicate values in this list represent the results of separate calls to
another method which each of the relevant variables.  For example, if <code>main</code> had calls
<code>compute(year, summerDays, winterDays)</code> and
<code>compute(year,schoolDays,breakDays)</code>, then for <code>main</code> we might see
this output:

<pre class="smallexample">     daikon.chicory.FieldInfo:summerDays
     --daikon.chicory.FieldInfo:winterDays([Year:compute()-11])
     --daikon.chicory.FieldInfo:schoolDays([Year:compute()-11, Year:compute()-11])
     ----daikon.chicory.FieldInfo:breakDays([Year:compute()-11])
</pre>
   <p>Empty lists indicate that no non-assignment interactions occurred in the series of
interactions connecting the two variables.

   <p>Elements of these lists are essentially parts of stack traces.  The maximum number
of stack trace levels displayed is set by <code>--trace-line-depth</code>, which is equal to 1 by default.

   <p>For these files, DynComp also has a <code>--abridged-vars</code> option that replaces text
like <code>daikon.chicory.ParameterInfo:d2</code> with text like <code>Parameter d2</code> in the <samp><span class="file">cset</span></samp>
and <samp><span class="file">trace</span></samp> files.  It writes <code>this</code> instead of
<code>daikon.chicory.ThisObjInfo:this</code>; and <code>return</code> instead of
<code>daikon.chicory.ReturnInfo:return</code>.  This option is off by default, but can be
turned on with <code>--abridged-vars</code>.

<ul class="menu">
<li><a accesskey="1" href="#Instrumenting-the-JDK-with-DynComp">Instrumenting the JDK with DynComp</a>
<li><a accesskey="2" href="#DynComp-for-Java-options">DynComp for Java options</a>
<li><a accesskey="3" href="#Instrumentation-of-Object-methods">Instrumentation of Object methods</a>
<li><a accesskey="4" href="#DynComp-for-Java-known-bugs">DynComp for Java known bugs</a>
</ul>

<div class="node">
<p><hr>
<a name="Instrumenting-the-JDK-with-DynComp"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DynComp-for-Java-options">DynComp for Java options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DynComp-for-Java">DynComp for Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#DynComp-for-Java">DynComp for Java</a>

</div>

<h4 class="subsection">7.2.1 Instrumenting the JDK with DynComp</h4>

<p><a name="index-dcomp_005frt_002ejar-file-for-DynComp-151"></a><a name="index-instrumented-JDK_002c-for-DynComp-152"></a><a name="index-JDK_002c-instrumented-for-DynComp-153"></a>
If you did not already do so when installing Daikon (in
<a href="#Complete-installation">Complete installation</a>), follow the instructions here to build an
instrumented copy of the JDK.  Use the following command in
<samp><span class="file">$DAIKONDIR</span></samp>:

<pre class="example">     make -C java dcomp_rt.jar
</pre>
   <p class="noindent">Make sure the <code>JAVA_HOME</code> environment variable is set to the directory
containing your JDK.  This command instruments the classes in the
<samp><span class="file">rt.jar</span></samp> file of the JDK, and creates a new file,
<samp><span class="file">dcomp_rt.jar</span></samp>, in the <samp><span class="file">java</span></samp> directory.

   <p>On MacOS, there is not normally a JDK directory.  Instead, the
<code>ORIG_RT</code> variable must be set to specify the location of the input JDK
jar file (<code>classes.jar</code> in MacOS).  Normally the file is found in
<code>/System/Library/Frameworks</code> under the appropriate Java version. 
The following example is for the standard install of Java 1.5 on
MacOS:

<pre class="smallexample">       export ORIG_RT=/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/classes.jar
</pre>
   <p>BuildJDK requires 20-40 minutes to complete and uses 1024 MB of
memory.  Regular progress indicators are printed to standard output.

   <p>You can ignore warnings issued during the instrumentation process, so
long as the make target itself completes normally.

   <p>There are a small number of methods in the JDK that DynComp is
currently unable to instrument.  The names of these methods will be
printed at the end of instrumentation.  This is not a problem unless
your application calls these methods (directly or indirectly). 
If one of those methods is called, a NoSuchMethodException will
be generated when the call is attempted.

<div class="node">
<p><hr>
<a name="DynComp-for-Java-options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Instrumentation-of-Object-methods">Instrumentation of Object methods</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Instrumenting-the-JDK-with-DynComp">Instrumenting the JDK with DynComp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#DynComp-for-Java">DynComp for Java</a>

</div>

<h4 class="subsection">7.2.2 DynComp options</h4>

<p>DynComp is invoked as follows:
<pre class="example">     java daikon.DynComp <var>dyncomp-args</var> <var>classname</var> <var>args</var>
</pre>
   <p class="noindent">where
<pre class="example">     java <var>classname</var> <var>args</var>
</pre>
   <p class="noindent">is a valid invocation of Java.

   <p>This section lists the optional command-line arguments to DynComp, which
appear before the <var>classname</var> on the DynComp command line.

     <dl>
<dt><samp><span class="option">--verbose</span></samp><dd>Print information about the classes being processed.

     <br><dt><samp><span class="option">--debug</span></samp><dd>Dump the instrumented classes to <samp><span class="file">/tmp/$USER/bin</span></samp>.

     <br><dt><samp><span class="option">--debug-dir</span></samp><dd>The directory in which to dump instrumented class files (only if
<samp><span class="option">--debug</span></samp> is specified).  Defaults to <samp><span class="file">debug</span></samp> in the current
working directory.

     <br><dt><samp><span class="option">--output-dir=</span><var>dir</var></samp><dd>The directory in which to create output files.  Defaults to the current
working directory.

     <br><dt><samp><span class="option">--decl-file=</span><var>file</var></samp><dd>Output filename for decl file suitable for input to Daikon.  Defaults to
<samp><var>target_program</var><span class="file">.decls-DynComp</span></samp>.

     <br><dt><samp><span class="option">--no-cset-file</span></samp><dd>When this switch is on, output of the <samp><span class="file">cset</span></samp> file is suppressed.

     <br><dt><samp><span class="option">--compare-sets-file=</span><var>file</var></samp><dd>Output filename for a more easily human-readable file summarizing
comparability sets.  The default behavior is to print to standard
output.  This switch has no effect if <samp><span class="option">--no-cset-file</span></samp> is specified
on the command line.

     <br><dt><samp><span class="option">--trace-sets-file=</span><var>file</var></samp><dd>Output filename for a human-readable file showing some of the interactions
that occurred.  Default behavior is to not create the file.

     <br><dt><samp><span class="option">--trace-line-depth=</span><var>n</var></samp><dd>Controls size of the stack displayed in tracing the interactions that
occurred.  Default behavior is to only display one element in the stack &ndash;
that is, display at most the topmost function on the stack when the
interaction occurred.  This switch has no effect if <samp><span class="option">--trace-sets-file</span></samp>
is not specified, or is null.

     <br><dt><samp><span class="option">--abridged-vars</span></samp><dd>When this switch is on, DynComp abridges the variables printed in the files
specified by <samp><span class="option">--compare-sets-file</span></samp> and <samp><span class="option">--trace-sets-file</span></samp>. 
For example, DynComp with output
&ldquo;Field foo&rdquo; instead of &ldquo;dyncomp.chicory.FieldInfo:MyClass.foo&rdquo;.  In particular,
it replaces &ldquo;dyncomp.chicory.ReturnInfo:return&rdquo; with &ldquo;return&rdquo; and
&ldquo;dyncomp.chicory.ThisObjInfo:this&rdquo; with &ldquo;this&rdquo;.

     <br><dt><samp><span class="option">--ppt-select-pattern=</span><var>regex</var></samp><dd>Only emit program points that match <var>regex</var>.  Specifically, a
program point is considered to match <var>regex</var> if the fully qualified
class name, the method name, or the program point name matches
<var>regex</var>.  The behavior of this switch is the same as in Chicory (see
<a href="#Program-points-in-Chicory-output">Program points in Chicory output</a>).

     <p>This option can be specified multiple times, and may be used in
conjunction with <samp><span class="option">--ppt-omit-pattern</span></samp>.  If a program point matches
both a select pattern and an omit pattern, it is omitted.

     <br><dt><samp><span class="option">--ppt-omit-pattern=</span><var>regex</var></samp><dd>Suppress program points that match <var>regex</var>.  Specifically, a
program point is considered to match <var>regex</var> if the fully qualified
class name, the method name, or the program point name matches
<var>regex</var>.  The behavior of this switch is the same as in Chicory (see
<a href="#Program-points-in-Chicory-output">Program points in Chicory output</a>).

     <p>This option can be specified multiple times, any may be used in
conjunction with <samp><span class="option">--ppt-select-pattern</span></samp>.  If a program point
matches both a select pattern and an omit pattern, it is omitted.

     <br><dt><samp><span class="option">--no-primitives</span></samp><dd>Don't track primitives.  When this switch is on, DynComp only tracks
the comparability of object references; primitive values are
ignored.  Using this switch can greatly improve DynComp's runtime if
you are not interested in primitive values.

     <br><dt><samp><span class="option">--no-jdk</span></samp><dd>When this switch is on, DynComp runs with an uninstrumented JDK, and the
<samp><span class="option">--rt-file</span></samp> switch is ignored.

     <br><dt><samp><span class="option">--rt-file</span></samp><dd>Specifies the location of the instrumented JDK (see <a href="#Instrumenting-the-JDK-with-DynComp">Instrumenting the JDK with DynComp</a>).  This option is rarely necessary, because
if <samp><span class="option">--rt-file</span></samp> is not specified, DynComp
will search for a file named <samp><span class="file">dcomp_rt.jar</span></samp> along the classpath,
and in <samp><span class="file">$DAIKONDIR/java</span></samp>.  Both this file and the current classpath
are placed on the boot classpath for DynComp's execution.

     <br><dt><samp><span class="option">--std-visibility</span></samp><dd>When this switch is on, DynComp traverses exactly those fields that are
visible from a given program point.  For an example, see <a href="#Variables-in-Chicory-output">Variables in Chicory output</a>.

     <br><dt><samp><span class="option">--nesting-depth=</span><var>n</var></samp><dd>Depth to which to examine structure components (default 2).  This
parameter determines which variables the front end causes to be output
at runtime.  For an example, see <a href="#Variables-in-Chicory-output">Variables in Chicory output</a>.

   </dl>

<div class="node">
<p><hr>
<a name="Instrumentation-of-Object-methods"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DynComp-for-Java-known-bugs">DynComp for Java known bugs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DynComp-for-Java-options">DynComp for Java options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#DynComp-for-Java">DynComp for Java</a>

</div>

<h4 class="subsection">7.2.3 Instrumentation of Object methods</h4>

<p>DynComp is unable to directly instrument methods of the class
<code>Object</code>, such as <code>clone</code> and <code>equals</code>.  DynComp uses a
few tricks, described here in brief, to track comparability in these
methods.

   <p>Calls such as <code>o1.equals(o2)</code> are replaced with calls to a static
method in DynComp, <code>dcomp_equals(o1, o2)</code>.  This static method
dynamically determines whether or not <code>o1</code> is an instance of a
class that has been instrumented by DynComp; every such class
implements the interface <code>DCompInstrumented</code>.  If so, it attempts
to invoke the instrumented version of the <code>equals</code> method for
<code>o1</code>.  If not, or if <code>o1</code> has not overridden the
<code>equals</code> method from <code>Object</code>, then no instrumented version
exists, so the uninstrumented version is invoked.

   <p>In either case, the references <code>o1</code> and <code>o2</code> are considered
to be comparable.  In a future release, we will provide a command-line
switch to customize this behavior.

   <p>The <code>clone</code> method operates in a similar manner, choosing
dynamically to invoke the instrumented method or the uninstrumented
method.  In the case of <code>clone</code>, the methods are invoked via
reflection.  In either case, the object being cloned and the resulting
clone are made comparable to each other.  Again, we will provide a
switch to customize this behavior in a future release.

<div class="node">
<p><hr>
<a name="DynComp-for-Java-known-bugs"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Instrumentation-of-Object-methods">Instrumentation of Object methods</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#DynComp-for-Java">DynComp for Java</a>

</div>

<h4 class="subsection">7.2.4 Known bugs and limitations</h4>

     <ul>
<li>Reflection finds the original, uninstrumented code, and so DynComp may
not accurately instrument code that uses reflection. 
<li>Instrumentation of the <code>clone()</code> method may fail on particular
invocations within private classes in the JDK. 
</ul>

<div class="node">
<p><hr>
<a name="Kvasir"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mangel_002dWurzel">Mangel-Wurzel</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DynComp-for-Java">DynComp for Java</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>

</div>

<h3 class="section">7.3 C/C++ front end Kvasir</h3>

<p><a name="index-Kvasir-_0028binary-front-end-for-C_0029-154"></a><a name="index-front-end-for-C_002fC_002b_002b-155"></a><a name="index-C_002fC_002b_002b-front-end-156"></a><a name="index-instrumentation_002c-of-C_002fC_002b_002b-programs-157"></a>
Daikon's front end for C and C++, named Kvasir, executes C and C++
programs and creates
data trace (<samp><span class="file">.dtrace</span></samp>) files of variables and their values by
examining the operation of the binary at
runtime.  Kvasir is named after the Norse god of knowledge and beet juice. 
It is built upon the Fjalar dynamic analysis framework for C and C++ programs
(available at <a href="http://pag.csail.mit.edu/fjalar/">http://pag.csail.mit.edu/fjalar/</a>, but already
included in the Daikon distribution).

   <p>To use Kvasir, first compile your program using the DWARF-2 debugging
format (e.g., supply the <samp><span class="option">-gdwarf-2</span></samp> option to <samp><span class="command">gcc</span></samp>) and
without optimizations (e.g., supply the <samp><span class="option">-O0</span></samp> option to <samp><span class="command">gcc</span></samp>). 
Then, prefix your command line by <samp><span class="command">kvasir-dtrace</span></samp>.  For example,
if you normally run your program with the command
<pre class="example">     ./program -option input.file
</pre>
   <p class="noindent">then instead use the command
<pre class="example">     kvasir-dtrace ./program -option input.file
</pre>
   <p class="noindent">to run your program and create a data trace file
<samp><span class="file">daikon-output/program.dtrace</span></samp>, which can be fed as input into
Daikon.  You can perform this step multiple times to create multiple
data trace files for Daikon. 
You can also run Daikon without creating an intermediate data trace
file; see <a href="#Online-execution">Online execution</a>.

   <p>For information about installing Kvasir, see <a href="#Installing-Kvasir">Installing Kvasir</a>. 
Kvasir only works under Linux running on an x86 or x86-64 processor; for full
details, see <a href="#Kvasir-limitations">Kvasir limitations</a>. 
For information about how to create an instrumenter for C that works on
non-Linux or non-x86 platforms, see <a href="developer.html#Instrumenting-C-programs">Instrumenting C programs</a>.

<ul class="menu">
<li><a accesskey="1" href="#Using-Kvasir">Using Kvasir</a>
<li><a accesskey="2" href="#Kvasir-options">Kvasir options</a>
<li><a accesskey="3" href="#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a>
<li><a accesskey="4" href="#Tracing-only-part-of-a-program">Tracing only part of a program</a>
<li><a accesskey="5" href="#Pointer-type-disambiguation">Pointer type disambiguation</a>
<li><a accesskey="6" href="#C_002b_002b-support">C++ support</a>
<li><a accesskey="7" href="#Online-execution">Online execution</a>
<li><a accesskey="8" href="#Installing-Kvasir">Installing Kvasir</a>
<li><a accesskey="9" href="#Kvasir-limitations">Kvasir limitations</a>
</ul>

<div class="node">
<p><hr>
<a name="Using-Kvasir"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Kvasir-options">Kvasir options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Kvasir">Kvasir</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Kvasir">Kvasir</a>

</div>

<h4 class="subsection">7.3.1 Using Kvasir</h4>

<p>Before using Kvasir, you must compile your program compile and link your
program normally, with two exceptions:
     <ul>
<li>Do not use optimization.  Remove
any optimization flags, such as <samp><span class="option">-O</span></samp> or <samp><span class="option">-O2</span></samp>,
and any flags that affect calling conventions, such as
<samp><span class="option">-fomit-frame-pointer</span></samp>. 
<li>Include debugging information, by supplying the <samp><span class="option">-g</span></samp> flag. 
The debugging information must be in the DWARF-2 format. 
DWARF-2 is the default format for debugging information in GCC 3 and later, and
otherwise is produced by supplying the <samp><span class="option">-gdwarf-2</span></samp> command line option. 
</ul>

   <p>In the second step of using Kvasir, run your program as you normally
would, but prepend the command <samp><span class="command">kvasir-dtrace</span></samp> to the beginning. 
For instance, if you normally run your program with the command
<pre class="example">     ./myprogram -option input.file
</pre>
   <p class="noindent">just say
<pre class="example">     kvasir-dtrace ./myprogram -option input.file
</pre>
   <p class="noindent">As well as running your program (more slowly than usual), this command
also creates a directory <samp><span class="file">daikon-output</span></samp> in the current
directory containing a <samp><span class="file">program.dtrace</span></samp> file suitable as input to Daikon.

   <p>Kvasir's first argument, the program name, should be given as a
pathname, as shown above.  If you usually just give a program name that
is not in the current directory but is found in your path, you may need
to modify your command to specify a pathname.  For example:
<pre class="example">     kvasir-dtrace `which myprogram` -option input.file
</pre>
   <p>You may supply options to Kvasir
before the argument that is the name of your program (see <a href="#Kvasir-options">Kvasir options</a>).

<div class="node">
<p><hr>
<a name="Kvasir-options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Kvasir">Using Kvasir</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Kvasir">Kvasir</a>

</div>

<h4 class="subsection">7.3.2 Kvasir options</h4>

<p>To see a complete list of options, run this command: <samp><span class="command">kvasir-dtrace --help</span></samp>

   <p>Output file format:

     <dl>
<dt><samp><span class="option">--decls-file=</span><var>filename</var></samp><dd>
Write the <samp><span class="file">.decls</span></samp> file listing the names of functions and
variables (called declarations) to the specified file name.  This forces
Kvasir to generate separate
<samp><span class="file">.decls</span></samp> and <samp><span class="file">.dtrace</span></samp> files instead of outputting everything to the
<samp><span class="file">.dtrace</span></samp> file, which is the default behavior.  If only a <samp><span class="file">.dtrace</span></samp> file is
created (default behavior), then it contains both variable declarations and a trace of
values.  If separate <samp><span class="file">.decls</span></samp> and <samp><span class="file">.dtrace</span></samp> files are created,
then the <samp><span class="file">.decls</span></samp> file contains declarations and the <samp><span class="file">.dtrace</span></samp>
file contains the trace of values.

     <br><dt><samp><span class="option">--decls-only</span></samp><dd>
Exit after writing the <samp><span class="file">.decls</span></samp> file; don't run the program or
generate trace information.  Since the <samp><span class="file">.decls</span></samp> file is the same for
any run of a program, it can be generated once and then reused on later
runs, as long as no new program points are added and each program point
has the same set of variables.

     <br><dt><samp><span class="option">--dtrace-file=</span><var>filename</var></samp><dd>
Write the <samp><span class="file">.dtrace</span></samp> trace file to the specified file name.  The default is
<samp><span class="file">daikon-output/</span><var>programname</var><span class="file">.dtrace</span></samp>, where <var>programname</var>
is the name of the program.  A filename of <samp><span class="file">-</span></samp> may be used to
specify the standard output; in this case, the regular standard output
of the program will be redirected back to the terminal (<samp><span class="file">/dev/tty</span></samp>), to avoid
intermixing it with the trace output.  If the given filename ends in
<samp><span class="file">.gz</span></samp>, then <samp><span class="option">--dtrace-gzip</span></samp> is enabled and the
<samp><span class="file">.dtrace</span></samp> file will be compressed.

     <br><dt><samp><span class="option">--dtrace-no-decs</span></samp><dd>
By default, the <samp><span class="file">.dtrace</span></samp> file contains both a list of variable
declarations followed by a trace of variable values (see <a href="developer.html#File-formats">File formats</a>).  If this option is used, then variable declarations are not
outputted in the .dtrace file.  This option is equivalent to
<samp><span class="option">--decls-file=/dev/null</span></samp>, except that it runs faster.  This is
useful when you want to generate one copy of the declarations in the
.decls file using <samp><span class="option">--decls-only</span></samp>, generate many
<samp><span class="file">.dtrace</span></samp> files from different program runs, and then feed 1
<samp><span class="file">.decls</span></samp> and several <samp><span class="file">.dtrace</span></samp> files into Daikon.

     <br><dt><samp><span class="option">--dtrace-append</span></samp><dd>
Append new trace information to the end of an existing <samp><span class="file">.dtrace</span></samp>
file.  The default is to overwrite a pre-existing <samp><span class="file">.dtrace</span></samp> file. 
When this option is used, no declaration information is written because
it is assumed that the existing .dtrace file already contains all
declarations (Daikon does not accept duplicate declarations).

     <br><dt><samp><span class="option">--dtrace-gzip</span></samp><dd>
Compress trace information with the gzip program before writing
it to the <samp><span class="file">.dtrace</span></samp> file.  You must have the gzip program
available.

     <br><dt><samp><span class="option">--output-fifo</span></samp><dd>
Create the output <samp><span class="file">.dtrace</span></samp> file as a FIFO (also
known as a &ldquo;named pipes&rdquo;).  Kvasir will then open first the <samp><span class="file">.decls</span></samp>
FIFO and then the <samp><span class="file">.dtrace</span></samp> FIFO, blocking until another program
(such as Daikon) reads from them.  Using FIFOs for the output of Kvasir
avoids the need for large trace files, but FIFOs are not supported by
some file systems, including AFS.

     <br><dt><samp><span class="option">--program-stdout=</span><var>filename</var></samp><dt><samp><span class="option">--program-stderr=</span><var>filename</var></samp><dd>
Redirect the standard output (respectively, standard error) stream of the
program being traced to the specified path.  By default, the standard
output and standard error streams will be left pointing to the same
locations specified by the shell, except that if <samp><span class="option">--dtrace-file=-</span></samp>
is specified, then the default behavior is as if
<samp><span class="option">--program-stdout=/dev/tty</span></samp> were specified, since mixing the
program's output and Kvasir's trace output is not advisable. 
If the same filename is given for both options, the streams will be
interleaved in the same way as if by the Bourne shell construction
<code>2&gt;&amp;1</code>.

     <p>Also, as in the shell, <var>filename</var> can be an ampersand followed by an
integer, to redirect to a numbered file descriptor.  For instance, to
redirect the program's standard output and error, and Kvasir's standard
error, to a single file, you can say <samp><span class="option">--program-stdout='&amp;2'
--program-stderr='&amp;2' 2&gt;</span><var>filename</var></samp>.

   </dl>

   <p>Selective program point and variable tracing:

     <dl>
<dt><samp><span class="option">--ppt-list-file=</span><var>filename</var></samp><dt><samp><span class="option">--var-list-file=</span><var>filename</var></samp><dd>
Trace only the program points (respectively, variables) listed in the
given file.  Other program points (respectively variables) will be
omitted from the <samp><span class="file">.decls</span></samp> and <samp><span class="file">.dtrace</span></samp> files.  A convenient
way to produce such files is by editing the output produced by the
<samp><span class="option">--dump-ppt-file</span></samp> (respectively, <samp><span class="option">--dump-var-file</span></samp>) option
described below.  (see <a href="#Tracing-only-part-of-a-program">Tracing only part of a program</a> section
for detailed instructions on using these options.)

     <br><dt><samp><span class="option">--dump-ppt-file=</span><var>filename</var></samp><dt><samp><span class="option">--dump-var-file=</span><var>filename</var></samp><dd>
Print a list of all the program points (respectively all the variables)
in the program to the specified file.  An edited version of this file can
then be used with the <samp><span class="option">--ppt-list-file</span></samp> (respectively
<samp><span class="option">--var-list-file</span></samp>) option. 
(see <a href="#Tracing-only-part-of-a-program">Tracing only part of a program</a> section
for detailed instructions on using these options.) 
Note: Do not use these options with the
<samp><span class="option">--with-dyncomp</span></samp> option because the behavior is undefined. 
Running Kvasir with these
options will initialize but not actually execute the target program, so
the dynamic comparability analysis cannot be performed in the first
place.

     <br><dt><samp><span class="option">--ignore-globals</span></samp><dd>
Omit any global or static variables from the <samp><span class="file">.decls</span></samp> and
<samp><span class="file">.dtrace</span></samp> files.  Leaving these out can significantly improve Kvasir
and Daikon's performance, at the expense of missing properties involving
them.  The default is to generate trace information for
global and static variables.

     <br><dt><samp><span class="option">--ignore-static-vars</span></samp><dd>
Omit any static variables but generate trace information for
global variables in the  <samp><span class="file">.decls</span></samp> and <samp><span class="file">.dtrace</span></samp> files.

     <br><dt><samp><span class="option">--all-static-vars</span></samp><dd>
Output all static variables at all program points in the <samp><span class="file">.decls</span></samp> and
<samp><span class="file">.dtrace</span></samp> files.  By default, file-static variables are only outputted at
program points for functions that are defined in the same file (compilation unit)
as the
variable, and static variables declared within a particular function are
only outputted at program points for that function.  These heuristics decrease
clutter in the output without greatly reducing precision because functions
have no easy way of modifying variables that are not in-scope, so it is often
not useful to output those variables.  This option turns off these heuristics
and always outputs static variables at all program points.

   </dl>

   <p>Other options affecting the amount of output Kvasir produces:

     <dl>
<dt><samp><span class="option">--object-ppts</span></samp><dd>Enables printing of object program points for C/C++ structs and C++
classes. See <a href="#Program-points">Program points</a> for more information.

     <br><dt><samp><span class="option">--flatten-arrays</span></samp><dd>This option forces the flattening of statically-sized arrays into
separate variables, one for each element.  For example, an array
<var>foo</var> of size 3 would be flattened into 3 variables: <var>foo[0]</var>,
<var>foo[1]</var>, <var>foo[2]</var>.  By default, Kvasir flattens
statically-sized arrays only after it has already exhausted the one
level of sequences that Daikon allows in the .dtrace output format
(e.g. an array of structs where each struct contains a statically-sized
array).

     <br><dt><samp><span class="option">--array-length-limit=</span><var>N</var></samp><dd>Only visit at most the first <var>N</var> elements of all arrays.  This can
improve performance at the expense of losing coverage; it is often
useful for tracing selected parts of programs that use extremely large
arrays or memory buffers.

     <br><dt><samp><span class="option">--output-struct-vars</span></samp><dd>This option forces Kvasir to output .decls and .dtrace entries for
struct variables.  By default, Kvasir ignores struct variables because
there is really no value that can be meaningfully associated with these
variables.  However, some tools require struct variables to be
outputted, so we have included this option.  Struct variables are
denoted by a <code># isStruct=true</code> annotation in their declarations.

     <br><dt><samp><span class="option">--nesting-depth=</span><var>N</var></samp><dd>
For recursively-defined structures (structs or classes with members that
are structs or classes or pointers to structs or classes of <em>any</em> type),
<var>N</var> (an integer between 0 and 100) specifies approximately how many levels
of pointers to dereference.  This is useful for controlling the output
of complex data structures with many references to other structures. 
The default is 2.

     <br><dt><samp><span class="option">--struct-depth=</span><var>N</var></samp><dd>
For recursively-defined structures (structs or classes with members that
are pointers to the <em>same</em> type of struct or class),
<var>N</var> (an integer between
0 and 100) specifies approximately how many levels of pointers to dereference. 
This is useful for controlling the output of linked lists and trees. 
The default is 4.  If you are trying to traverse deep into data
structures, try adjusting the <samp><span class="option">--struct-depth</span></samp> and
<samp><span class="option">--total-depth</span></samp> options until Kvasir traverses deep enough to
reach the desired variables.

   </dl>

   <p><a href="#Pointer-type-disambiguation">Pointer type disambiguation</a>:

     <dl>
<dt><samp><span class="option">--disambig-file=</span><var>filename</var></samp><dd>Specifies the name of the pointer type disambiguation file
(see <a href="#Pointer-type-disambiguation">Pointer type disambiguation</a>). 
If this file exists, Kvasir uses it to make decisions about how
to output the referents of pointer variables.  If the file does not exist,
then Kvasir creates it.  This file may then be edited and used on
subsequent runs.  This option initializes but does not fully execute the
target program (unless it is run with the <samp><span class="option">--smart-disambig</span></samp>
option).

     <br><dt><samp><span class="option">--disambig</span></samp><dd>Tells Kvasir to create or read pointer type disambiguation
(see <a href="#Pointer-type-disambiguation">Pointer type disambiguation</a>) with the default filename,
which is <samp><var>myprog</var><span class="file">.disambig</span></samp> in the same
directory as the target program, where <var>myprog</var> is the name of the
target program.  This is equivalent to
<samp><span class="option">--disambig-file=</span><samp><var>myprog</var><span class="file">.disambig</span></samp></samp>.

     <br><dt><samp><span class="option">--smart-disambig</span></samp><dd>This option should be used in addition to either the <samp><span class="option">--disambig</span></samp>
or <samp><span class="option">--disambig-file</span></samp> options (it does nothing by itself).  If the
.disambig file specified by the option does not exist, then Kvasir
executes the target program, observes whether each pointer refers to
either one element or an array of elements, and creates a disambiguation
file that contains suggestions for the disambiguation types of each
pointer variable.  This potentially provides more accuracy than using
either the <samp><span class="option">--disambig</span></samp> or <samp><span class="option">--disambig-file</span></samp> options alone,
but at the expense of a longer run time.  (If the .disambig file already
exists, then this option provides no extra functionality.)

     <br><dt><samp><span class="option">--func-disambig-ptrs</span></samp><dd>By default, Kvasir treats all pointers as arrays when outputting their
contents.  This option forces Kvasir to treat function parameters and
return values that are pointers as pointing to single values.  However,
all pointers nested inside of data structures pointed-to by parameters
and return values are still treated as arrays.  This is useful for
outputting richer data information for functions that pass parameters or
return values via pointers, which happens often in practice.

     <br><dt><samp><span class="option">--disambig-ptrs</span></samp><dd>By default, Kvasir treats all pointers as arrays when outputting their
contents.  This option forces Kvasir to treat all pointers as pointing to
single values.  This is useful when tracing nested structures with lots
of pointer fields which all refer to one element.

   </dl>

   <p><a href="#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a>:

     <dl>
<dt><samp><span class="option">--with-dyncomp</span></samp><dd>
Run Kvasir with the DynComp dynamic
comparability analysis tool to determine which variables have the same
abstract type. 
Variable comparability information can
improve the performance of Daikon and allow it to generate a more
focused and relevant set of invariants. 
Because it is not available until the end of execution, comparability
information is always written to a separate <samp><span class="file">.decls</span></samp> file (in the
format specified in the <a href="developer.html#Program-point-declarations">Program point declarations</a> section), as if
the <samp><span class="option">--decls-file</span></samp> option had been specified
(<samp><span class="option">--decls-file</span></samp> can still be used to control the name of the
file). 
This file must be provided to Daikon along with the <samp><span class="file">.dtrace</span></samp>
file. 
This option may also be used with <samp><span class="option">--decls-only</span></samp> to only generate
a <samp><span class="file">.decls</span></samp> file without a <samp><span class="file">.dtrace</span></samp>.

     <br><dt><samp><span class="option">--no-dyncomp-gc</span></samp><dd>
By default, DynComp runs with a garbage collector for the tag metadata
that it uses, but this can cause your program to slow down if it runs
too often.  This option turns off the garbage collector.  This is not
recommended for long program runs, because without the garbage
collector, it will likely run out of memory.

     <br><dt><samp><span class="option">--gc-num-tags=</span><var>N</var></samp><dd>
The DynComp garbage collector runs once after every 10,000,000 tags have
been assigned.  This option tells the garbage collector to run once
after every <var>N</var> tags have been assigned.  Making the value of
<var>N</var> larger allows your program to run faster (because the garbage
collector runs less frequently), but may cause your program to run out
of memory as well.  Making the value of <var>N</var> too small may cause your
program to never terminate if <var>N</var> is smaller than the total number
of tags that your program uses in steady state.  You will probably need
to experiment with tweaking this value in order to get DynComp to work
properly.

     <br><dt><samp><span class="option">--dyncomp-fast-mode</span></samp><dd>
This option applies an approximation for handling literal values which
greatly speeds up the performance of DynComp and drastically lowers its
memory usage, but at the expense of a slight loss in precision of the
generated comparability sets.  If you cannot get DynComp to successfully
run on a large program, even after tweaking <samp><span class="option">--gc-num-vars</span></samp>, try
turning on this option.

     <br><dt><samp><span class="option">--dyncomp-detailed-mode</span></samp><dd>
This option runs a more detailed (but more time- and space-intensive)
algorithm for tracking variable comparability.  It takes O(n^2) time and
space, whereas the default algorithm takes roughly O(n) time and space. 
However, it can produce more precise results.  Despite its name, this
mode can be used together with <samp><span class="option">--dyncomp-fast-mode</span></samp> to run the
more precise algorithm but still use an approximation for handling
literal values.  (This mode is still experimental and not well-tested
yet.)

     <br><dt><samp><span class="option">--separate-entry-exit-comp</span></samp><dd>
The default behavior for DynComp is to generate the same comparability
numbers for Daikon variables at each pair of function entrance and exit
program points.  If this option is used, then DynComp keeps track of
comparability separately for function entrances and exits, which can
lead to more accurate results, but sometimes generates output .decls
files that Daikon cannot accept.

     <br><dt><samp><span class="option">--dyncomp-dataflow-only</span></samp><dd>
When DynComp is operating in this mode, no binary operations qualify as
interactions between values.  Thus, DynComp only tracks dataflow.

     <br><dt><samp><span class="option">--dyncomp-dataflow-comp</span></samp><dd>
When DynComp is operating in this mode, the only binary operations that
qualify as interactions are comparisons between values (e.g., <code>x &lt;=
y</code> or <code>x != y</code>).

     <br><dt><samp><span class="option">--dyncomp-units</span></samp><dd>
When DynComp is operating in this mode, the only binary operations that
qualify as interactions are comparisons, addition, subtraction. 
This ensures that the variables that DynComp groups together into one
set all have the same units (e.g., physics units).

   </dl>

   <p>Debugging:

     <dl>
<dt><samp><span class="option">--xml-output-file=</span><var>filename</var></samp><dd>
Outputs a representation of data structures, functions, and variables in
the target program to an XML file in order to aid in debugging.  These
are all the entities that Kvasir tracks for a particular run of a target
program, so if you do not see an entity in this XML file, then you
should either adjust command-line options or contact us with a bug
report.

     <br><dt><samp><span class="option">--with-gdb</span></samp><dd>
This pauses the program's execution in an infinite loop during
initialization.  You can attach a debugger such as <code>gdb</code> to the
running process by running gdb on <samp><span class="file">inst/lib/valgrind/x86-linux/fjalar</span></samp> under
the Kvasir directory and using the <code>attach</code> command.

     <br><dt><samp><span class="option">--kvasir-debug</span></samp><dt><samp><span class="option">--fjalar-debug</span></samp><dt><samp><span class="option">--dyncomp-debug</span></samp><dd>
Enable progress messages meant for debugging problems with Kvasir, Fjalar, or
DynComp.  By default, they are disabled.  This option is intended mainly
for Kvasir's developers.

     <br><dt><samp><span class="option">--no-path-compression</span></samp><dt><samp><span class="option">--no-var-leader</span></samp><dt><samp><span class="option">--no-val-leader</span></samp><dd>
These disable optimizations to Dyncomp's abstract type inference
implementation. These are disabled by default. These options are
intended mainly for Dyncomp developers.

     <br><dt><samp><span class="option">--dyncomp-trace</span></samp><dt><samp><span class="option">--dyncomp-trace-merge</span></samp><dt><samp><span class="option">-- dyncomp-print-inc</span></samp><dd>
Enables trace messages to be output to stderr. These are disabled by
default. These options are intended mainly for Dyncomp developers.

     <br><dt><samp><span class="option">--gcc3</span></samp><dd>
Experimental option. This option improves Kvasir's support for GCC 3.x
created binaries. This option is fairly untested, but may be useful
for anyone attempting to run Kvasir on GCC 3.x created binaries. We
recommend the use of GCC 4.1 for creating binaries for use
with Kvasir. See <a href="#Kvasir-limitations">Kvasir limitations</a> for
more information.

   </dl>

<div class="node">
<p><hr>
<a name="DynComp-for-C%2fC++"></a>
<a name="DynComp-for-C_002fC_002b_002b"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tracing-only-part-of-a-program">Tracing only part of a program</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Kvasir-options">Kvasir options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Kvasir">Kvasir</a>

</div>

<h4 class="subsection">7.3.3 DynComp dynamic comparability (abstract type) analysis for C/C++</h4>

<p><a name="index-DynComp_002c-for-C_002fC_002b_002b-158"></a><a name="index-abstract-types_002c-for-C_002fC_002b_002b-159"></a><a name="index-comparability_002c-for-C_002fC_002b_002b-160"></a><a name="index-dynamic-comparability_002c-for-C_002fC_002b_002b-161"></a>
Kvasir comes with the DynComp dynamic comparability analysis tool, which
performs dynamic type inference to group variables at each program point
into comparability sets (see <a href="developer.html#Program-point-declarations">Program point declarations</a> for the
numeric representation format of these sets).  All variables in each
comparability set belong to the same &ldquo;abstract type&rdquo; of data that the
programmer likely intended to represent, which is a richer set of types
than the few basic declared types (e.g., int, float) provided by the
language.  Consider the example below:

<pre class="example">     int main() {
       int year = 2005;
       int winterDays = 58;
       int summerDays = 307;
       compute(year, winterDays, summerDays);
     }
     
     int compute(int yr, int d1, int d2) {
       if (yr % 4)
         return d1 + d2;
       else
         return d1 + d2 + 1;
     }
</pre>
   <p>The three variables in <code>main()</code> all have the same C representation
type, <code>int</code>, but two of them hold related quantities (numbers of
days), as can be determined by the fact that they interact when the
program adds them, whereas the other contains a conceptually distinct
quantity (a year).  The abstract types 'day' and 'year' are both
represented as <code>int</code>, but DynComp can differentiate them with its
dynamic analysis.  For example, DynComp can infer that <code>winterDays</code>
and <code>summerDays</code> are comparable (belong to the same abstract type)
because the program adds their values together within the
<code>compute()</code> function.

   <p>Without comparability information, Daikon attempts to find invariants
over all pairs (and sometimes triples) of variables present at every
program point.  This can lead to two negative consequences: First, it
may take lots of time and memory to infer all of these invariants,
especially when there are many global or derived variables present. 
Second, many of those invariants are true but meaningless because they
relate variables which conceptually represent different types (e.g., an
invariant such as <code>winterDays &lt; year</code> is true but meaningless
because days and years are not comparable).

   <p>Use the <samp><span class="option">--with-dyncomp</span></samp> option to run Kvasir with DynComp to
generate a <samp><span class="file">.decls</span></samp> file with comparability information along with
the usual value trace in the <samp><span class="file">.dtrace</span></samp> file.  Using
<samp><span class="option">--decls-only</span></samp> will only generate the <samp><span class="file">.decls</span></samp> file without
the extra slowdown of writing the <samp><span class="file">.dtrace</span></samp> file to disk (however,
because DynComp must execute the entire program to perform its analysis,
the only time saved is I/O time).  Other DynComp options are listed in
the <a href="#Kvasir-options">Kvasir options</a> section.  Running Kvasir with DynComp takes
more memory and longer time than running Kvasir alone, but remember that
DynComp only needs to be run once to generate a <samp><span class="file">.decls</span></samp> file with
comparability information.  That one file can be passed into Daikon along
with many different <samp><span class="file">.dtrace</span></samp> files generated during subsequent
Kvasir runs without DynComp.

   <p>Here is part of the <samp><span class="file">.decls</span></samp> file generated by running Kvasir with
DynComp on the above example:

<pre class="smallexample">     DECLARE
     ..compute():::ENTER
     yr
     int # isParam=true
     int
     1
     d1
     int # isParam=true
     int
     2
     d2
     int # isParam=true
     int
     2
     
     DECLARE
     ..compute():::EXIT0
     yr
     int # isParam=true
     int
     1
     d1
     int # isParam=true
     int
     2
     d2
     int # isParam=true
     int
     2
     return
     int
     int
     2
</pre>
   <p>The abstract type of 'year' (and its corresponding comparability set) is
represented by the number 1 while the abstract type of 'day' is
represented by the number 2.  DynComp places two variables in the same
comparability set when their values interact via program operations such
as arithmetic or assignment.  Because the parameters <code>d1</code> and
<code>d2</code> were added together, DynComp inferred that those variables
were somehow related and put them in the same comparability set.  The
return value is also related to <code>d1</code> and <code>d2</code> because it is
the result of the addition operation.  Notice that <code>yr</code> never
interacts with any other variables, so DynComp places it into its own
comparability set.  With this comparability information, Daikon will
never attempt to find invariants between <code>yr</code> and
<code>d1</code>/<code>d2</code>, which both saves time and memory and eliminates
meaningless invariants (the savings are miniscule in this trivial
example, but they can be rather dramatic in larger examples).

<div class="node">
<p><hr>
<a name="Tracing-only-part-of-a-program"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pointer-type-disambiguation">Pointer type disambiguation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Kvasir">Kvasir</a>

</div>

<h4 class="subsection">7.3.4 Tracing only part of a program</h4>

<p>When Kvasir is run on a target program of significant size, often times
too much output is generated, which causes an enormous performance
slowdown of both Kvasir outputting the trace file and also Daikon trying
to process the trace file.  It is often desirable to only trace a
specific portion of the target program, program points and variables
that are of interest for a particular invariant detection application. 
For instance, one may only be interested in tracking changes in a
particular global data structure during calls to a specific set of
functions (program points), and thus have no need for information about
any other program points or variables in the trace file.  The
<samp><span class="option">--ppt-list-file</span></samp> and <samp><span class="option">--var-list-file</span></samp> options can be
used to achieve such selective tracing.

   <p>The program point list file (abbreviated as <samp><span class="file">ppt-list-file</span></samp>)
consists of a newline-separated list of names of functions that the
user wants Kvasir to trace.  Every name corresponds to both the entrance
(<code>:::ENTER</code>) and exit (<code>:::EXIT</code>) program points for that function
and is printed out in the exact same format that Kvasir
uses for that function in the trace file (see <a href="#Using-Kvasir">Using Kvasir</a>
section for the program point naming scheme).  Here is an
example of a <samp><span class="file">ppt-list-file</span></samp>:

<pre class="example">     FunctionNamesTest.cpp.staticFoo(int, int)
     ..firstFileFunction(int)
     ..main()
     second_file.cpp.staticFoo(int, int)
     ..secondFileFunction()
</pre>
   <p>It is very important to follow this format in the <samp><span class="file">ppt-list-file</span></samp>
because Kvasir performs string comparisons to determine which program
points to trace.  Thus, it is often easier to have Kvasir generate a
<samp><span class="file">ppt-list-file</span></samp> file that contains a list of all program points in a
target program by using the <samp><span class="option">--dump-ppt-file</span></samp> option, and then
either comment out (by using the <code>'#'</code> comment character at the
beginning of the line) or delete lines in that file for program points
not to be traced or create a new <samp><span class="file">ppt-list-file</span></samp> using the names in
the Kvasir-generated file.  This prevents typos and the tedium of
manually typing up program point names.  In fact, the <samp><span class="file">ppt-list-file</span></samp>
presented in the above example was generated from a C++ test program named
<code>FunctionNamesTest</code> by using the following command:

<pre class="example">     kvasir-dtrace --dump-ppt-file=FunctionNamesTest.ppts  ./FunctionNamesTest
</pre>
   <p>That file represents all the program points that Kvasir would
normally trace.  If the user wanted to only trace the <code>main()</code>
function, he could comment out all other lines by placing a single
<code>'#'</code> character at the beginning of each line to be commented out,
as demonstrated here:

<pre class="example">     #FunctionNamesTest.cpp.staticFoo(int, int)
     #..firstFileFunction(int)
     ..main()
     #second_file.cpp.staticFoo(int, int)
     #..secondFileFunction()
</pre>
   <p class="noindent">When running Kvasir with the <samp><span class="option">--ppt-list-file</span></samp> option using this
as the <samp><span class="file">ppt-list-file</span></samp>, Kvasir only stops the execution of the target program at the
entrance and exit of <code>main()</code> in order to output values to the
.dtrace file.  In order to reduce the file size, when running Kvasir
with the <samp><span class="option">--ppt-list-file</span></samp> option, the .decls file only contains
program point declarations for those listed in the <samp><span class="file">ppt-list-file</span></samp>
(<code>..main():::ENTER</code> and <code>..main():::EXIT</code> in this case) because
no other declarations are necessary.

   <p>The variable list file (abbreviated as <samp><span class="file">var-list-file</span></samp>) contains
all of the variables that the user wants Kvasir to output.  There is one
section for global variables and a section for variables associated with
each function (formal parameters and return values).  Again, the best way to
create a <samp><span class="file">var-list-file</span></samp> is to have Kvasir generate a file with all
variables using the <samp><span class="option">--dump-var-file</span></samp> option and then modifying
that file for one's particular needs by either deleting or
commenting out lines (again using the <code>'#'</code> comment character).  For example,
executing

<pre class="example">     kvasir-dtrace --dump-var-file=FunctionNamesTest.vars  ./FunctionNamesTest
</pre>
   <p class="noindent">will generate the following <samp><span class="file">var-list-file</span></samp> named
<code>FunctionNamesTest.vars</code>:

<pre class="example">     ----SECTION----
     globals
     /globalIntArray
     /globalIntArray[]
     /anotherGlobalIntArray
     /anotherGlobalIntArray[]
     
     
     ----SECTION----
     FunctionNamesTest.cpp.staticFoo()
     x
     y
     
     
     ----SECTION----
     ..firstFileFunction(int)
     blah
     
     
     ----SECTION----
     ..main()
     argc
     argv
     argv[]
     return
     
     
     ----SECTION----
     second_file.cpp.staticFoo()
     x
     y
     
     
     ----SECTION----
     ..secondFileFunction()
</pre>
   <p>The file format is straightforward.  Each section is marked by a
special string &ldquo;<code>----SECTION----</code>&rdquo; on a line by itself followed
immediately by a line that either denotes the program point name
(formatted like how it appears in the .decls and .dtrace files) or the
special string &ldquo;<code>globals</code>&rdquo;.  This is followed by a
newline-delimited list of all variables to be outputted for that
particular program point.  Global variables listed in the
<code>globals</code> section are outputted for all program points. Additional global
variables to be outputted for a particular program point can be specified
in the corresponding section entry. For clarity, one or more blank lines
should separate neighboring sections, although the &ldquo;<code>----SECTION----</code>&rdquo;
string literal on a line by itself is the only required delimiter. 
If an entire section is missing, then no variables for that program point
(or no global variables, if it is the special globals section) are traced.

   <p>The variables listed in this file are written exactly as they appear in
the .decls and .dtrace file (see <a href="#Using-Kvasir">Using Kvasir</a> section
for the variable naming scheme).  In the program that generated the
output for the above example, <code>int*
globalIntArray</code> is a global integer pointer variable.  For that
variable, Kvasir generates two Daikon variables: <code>/globalIntArray</code>
to represent the hashcode pointer value, and <code>/globalIntArray[]</code> to
represent the array of integers referred-to by that pointer.  The
latter is a derived-variable that can be thought of as the child of
<code>/globalIntArray</code>.  If the entry for <code>/globalIntArray</code> is
commented-out or missing, then Kvasir will not output any values for
<code>/globalIntArray</code> or for any of its children, which in this case is
<code>/globalIntArray[]</code>.  If a struct or struct pointer variable is
commented-out or missing, then none of its members are traced.  Thus, a
general rule about variable entries in the <samp><span class="file">var-list-file</span></samp> is that
if a parent variable is not present, then neither it nor its children
are traced.

<pre class="example">     
     record
     record-&gt;entries[1]
     record-&gt;entries[1]-&gt;list
     record-&gt;entries[1]-&gt;list-&gt;head
     record-&gt;entries[1]-&gt;list-&gt;head-&gt;magic
     
</pre>
   <p>For example, if you wanted to trace the value of the <code>magic</code> field
nested deep within several layers of structs and arrays, it would not be
enough to merely list this variable in the <samp><span class="file">var-list-file</span></samp>.  You
would need to list all variables that are the parents of this one, as
indicated by their names.  This can be easily accomplished by creating a
file with <samp><span class="option">--dump-var-file</span></samp> and cutting out variable entries,
taking care to not cut out entries that are the parents of entries that
you want to trace.

   <p>In order to limit both the number of program points traced as well as
the variables traced at those program points, the user can run Kvasir
with both the <samp><span class="option">--ppt-list-file</span></samp> and <samp><span class="option">--var-list-file</span></samp>
options with the appropriate <samp><span class="file">ppt-list-file</span></samp> and
<samp><span class="file">var-list-file</span></samp>, respectively.  The <samp><span class="file">var-list-file</span></samp> only needs
to contain a section for global variables and sections for all program
points to be traced because variable listings for program points not to
be traced are irrelevant (their presence in the <samp><span class="file">var-list-file</span></samp>
does not affect correctness but does cause an unnecessary
performance and memory inefficiency).

   <p>If the <samp><span class="option">--dump-var-file</span></samp> option is used in conjunction with the
<samp><span class="option">--ppt-list-file</span></samp> option, then the only sections generated in the
<samp><span class="file">var-list-file</span></samp> will be the global section and sections for all
program points explicitly mentioned in the <samp><span class="file">ppt-list-file</span></samp>.  This
is helpful for generating a smaller <samp><span class="file">var-list-file</span></samp> for use with an
already-existent <samp><span class="file">ppt-list-file</span></samp>.

<div class="node">
<p><hr>
<a name="Pointer-type-disambiguation"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#C_002b_002b-support">C++ support</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tracing-only-part-of-a-program">Tracing only part of a program</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Kvasir">Kvasir</a>

</div>

<h4 class="subsection">7.3.5 Pointer type disambiguation</h4>

<p><a name="index-pointer-type-disambiguation-162"></a><a name="index-disambiguation-of-pointer-types-163"></a>
Kvasir permits users (or external analyses) to specify whether pointers
refer to arrays or to single values, and optionally, to specify the type
of a pointer (see <a href="#Pointer-type-coercion">Pointer type coercion</a>).  For example, in
<pre class="example">     void sum(int* array, int* result) { ... }  // definition of "sum"
     ...
     int a[40];
     int total;
     ...
     sum(a, &amp;total);        // use of "sum"
</pre>
   <p class="noindent">the first pointer parameter refers to an array while the second refers to
a single value.  Kvasir (and Daikon) should treat these values
differently.  For instance, <code>*array</code> is better printed as <code>array[]</code>,
an array of integers, and <code>result[]</code> isn't a sensible array
at all, even though in C <code>result[0]</code> is semantically identical to
<code>*result</code>. 
By default, Kvasir treats all pointers as referencing arrays.  For
instance, it would print <code>result[]</code> rather than <code>result[0]</code>
and would indicate that the length of array <code>result[]</code> is always 1. 
In order to improve the formatting of Daikon's output (and to speed it
up), you can indicate to Kvasir that certain pointers refer to single
elements rather than to arrays. 
For an example, see <a href="#Pointer-type-disambiguation-example">Pointer type disambiguation example</a>).

   <p>Information about whether each pointer refers to an array or a single
element can be specified in a &ldquo;disambig file&rdquo; that resides in the
same directory as the target program (by default).  The <samp><span class="option">--disambig</span></samp>
option instructs Kvasir to read this file if it exists.  (If it does not exist,
Kvasir produces the file automatically and, if invoked along with the
<samp><span class="option">--smart-disambig</span></samp> option, heuristically infers whether each
pointer variable refers to single or multiple elements.  Thus, users can
edit this file for use on subsequent runs rather than having to create it
from scratch.)  The disambig file lists all the program points and user-defined
types, and under each, lists certain types of variables along with their
custom disambiguation types as shown below. 
The list of disambiguation options is:

     <ol type=1 start=1>
<li>For variables of type <code>char</code> and <code>unsigned char</code>:
          <ol type=1 start=1>
<li>'I': an integer, signed for <code>char</code> and unsigned for <code>unsigned char</code>. (Default)
<li>'C': a single character, output as a string.
          </ol>
<li>For pointers to (or arrays of) <code>char</code> and <code>unsigned char</code>:
          <ol type=1 start=1>
<li>'S': a string, possibly zero-terminated. (Default)
<li>'C': a single character, output as a string. 
<li>'A': an array of integers. 
<li>'P': a single integer.
          </ol>
<li>For pointers to (or arrays of) all other variable types (if invoked
along with <samp><span class="option">--smart-disambig</span></samp>, Kvasir automatically infers a default 'A' or 'P' for each variable during the generation of a <samp><span class="file">.disambig</span></samp> file):
          <ol type=1 start=1>
<li>'A': an array.  (Default) (For an array of structs, an array will be output for each scalar field of the struct.  Aggregate children (arrays, other structs) will not be output.) 
<li>'P': a pointer to a single element.  (For a pointer to a struct, each
field will be output as a single instance, and child aggregate types
will be output recursively.  This extra information obtained from struct
pointers is a powerful consequence of pointer type disambiguation.  This
will be the default if the <samp><span class="option">--disambig-ptrs</span></samp> option is used.)
          </ol>
        </ol>

   <p>The disambig file that Kvasir creates contains a section for each
function, which can be used to disambiguate parameter variables visible
at that function's entrance program point and parameter and return
value variables visible at that function's exit program point.  It also contains
a section for every user-defined
struct/class, which can be used to disambiguate member variables of
that struct/class.  Disambiguation information entered here will apply to all
instances of a struct/class of that type, at all program points. 
There is also a section called &ldquo;globals&rdquo;, which disambiguates global
variables which are output at every program point.  The entries in the
disambig file may appear in any order, and whole entries or individual
variables within a section may be omitted.  In this case, Kvasir will
retain their default values.

<ul class="menu">
<li><a accesskey="1" href="#Pointer-type-coercion">Pointer type coercion</a>
<li><a accesskey="2" href="#Pointer-type-disambiguation-example">Pointer type disambiguation example</a>
<li><a accesskey="3" href="#Using-pointer-type-disambiguation-with-partial-program-tracing">Using pointer type disambiguation with partial program tracing</a>
</ul>

<div class="node">
<p><hr>
<a name="Pointer-type-coercion"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pointer-type-disambiguation-example">Pointer type disambiguation example</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pointer-type-disambiguation">Pointer type disambiguation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointer-type-disambiguation">Pointer type disambiguation</a>

</div>

<h5 class="subsubsection">7.3.5.1 Pointer type coercion</h5>

<p>In addition to specifying whether a particular pointer refers to one
element or to an array of elements, the user can also specify what type
of data a pointer refers to.  This type coercion acts like an explicit
type cast in C, except that it only works on struct/class types and not
on primitive types.  This feature is useful for traversing inside of
data structures with generic <code>void*</code> pointer fields.  Another use
is to cast a pointer from one that refers to a 'super class' to one that
refers to a 'sub class'.  This structural equivalence pattern is often
found in C programs that emulate object orientation.  To coerce a
pointer to a particular type, simply write the name of the struct type
after the disambiguation letter (e.g., A, P, S, C, I) in the
<samp><span class="file">.disambig</span></samp> file:

<pre class="example">     ----SECTION----
     function: ..view_foo_and_bar()
     f
     P foo
     b
     P bar
</pre>
   <p>Without the type coercion, Kvasir cannot print out anything except for a
hashcode for the two <code>void*</code> parameters of this function:

<pre class="example">     void view_foo_and_bar(void* f, void* b);
</pre>
   <p>With type coercion, though, Kvasir treats <code>f</code> as a <code>foo*</code> and
<code>b</code> as <code>bar*</code> and can traverse inside of them.  Of course, if
those are not the true runtime types of the variables, then Kvasir's
output will be meaningless.

   <p>Due to the use of typedefs, there may be more than one name for a
particular struct type.  The exact name that you need to write in the
<samp><span class="file">.disambig</span></samp> file is the one that appears in that file after the
<code>usertype</code> prefix.  Note that if a struct does not have any pointer
fields, then there will be no <code>usertype</code> section for it in the
<samp><span class="file">.disambig</span></samp> file.  In that case, try different names for the struct
if necessary until Kvasir accepts the name (names are all one word long;
you will never have to write <code>struct foo</code>).  There should only be
at most a few choices to make.  If the coercion if successful, Kvasir
prints out a message in the following form while it is processing the
<samp><span class="file">.disambig</span></samp> file:

<pre class="example">       .disambig: Coerced variable f into type 'foo'
       .disambig: Coerced variable b into type 'bar'
</pre>
   <p>One more caveat about type coercion is that you can currently only
coerce pointers into types that at least one variable in the program
(e.g., globals, function parameters, struct fields) belongs to.  It is
not enough to merely declare a struct type in your source code; you must
have a variable of that type somewhere in your program.  This is a
limitation of the current implementation, but it should not matter most
of the time because programs rarely have struct declarations with no
variables that belong to that type.  If you encounter this problem, you
can simply create a global variable of a certain type to make type
coercion work.

<div class="node">
<p><hr>
<a name="Pointer-type-disambiguation-example"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-pointer-type-disambiguation-with-partial-program-tracing">Using pointer type disambiguation with partial program tracing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pointer-type-coercion">Pointer type coercion</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointer-type-disambiguation">Pointer type disambiguation</a>

</div>

<h5 class="subsubsection">7.3.5.2 Pointer type disambiguation example</h5>

<p>This example demonstrates the power of pointer type disambiguation in creating
more accurate Daikon output.  Consider this file:

<pre class="smallexample">     struct record {
       char* name;     // Initialize to: "Daikon User"
       int numbers[5]; // Initialize to: {5, 4, 3, 2, 1}
     };
     
     void foo(struct record* bar) {
       int i;
       for (i = 0; i &lt; 5; i++) {
         bar-&gt;numbers[i] = (5 - i);
       }
     }
     
     int main() {
       char* myName = "Daikon User";
       struct record baz;
       baz.name = myName;
       foo(&amp;baz);
     }
</pre>
   <p>In <code>foo()</code>, <code>bar</code> is a pointer to a  <code>record</code> struct.  By inspection, it is
evident that in this program, <code>bar</code> only refers to one element: <code>&amp;baz</code>
within <code>main</code>.  However, by default, Kvasir assumes that <code>bar</code> is an
array of <code>record</code> structs since a C pointer contains no information about
how many elements it refers to.  Because Kvasir must output <code>bar</code> as an
array and <code>bar-&gt;numbers</code><!-- /@w --> is an array of integers, it &ldquo;flattens&rdquo;
<code>bar-&gt;numbers</code><!-- /@w --> into 5 separate arrays named <code>bar-&gt;numbers[0]</code><!-- /@w -->
through <code>bar-&gt;numbers[4]</code><!-- /@w -->
and creates fairly verbose output.  This is a direct
consequence of the fact that Daikon can only handle one layer of sequences
(it cannot handle arrays within arrays, i.e., multi-dimensional arrays).

   <p>Here is part of the Daikon output for this program:

<pre class="smallexample">     ======================================================================
     ..foo():::ENTER
     bar has only one value
     bar[].name == [Daikon User]
     bar[].name elements == "Daikon User"
     ======================================================================
     ..foo():::EXIT
     size(bar[]).numbers[0] == size(bar[]).numbers[0][0]
     size(bar[]).numbers[0] == size(bar[]).numbers[1]
     size(bar[]).numbers[0] == size(bar[]).numbers[1][0]
     size(bar[]).numbers[0] == size(bar[]).numbers[2]
     size(bar[]).numbers[0] == size(bar[]).numbers[2][0]
     size(bar[]).numbers[0] == size(bar[]).numbers[3]
     size(bar[]).numbers[0] == size(bar[]).numbers[3][0]
     size(bar[]).numbers[0] == size(bar[]).numbers[4]
     size(bar[]).numbers[0] == size(bar[]).numbers[4][0]
     bar[].name == [Daikon User]
     bar[].name elements == "Daikon User"
     bar[].numbers[0] contains no nulls and has only one value, of length 1
     bar[].numbers[0] elements has only one value
     bar[].numbers[0][0] == [5]
     bar[].numbers[0][0] elements == 5
     bar[].numbers[1] contains no nulls and has only one value, of length 1
     bar[].numbers[1] elements has only one value
     bar[].numbers[1][0] == [4]
     bar[].numbers[1][0] elements == 4
     bar[].numbers[2] contains no nulls and has only one value, of length 1
     bar[].numbers[2] elements has only one value
     bar[].numbers[2][0] == [3]
     bar[].numbers[2][0] elements == 3
     bar[].numbers[3] contains no nulls and has only one value, of length 1
     bar[].numbers[3] elements has only one value
     bar[].numbers[3][0] == [2]
     bar[].numbers[3][0] elements == 2
     bar[].numbers[4] contains no nulls and has only one value, of length 1
     bar[].numbers[4] elements has only one value
     bar[].numbers[4][0] == [1]
     bar[].numbers[4][0] elements == 1
     size(bar[]).numbers[0] == 1
     bar[].numbers[4][0] elements == size(bar[]).numbers[0]
     size(bar[]).numbers[0] in bar[].numbers[4][0]
</pre>
   <p>This is a bit verbose due to the fact that Kvasir treats <code>bar</code> like an array
by default when it actually only points to one element.  However, by running
Kvasir with the <samp><span class="option">--disambig</span></samp> option, we create the
<samp><var>myprog</var><span class="file">.disambig</span></samp> file, which we can then edit and feed back to
Kvasir to change how the pointer is treated.  (We run Kvasir twice on the same
program, but we edit the <samp><span class="file">.disambig</span></samp> file in between the runs.)
<pre class="example">     kvasir-dtrace <var>...options...</var> --disambig --smart-disambig <var>myprog</var>
</pre>
   <p>This creates the <samp><var>myprog</var><span class="file">.disambig</span></samp> file.  It contains, at the top:

<pre class="smallexample">     ----SECTION----
     function: ..foo()
     bar
     P
</pre>
   <p>This means that at the program points corresponding to the entry and
exit of <code>foo()</code>, the variable <code>bar</code> is treated as a
&lsquo;<samp><span class="samp">P</span></samp>&rsquo;ointer type. 
Since we have used the <samp><span class="option">--smart-disambig</span></samp> option,
Kvasir automatically inferred Pointer instead of Array for <code>bar</code>
because it observed that <code>bar</code> only pointed to one element during the
execution of the target program which generated the <samp><span class="file">.disambig</span></samp> file. 
This heuristic allows users to use
<samp><span class="file">.disambig</span></samp> files more effectively with less manual editing. 
Without <samp><span class="option">--smart-disambig</span></samp>, Kvasir does not execute the program
to make such inferences, which allows .disambig files to be generated
faster, but leaves the default disambiguation types for all entries (in
this case, <code>bar</code> would have the default array type of
<code>'A'</code>).

   <p>Then, running Kvasir again with the <samp><span class="option">--disambig</span></samp>
option causes Kvasir to open the existing
<samp><var>myprog</var><span class="file">.disambig</span></samp> file, read the definitions, and alter
the output accordingly:
<pre class="example">     kvasir-dtrace <var>...options...</var> --disambig <var>myprog</var>
</pre>
   <p>This tells Kvasir to output <code>bar</code> as a &lsquo;<samp><span class="samp">P</span></samp>&rsquo;ointer to a single
element, which in turn causes Daikon to generate a much more concise
set of invariants.  Notice that <code>bar-&gt;numbers</code><!-- /@w --> no longer has to be
&ldquo;flattened&rdquo; because <code>bar</code> is now a pointer to one struct, so
Daikon can recognize <code>bar-&gt;numbers</code><!-- /@w --> as a single-dimensional
array (Daikon uses a Java-like syntax, replacing the arrow '-&gt;' symbol
with a dot, so it actually outputs <code>bar.numbers</code>).

<pre class="smallexample">     ======================================================================
     ..foo():::ENTER
     bar has only one value
     bar.name == "Daikon User"
     ======================================================================
     ..foo():::EXIT
     bar.name == "Daikon User"
     bar.numbers has only one value
     bar.numbers[] == [5, 4, 3, 2, 1]
     size(bar.numbers[]) == 5
     bar.name == orig(bar.name)
     size(bar.numbers[]) in bar.numbers[]
     size(bar.numbers[])-1 in bar.numbers[]
</pre>
   <div class="node">
<p><hr>
<a name="Using-pointer-type-disambiguation-with-partial-program-tracing"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pointer-type-disambiguation-example">Pointer type disambiguation example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointer-type-disambiguation">Pointer type disambiguation</a>

</div>

<h5 class="subsubsection">7.3.5.3 Using pointer type disambiguation with partial program tracing</h5>

<p>It is possible to use pointer type disambiguation while only tracing
selected program points and/or variables in a target program, combining
the functionality described in the <a href="#Pointer-type-disambiguation">Pointer type disambiguation</a> and
<a href="#Tracing-only-part-of-a-program">Tracing only part of a program</a> sections.  This section describes
the interaction of the <samp><span class="file">ppt-list-file</span></samp>, <samp><span class="file">var-list-file</span></samp>, and
.disambig files.

   <p>The interaction between selective program point tracing (via
the <samp><span class="file">ppt-list-file</span></samp>) and pointer type disambiguation is fairly
straightforward:  If the user creates a .disambig file while running
Kvasir with a <samp><span class="file">ppt-list-file</span></samp> that only specifies certain program
points, the generated .disambig file will only contain sections for
those program points (as well as the global section and sections for
each struct type).  If the user reads in a .disambig file while running
Kvasir with a <samp><span class="file">ppt-list-file</span></samp>, then disambiguation information is
applied for all variables at the program points to be traced.  This can
be much faster and generate a much smaller disambiguation file, one that
only contains information about the program points of interest.

   <p>The interaction between selective variable tracing (via the
<samp><span class="file">var-list-file</span></samp>) and pointer type disambiguation is a bit more
complicated.  This is because the <samp><span class="file">var-list-file</span></samp> lists variables
as they appear in the .decls and .dtrace files, but using a .disambig
file can actually change the way that variable names are printed out in
the .decls and .dtrace files.  For example, consider the test program
from the <a href="#Pointer-type-disambiguation-example">Pointer type disambiguation example</a>.  The <code>struct
record* bar</code> parameter of <code>foo()</code> is treated like an array by
default.  Hence, the .decls, .dtrace, and <samp><span class="file">var-list-file</span></samp> will list
the following variables derived from this parameter:

<pre class="example">     ----SECTION----
     ..foo()
     bar
     bar[].name
     bar[].numbers[0]
     bar[].numbers[0][0]
     bar[].numbers[1]
     bar[].numbers[1][0]
     bar[].numbers[2]
     bar[].numbers[2][0]
     bar[].numbers[3]
     bar[].numbers[3][0]
     bar[].numbers[4]
     bar[].numbers[4][0]
</pre>
   <p>However, if we use a disambiguation file to denote <code>bar</code> as a
pointer to a single element, then the .decls and .dtrace files will
instead list the following variables:

<pre class="example">     ----SECTION----
     ..foo()
     bar
     bar-&gt;name
     bar-&gt;numbers
     bar-&gt;numbers[]
</pre>
   <p>Notice how the latter variable list is more compact and reflects the
fact that <code>bar</code> is a pointer to a single struct.  Thus, the
flattening of the <code>numbers[5]</code> static array member variable is no
longer necessary (it was necessary without disambiguation because Daikon
does not support nested arrays of arrays, which can occur if <code>bar</code>
were itself an array since <code>numbers[5]</code> is already an array).

   <p>Notice that, with the exception of the base variable <code>bar</code>, all
other variable names differ when running without and with
disambiguation.  Thus, if you used a <samp><span class="file">var-list-file</span></samp> generated on a
run without the disambiguation information while running Kvasir with the
disambiguation information, the names will not match up at all, and you
will not get the proper selective variable tracing behavior.

   <p>The suggested way to use selective variable tracing with pointer type
disambiguation is as follows:

     <ol type=1 start=1>
<li>First create the proper .disambig file by using either
<samp><span class="option">--disambig</span></samp> or <samp><span class="option">--disambig-file</span></samp>. 
You can use <samp><span class="option">--ppt-list-file</span></samp> as well to only create the
.disambig file for certain program points, but do NOT use
<samp><span class="option">--var-list-file</span></samp> to try to create a .disambig only for certain
variables; this feature does not work yet. 
Modify the variable
entries in the Kvasir-generated .disambig file to suit your needs. 
<li>Now create a <samp><span class="file">var-list-file</span></samp> by using
<samp><span class="option">--dump-var-file</span></samp> while running Kvasir with the .disambig file
that you have just created.  This ensures that the variables listed in
<samp><span class="file">var-list-file</span></samp> will have the proper names for use with that
particular .disambig file.  Modify the Kvasir-generated
<samp><span class="file">var-list-file</span></samp> to suit your needs. 
<li>Finally, run Kvasir with the <samp><span class="option">--var-list-file</span></samp> option using
the <samp><span class="file">var-list-file</span></samp> that you have just created and either the
<samp><span class="option">--disambig</span></samp> or <samp><span class="option">--disambig-file</span></samp> option with the proper
.disambig file.  This will perform the desired function: selective
variable tracing along with disambiguation for all of the traced
variables.
        </ol>

   <p>For maximum control of the output, you can use selective program point
tracing, variable tracing, and disambiguation together all at once.

<div class="node">
<p><hr>
<a name="C++-support"></a>
<a name="C_002b_002b-support"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Online-execution">Online execution</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pointer-type-disambiguation">Pointer type disambiguation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Kvasir">Kvasir</a>

</div>

<h4 class="subsection">7.3.6 C++ support</h4>

<p>Kvasir supports C++, but Kvasir has been tested more on C programs than
on C++ programs, so Kvasir's C++ support is not as mature as its C support. 
Here is a partial list of C++ features that Kvasir currently supports:

     <ul>
<li>Class member functions are traced just like regular functions, except
that their first parameter is a pointer (called <code>this</code>) to a single
instance of the class.  They are printed with the class name as the
prefix, followed by a period and then the full function signature.  For
example, a <code>push()</code> function of a <code>Stack</code> class might be named
<code>Stack.push(char*)</code>.

     <li>OBJECT program points (see <a href="#Program-points">Program points</a>) are printed out in the
.decls file for each class with at least 1 member variable and 1 member
function.  No extra information besides member function traces are
required in the .dtrace file; Daikon can link together class and
function names to determine when a particular function is a member
function and generate object invariants for that class by observing the
values of the <code>this</code> parameter.

     <li>Static member variables are currently treated just like global
variables, because they actually have static global locations.  Another
(not yet implemented) possibility is to only print them at program
points of member functions belonging to the respective variable's own
class.

     <li>Inheritance is handled correctly because whenever Kvasir traverses
inside of a class to print out its member variables, it also recursively
traverses inside all superclasses (and inside their superclasses,
etc...) to print out inherited member variables.  The superclass class
names are appended onto the variable names to make them unique.  For
example, if <code>this</code> is an instance of a class that inherits from
another class called <code>fooClass</code> which has a member variable
<code>fooVar</code>, then Kvasir prints out <code>fooVar</code> as
<code>this-&gt;fooClass.fooVar</code>.  This correctly handles the case of
multiple inheritance as well as several layers of inheritance.  Thus,
object invariants capture properties of a class's own member variables
as well as those of its superclasses' member variables.

     <li>Inheritance-based polymorphism is handled correctly without any extra
effort because when a function entrance or exit is encountered at run
time, the version that is called has already been resolved.

     <li>Overloaded functions are handled correctly because Kvasir prints out the
full function signature as its name in order to prevent conflicts.  For
example, two overloaded versions of a function <code>foo()</code> will be
disambiguated by their signatures, such as <code>foo(int, int)</code> and
<code>foo(double, double)</code>.

     <li>Kvasir handles functions that pass parameters by reference as well as
those that pass parameters by value.

   </ul>

   <p>One current C++ limitation is that Kvasir cannot print out the contents
of classes which are defined in external libraries rather than in the
user's program (e.g., it can properly output a C-string represented as
<code>char*</code> but not the contents of the C++ <code>string</code> class).  If
further support for specific C++ features are important to you, please
send email to <a href="mailto:daikon-developers@lists.csail.mit.edu">daikon-developers@lists.csail.mit.edu</a>, so that we
can increase its priority on our to-do list.

<div class="node">
<p><hr>
<a name="Online-execution"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installing-Kvasir">Installing Kvasir</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#C_002b_002b-support">C++ support</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Kvasir">Kvasir</a>

</div>

<h4 class="subsection">7.3.7 Online execution</h4>

<p><a name="index-online-execution_002c-for-C-programs-164"></a><a name="index-on_002dthe_002dfly-execution_002c-for-C-programs-165"></a>
The term &ldquo;online execution&rdquo; refers to running Daikon at the same time
as the target program, without writing any information to a file.  This
can avoid some I/O overhead, prevent filling up your disk with
files, and in the future Daikon may be able to produce partial results
as the target program is executing.  A limitation of online execution is
that, unless FIFOs, or named pipes (see <a href="#Online-execution-with-DynComp-for-C_002fC_002b_002b">Online execution with DynComp for C/C++</a>)
are used, it runs Daikon over only a single execution, as opposed to
generalizing over multiple executions as can be done when writing to files
and supplying all the files to Daikon. 
The Chicory front end for Java also supports online execution, via its
<samp><span class="option">--daikon-online</span></samp> option (see <a href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a>).

   <p><a name="index-pipe_002c-as-data-trace-file-166"></a>
To use regular pipes in lieu of a disk file, simply use <samp><span class="file">-</span></samp> as the
name of the <samp><span class="file">.dtrace</span></samp> file, and run the target program and Daikon
in a Unix pipeline. 
When the <samp><span class="option">--dtrace-file=-</span></samp> option is used to redirect
the .dtrace output to stdout, the target program's stdout is redirected
to the terminal (<samp><span class="file">/dev/tty</span></samp>) so that it does not intermix with the
.dtrace output.

<pre class="example">     kvasir-dtrace --dtrace-file=- ./bzip2 --help | $DAIKON -
</pre>
   <p>Of course, you could also replace <samp><span class="option">--help</span></samp> with <samp><span class="option">-vv1
file.txt</span></samp> to compress a text file (but start with a small one first).

<p class="noindent">(This example assumes that you have compiled the bzip2 example (in
<samp><span class="file">$DAIKONDIR/examples/c-examples/bzip2</span></samp> of the distribution) by
saying <samp><span class="command">gcc -gdwarf-2 bzip2.c -o bzip2</span></samp>, and that
<samp><span class="command">$DAIKON</span></samp> stands for the command that invokes Daikon, for
instance <samp><span class="command">java -Xmx512m daikon.Daikon --config_option
daikon.derive.Derivation.disable_derived_variables=true</span></samp>.)

   <p><a name="index-named-pipe_002c-as-data-trace-file-167"></a><a name="index-FIFO_002c-as-data-trace-file-168"></a>
Instead of a regular pipe, you can use a named pipe, also known as a
FIFO, which is a special kind of file supported by most Unix-compatible
systems.  When one process tries to open a FIFO
for reading, it blocks, waiting for another process to open it for
writing (or vice-versa).  When both a reader and a writer are ready, the
FIFO connects the reader to the writer like a regular Unix pipe.

   <p>The <samp><span class="option">--output-fifo</span></samp> option causes Kvasir to create its output
<samp><span class="file">.dtrace</span></samp> file as a named pipe.  When Kvasir is
run with this option, Daikon needs to be run at the same time to read
from the FIFO, such as from another terminal or using the shell's
<code>&amp;</code> operator.

   <p>For instance, the following two commands have the same effect as the
pipeline above that used ordinary pipes.  The FIFO is named
<samp><span class="file">bzip2.dtrace</span></samp>.

<pre class="example">     kvasir-dtrace --output-fifo ./bzip2 --help &amp;
     $DAIKON bzip2.dtrace
</pre>
   <p>The two commands (before and after the ampersand) could also be run in
two different terminals.

<ul class="menu">
<li><a accesskey="1" href="#Online-execution-with-DynComp-for-C_002fC_002b_002b">Online execution with DynComp for C/C++</a>
</ul>

<div class="node">
<p><hr>
<a name="Online-execution-with-DynComp-for-C%2fC++"></a>
<a name="Online-execution-with-DynComp-for-C_002fC_002b_002b"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Online-execution">Online execution</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Online-execution">Online execution</a>

</div>

<h5 class="subsubsection">7.3.7.1 Online execution with DynComp for C/C++</h5>

<p>When running Kvasir with DynComp (using the <samp><span class="file">--with-dyncomp</span></samp>
option), Kvasir generates the .decls file after it generates the .dtrace
file, so it is not possible to perform online execution using one run. 
The recommended way to perform online execution with DynComp is to run
it once and only generate a .decls file with comparability information,
then run Kvasir again without DynComp and pipe the .dtrace data directly
into Daikon while using the .decls file generated from the previous run:

<pre class="smallexample">     kvasir-dtrace --with-dyncomp --decls-only ./foo
</pre>
   <p>This should generate a .decls file with comparability information
named <samp><span class="file">daikon-output/foo.decls</span></samp>.

<pre class="smallexample">     kvasir-dtrace --dtrace-no-decs --dtrace-file=- ./foo \
         | java daikon.Daikon daikon-output/foo.decls -
</pre>
   <p>When you run Kvasir the second time, you don't need to run DynComp
again since you are only interested in the .dtrace file.  Notice that
the .dtrace output
is directed to standard out (<samp><span class="file">--dtrace-file=-</span></samp>) and does not
contain any declarations (<samp><span class="option">--dtrace-no-decs</span></samp>) because the .decls
file already contains the declarations.  You can simply
pipe that .dtrace output out to Daikon, which is invoked using the
.decls file (with comparability information) generated during your
previous run.

<div class="node">
<p><hr>
<a name="Installing-Kvasir"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Kvasir-limitations">Kvasir limitations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Online-execution">Online execution</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Kvasir">Kvasir</a>

</div>

<h4 class="subsection">7.3.8 Installing Kvasir</h4>

<p><a name="index-installing-Kvasir-169"></a><a name="index-Kvasir-installation-170"></a>
<!-- Kvasir is the recommended C/C++ front end for use on Linux/x86. -->
The source
code for Kvasir is included in the main Daikon distribution, and is
compiled by default on Linux/x86 and Linux/x86-64 systems.

   <p>To compile and install Kvasir, give the command <samp><span class="command">make kvasir</span></samp>
from the top-level Daikon directory:

<pre class="example">     cd $DAIKONDIR
     make kvasir
</pre>
   <p>This will check that you have the appropriate prerequisites (such as
GCC), configure Kvasir for your machine, compile it, and install
it in the directory <samp><span class="file">kvasir/inst</span></samp>.

   <p>You may see warnings about the 'missing' script.  These can be ignored.

   <p>Once Kvasir has been installed, it can be used via the
<samp><span class="file">kvasir-dtrace</span></samp> script in the <samp><span class="file">$DAIKONDIR/bin</span></samp> directory; if
you have set up the Daikon environment according to the instructions
above, it should already be in your <samp><span class="env">PATH</span></samp>.  For instructions on using
Kvasir, see <a href="#Kvasir">Kvasir</a>.

<div class="node">
<p><hr>
<a name="Kvasir-limitations"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installing-Kvasir">Installing Kvasir</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Kvasir">Kvasir</a>

</div>

<h4 class="subsection">7.3.9 Kvasir implementation and limitations</h4>

<p>Kvasir is based on the Valgrind dynamic program supervision framework
(which is best known for its memory error detection tool).  Using
Valgrind allows Kvasir to interrupt your program's execution, read its
variables, and examine its memory usage, all transparently to the
program.  Also, rather than using your program's source code to find
the names and types of functions and variables, Kvasir obtains them
from debugging information included in the executable in a standard
format (DWARF-2).

   <p><a name="index-AMD64-architecture_002c-and-Kvasir-171"></a><a name="index-Intel-64-architecture_002c-and-Kvasir-172"></a><a name="index-IA_002d32e-architecture_002c-and-Kvasir-173"></a><a name="index-EM64T-architecture_002c-and-Kvasir-174"></a><a name="index-g_t64_002dbit-AMD64-architecture_002c-and-Kvasir-175"></a>
However, Kvasir has some limitations of its own.  Because Kvasir uses
Valgrind, it shares Valgrind's processor and operating system limitations. 
Furthermore, of the platforms supported by Valgrind, the only ones
currently supported by Kvasir are <code>x86-linux</code> and
<code>amd64-linux</code>. 
<code>x86-linux</code> refers to Intel 386-compatible processors
(the so-called IA-32 architecture) such as the Intel Pentium and the
AMD Athlon, running Linux. 
<code>amd64-linux</code> refers to the 64-bit extension of the x86
architecture found in many newer Intel and AMD processors, also
variously referred to as x86-64, IA-32e, EM64T, and Intel 64, when
running under a Linux kernel in 64-bit mode. 
The Itanium or IA-64 architecture is not supported. 
The Kvasir build process will automatically compile a 32-bit version, a
64-bit version, or both, whichever are supported by your system's
default compiler.

   <p>Kvasir requires that your program have debugging
information available in the DWARF-2 format, as produced by GCC version
3 and later.  For the best results, the programs used by Kvasir should be
compiled without optimization.

   <p>This subsection lists some of the known limitations of the
current Kvasir release; if you encounter any problems other than listed
here, please report them as bugs (see <a href="#Reporting-problems">Reporting problems</a>).  The
limitations are listed roughly in decreasing order of severity.

     <ul>
<li>Kvasir-traced programs take a while to start (often a good fraction of a
second).  When tracing short-lived programs, this overhead can
dominate Kvasir's per-instruction runtime overhead.  In order to make Kvasir
run faster, try the <samp><span class="option">--ignore-globals</span></samp>
option in order to limit the amount of generated output. 
However, please keep in mind that, when running simultaneously with
Daikon using the <samp><span class="option">--output-fifo</span></samp> option (see <a href="#Online-execution">Online execution</a>), Kvasir can generate
output data much faster than Daikon can process it.  Thus, it is not the
performance bottleneck in the entire invariant detection system.

     <li>Kvasir's support for outputting arrays is not yet complete. 
It still does not have the functionality to print out multidimensional
arrays with all of their elements or the option to flatten
multidimensional arrays into multiple single-dimensional arrays.

     <li>Kvasir behaves somewhat differently with different versions of GCC. 
We have had the best results with GCC versions 4.1 and 4.3 (which we use for
testing).  If feasible, we recommend that you use Kvasir with one of
these versions of GCC.  Incompatibilities
between Kvasir and the debugging information produced by older GCC
versions can lead to incorrect output and, in some cases for version
2.95, can cause Kvasir to crash.

     <li>Kvasir with Dyncomp will produce different results for x86 and
x86-64 hosts. This is due to a Dyncomp limitation with regards to
how handling the AMD64 ABI. The AMD64 ABI allows structs that are
less than 8-bytes to be passed to a function via register. 
Dyncomp categorizes this as an interaction between all
fields of the struct and will mark all fields of the struct as
comparable to each other.

     <li>Kvasir is incompatible with some compiler optimizations.  It is
definitely incompatible with the <samp><span class="option">-fomit-frame-pointer</span></samp>
optimization, and it may have trouble with other optimizations as
well.  We recommend that you compile programs for Kvasir without
optimization.

     <li>Kvasir always prints the contents of structures according to their
compile-time type.  Programs that use generic pointers and structural
equivalence to simulate object-orientation will have derived-class
fields missing when a structure is passed via a base-class pointer. 
This limitation can be worked around by manually coercing a pointer to a
particular type (see <a href="#Pointer-type-coercion">Pointer type coercion</a>).

   </ul>

<div class="node">
<p><hr>
<a name="Mangel-Wurzel"></a>
<a name="Mangel_002dWurzel"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#dfepl">dfepl</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Kvasir">Kvasir</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>

</div>

<h3 class="section">7.4 Source-based C/C++ front end Mangel-Wurzel</h3>

<p><a name="index-Mangel_002dWurzel-_0028deprecated-source_002dbased-front-end-for-C_0029-176"></a><a name="index-front-end-for-C_002fC_002b_002b-_0028deprecated_0029-177"></a><a name="index-C_002fC_002b_002b-front-end-_0028deprecated_0029-178"></a><a name="index-instrumentation_002c-of-C_002fC_002b_002b-programs-_0028deprecated_0029-179"></a>
In addition to the binary-based front end Kvasir (<a href="#Kvasir">Kvasir</a>), there
is also a source-based C/C++ front end, Mangel-Wurzel.  Unlike Kvasir, which
runs only on Linux/x86 platforms, Mangel-Wurzel will run on nearly any
Unix platform, as well as on Windows (with the Microsoft Visual C/C++
compiler).  If you have access to a Linux/x86 platform (32 or 64-bit),
we recommend use
of Kvasir.  Mangel-Wurzel is missing a few features of Kvasir; for
instance, Mangel-Wurzel outputs fewer variables and has no abstract type
inference analysis ().  Mangel-Wurzel requires
the source code for your program, and it also requires the Purify
program analysis tool from Rational Software.  You must install Purify
(either a paid or evaluation version) before you can use Mangel-Wurzel.

   <p>Mangel-Wurzel is based on the EDG C/C++ front end, which is also commercial
software.  For this reason, Mangel-Wurzel is distributed in precompiled
binary form only.  See <a href="#Installing-Mangel_002dWurzel">Installing Mangel-Wurzel</a>, for more information
about installation.  If you have an EDG source license and would like to build
or modify Mangel-Wurzel, we can provide source code on request.

   <p>Mangel-Wurzel is named after a root vegetable grown as cattle fodder. 
It &ldquo;mangles&rdquo; the source code into a form that is not fit for human
consumption before compiling it.

<ul class="menu">
<li><a accesskey="1" href="#Using-Mangel_002dWurzel">Using Mangel-Wurzel</a>
<li><a accesskey="2" href="#Mangel-options">Mangel options</a>
<li><a accesskey="3" href="#Pointer_002farray-disambiguation-in-Mangel_002dWurzel">Pointer/array disambiguation in Mangel-Wurzel</a>
<li><a accesskey="4" href="#Mangel_002dWurzel-usage-notes">Mangel-Wurzel usage notes</a>
<li><a accesskey="5" href="#Interaction-with-Purify">Interaction with Purify</a>
<li><a accesskey="6" href="#Installing-Mangel_002dWurzel">Installing Mangel-Wurzel</a>
</ul>

<div class="node">
<p><hr>
<a name="Using-Mangel-Wurzel"></a>
<a name="Using-Mangel_002dWurzel"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mangel-options">Mangel options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mangel_002dWurzel">Mangel-Wurzel</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel_002dWurzel">Mangel-Wurzel</a>

</div>

<h4 class="subsection">7.4.1 Using Mangel-Wurzel</h4>

<p><a name="index-mangel-driver-180"></a><a name="index-wurzel-preprocessor-181"></a>
Mangel-Wurzel consists of three parts: a driver program called
<samp><span class="command">mangel</span></samp>, the preprocessor <samp><span class="command">wurzel</span></samp> which
adds annotations to the source code,
and a small runtime library.  Mangel is a replacement for the
<samp><span class="command">cc</span></samp> command:  it produces an
instrumented executable that behaves like the original program, but that
also produces a <samp><span class="file">.dtrace</span></samp> data trace file for Daikon to analyze. 
Mangel operates by in turn invoking
the source preprocessor wurzel, the host compiler and linker, and the
object code instrumenter Purify.

   <p>To use Mangel-Wurzel in conjunction with Daikon, follow these steps
(after installing Mangel-Wurzel, see <a href="#Installing-Mangel_002dWurzel">Installing Mangel-Wurzel</a>):

     <ol type=1 start=1>

     <li>Compile and link the program, using <samp><span class="command">mangel</span></samp> in place of
<samp><span class="command">cc</span></samp>.  This produces both an
instrumented executable and also a <samp><span class="file">.decls</span></samp> file
for each compilation unit.

     <p>If you use a makefile to compile your program, simply substitute
<samp><span class="command">mangel</span></samp> for <samp><span class="command">cc</span></samp>.

     <p>Alternately, you may issue the compilation commands directly. 
For example, suppose you have a program that consists of three input files,
<samp><span class="file">foo.c</span></samp>, <samp><span class="file">bar.c</span></samp>, and <samp><span class="file">baz.c</span></samp>.  You can compile
and link in one step:

     <pre class="example">          mangel -o foo foo.c bar.c baz.c
</pre>
     <p class="noindent">Or, you can compile each file individually and then invoke mangel again to
link:

     <pre class="example">          mangel -c foo.c
          mangel -c bar.c
          mangel -c baz.c
          mangel -o foo foo.o bar.o baz.o
</pre>
     <p>As a side-effect, the wurzel preprocessor invoked by mangel
produces a <samp><span class="file">.decls</span></samp> file for each source file
it processes, in this case <samp><span class="file">foo.decls</span></samp>, <samp><span class="file">bar.decls</span></samp>, and
<samp><span class="file">baz.decls</span></samp>.

     <li>Run the instrumented program.

          <ul>
<li>On Unix, simply run the instrumented program (in this example, <samp><span class="file">foo</span></samp>)
created by mangel.

          <li>On Windows, Purify needs to be invoked when you run your program, not
at link time.  Mangel creates a <samp><span class="file">.cmd</span></samp> file that does this for you;
in this example, run <samp><span class="file">foo.cmd</span></samp> instead of <samp><span class="file">foo.exe</span></samp>. 
You can also run your program from within the Purify GUI
instead of from the command line, if you prefer. 
</ul>

     <p>This creates a single <samp><span class="file">.dtrace</span></samp> file
(in addition to anything else the program does). 
Assuming <samp><span class="file">foo.c</span></samp> contains the <code>main</code> routine, the
trace output for this example will be in <samp><span class="file">foo.dtrace</span></samp>. 
How to run the instrumented program depends on your operating system.

     <li>Invoke Daikon, passing all of the <samp><span class="file">.decls</span></samp> files and the <samp><span class="file">.dtrace</span></samp>
file as inputs.

     <pre class="example">          java daikon.Daikon foo.decls bar.decls baz.decls foo.dtrace
</pre>
     <li>Examine the invariants.  There are
several ways to do this; See <a href="#StackAr-example">StackAr example</a>.

        </ol>

<div class="node">
<p><hr>
<a name="Mangel-options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pointer_002farray-disambiguation-in-Mangel_002dWurzel">Pointer/array disambiguation in Mangel-Wurzel</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Mangel_002dWurzel">Using Mangel-Wurzel</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel_002dWurzel">Mangel-Wurzel</a>

</div>

<h4 class="subsection">7.4.2 Mangel options</h4>

<p>Mangel acts as a replacement for the host <samp><span class="command">cc</span></samp> command.  It
supports most of the common C compiler command-line options
(see <a href="#Standard-compiler-options-for-Mangel">Standard compiler options for Mangel</a>).  It also has options
that control how the wurzel preprocessor, compiler, and linker programs
are invoked (see <a href="#Mangel-configuration-options">Mangel configuration options</a>), and options that are
specific to controlling the program annotations added by wurzel
(see <a href="#Mangel-annotation-options">Mangel annotation options</a>).

   <p>Mangel is invoked as:

<pre class="example">     mangel <var>[options] inputfile1 ...</var>
</pre>
   <p>You can specify multiple <var>inputfile</var>s on the command line.  Mangel will
compile source files individually and then link them together (unless you have
specified one of the command-line options that suppresses linking).  You
can also include object and archive files on the command line, which are
passed directly to the linker.

<ul class="menu">
<li><a accesskey="1" href="#Standard-compiler-options-for-Mangel">Standard compiler options for Mangel</a>
<li><a accesskey="2" href="#Mangel-configuration-options">Mangel configuration options</a>
<li><a accesskey="3" href="#Mangel-annotation-options">Mangel annotation options</a>
<li><a accesskey="4" href="#Options-files-for-Mangel">Options files for Mangel</a>
</ul>

<div class="node">
<p><hr>
<a name="Standard-compiler-options-for-Mangel"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mangel-configuration-options">Mangel configuration options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mangel-options">Mangel options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel-options">Mangel options</a>

</div>

<h5 class="subsubsection">7.4.2.1 Standard compiler options for Mangel</h5>

<p>Mangel supports most of the common C compiler command-line options.

     <dl>
<dt><samp><span class="option">-o </span><var>filename</var></samp><dd>Specify <var>filename</var> as the output file.

     <br><dt><samp><span class="option">-c</span></samp><dd>Stop after compilation, producing a <samp><span class="file">.o</span></samp> file; do not link.

     <br><dt><samp><span class="option">-E</span></samp><dd>Stop after preprocessing with wurzel, producing a <samp><span class="file">.int.c</span></samp> file;
do not compile or link.  You might want to use this option for debugging
if you are having problems getting the instrumented code to compile with
the host C/C++ compiler.

     <br><dt><samp><span class="option">-D</span><var>symbol</var></samp><dt><samp><span class="option">-D</span><var>symbol</var><span class="option">=</span><var>value</var></samp><dd>Define preprocessor symbols.

     <br><dt><samp><span class="option">-U</span><var>symbol</var></samp><dd>Undefine preprocessor symbols.

     <br><dt><samp><span class="option">-I</span><var>pathname</var></samp><dd>Add <var>pathname</var> to the list of places searched for include files.

     <p><a name="index-MANGEL_005fDIR-environment-variable-182"></a>If the environment variable <samp><span class="env">MANGEL_DIR</span></samp> is set, mangel implicitly
adds its <samp><span class="file">include</span></samp> subdirectory to the list of directories searched
for system include
files.  Otherwise you must explicitly use <samp><span class="option">-I</span></samp> to specify where to
find Mangel-Wurzel's system include files, or include this information in
the options list passed directly to the wurzel preprocessor.  See the
<samp><span class="option">--preprocessor_opts</span></samp> option (see <a href="#Mangel-configuration-options">Mangel configuration options</a>).

     <p><a name="index-INCLUDE-environment-variable-183"></a><a name="index-CPATH-environment-variable-184"></a>On Windows, mangel implicitly adds &lsquo;<samp><span class="samp">-I</span></samp>&rsquo; options for all of the
pathnames specified in the environment variable <samp><span class="env">INCLUDE</span></samp>, which is
also used by the Microsoft C compiler to specify the location of its
default system libraries.  On Unix, it uses the path specified in the
environment variable <samp><span class="env">CPATH</span></samp> in addition to the default system libraries
specified in the configuration file, for compatibility with gcc.

     <br><dt><samp><span class="option">-O</span></samp><dt><samp><span class="option">-O</span><var>value</var></samp><dd>Enable optimization in the compiler.  This might interact badly with Purify, so
be careful.

     <br><dt><samp><span class="option">-g</span></samp><dd>Enable debugging in the compiler.  Since Purify expects code it processes
to be compiled with <samp><span class="option">-g</span></samp>, this is typically configured as one of the
default host compiler options (see <a href="#Installing-Mangel_002dWurzel">Installing Mangel-Wurzel</a>) and
need not be supplied explicitly on the command line.

     <br><dt><samp><span class="option">-L</span><var>pathname</var></samp><dd>Add <var>pathname</var> to the list of places searched for system libraries. 
This option is not supported on Windows, since the Microsoft linker uses
a different model for finding libraries.

     <br><dt><samp><span class="option">-l</span><var>name</var></samp><dd>Link with system library <var>name</var>.  This option is not supported on
Windows, since the Microsoft linker expects libraries to be specified like
ordinary input files to the linker.

     <p>If the environment variable <samp><span class="env">MANGEL_DIR</span></samp> is set, mangel implicitly
adds <samp><span class="file">$MANGEL_DIR/lib/libmangelwurzel.a</span></samp> to the list of libraries to
be linked with.  Otherwise you must explicitly link with this library,
include this information in the options list passed directly to the
linker.  See <samp><span class="option">--linker_opts</span></samp> (see <a href="#Mangel-configuration-options">Mangel configuration options</a>).

     <p><a name="index-PURIFY_005fDIR-environment-variable-185"></a>Also, on Unix, if the environment variable <samp><span class="env">PURIFY_DIR</span></samp> is set, mangel
implicitly adds <samp><span class="file">$PURIFY_DIR/purify_stubs.a</span></samp> to the list of libraries to
be linked with.  Similarly, if the environment variable is not set, you have
to specify this library explicitly.  This is not needed on Windows because
Purify uses a different model for resolving link references to its API on
that platform.

     <br><dt><samp><span class="option">--c</span></samp><dt><samp><span class="option">--c99</span></samp><dt><samp><span class="option">--c++</span></samp><dd>Interpret the input source file as old standard C (C89), C99, or C++,
respectively.  If none of these options are specified, mangel attempts
to infer the source language from the filename extension.

     <br><dt><samp><span class="option">--ansi</span></samp><dt><samp><span class="option">--gcc</span></samp><dt><samp><span class="option">--microsoft</span></samp><dd>Enable strict ANSI, gcc, and Microsoft compatibility modes (respectively)
in the wurzel preprocessor.  If none of these options are specified, wurzel
accepts ANSI C/C++ with a few common extensions and anachronisms.

     <br><dt><samp><span class="option">-h</span></samp><dt><samp><span class="option">--help</span></samp><dd>Print a usage message and exit. 
</dl>

<div class="node">
<p><hr>
<a name="Mangel-configuration-options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mangel-annotation-options">Mangel annotation options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Standard-compiler-options-for-Mangel">Standard compiler options for Mangel</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel-options">Mangel options</a>

</div>

<h5 class="subsubsection">7.4.2.2 Mangel configuration options</h5>

<p>You can use either command-line options or an options file
to override Mangel's default behavior
regarding how Mangel invokes wurzel, the host
compiler, and the linker. 
Options files are discussed in <a href="#Options-files-for-Mangel">Options files for Mangel</a>.

   <p>When you use command-line options from the shell or makefile to
specify these configuration parameters, be careful to quote the entire
option value string so that mangel interprets it as a single argument.

     <dl>
<dt><samp><span class="option">--preprocessor </span><var>command</var></samp><dd>Use <var>command</var> to invoke the wurzel preprocessor.  If this option is not
specified on the command line or in an options file,
it defaults to &lsquo;<samp><span class="samp">wurzel</span></samp>&rsquo;.

     <br><dt><samp><span class="option">--preprocessor_opts </span><var>option_string</var></samp><dd>Use <var>option_string</var> as additional options to the wurzel preprocessor.  If
this option is not specified on the command line or in an options file, it
defaults to a system-specific value.

     <br><dt><samp><span class="option">--compiler </span><var>command</var></samp><dd>Use <var>command</var> to invoke the host C/C++ compiler.  If this option is not
specified on the command line or in an options file,
it defaults to &lsquo;<samp><span class="samp">cc</span></samp>&rsquo;.

     <br><dt><samp><span class="option">--compiler_opts </span><var>option_string</var></samp><dd>Use <var>option_string</var> as additional options to the host compiler.  If
this option is not specified on the command line or in an options file,
it defaults to a system-specific value.

     <br><dt><samp><span class="option">--linker </span><var>command</var></samp><dd>Use <var>command</var> to invoke the host linker.  If this option is not
specified on the command line or in an options file,
it defaults to &lsquo;<samp><span class="samp">cc</span></samp>&rsquo;.

     <br><dt><samp><span class="option">--linker_opts </span><var>option_string</var></samp><dd>Use <var>option_string</var> as additional options to the host linker.  If
this option is not specified on the command line or in an options file,
it defaults to a system-specific value.

     <br><dt><samp><span class="option">--purify </span><var>command</var></samp><dd>Use <var>command</var> to invoke Rational Purify.  If this option is not
specified on the command line or in an options file,
it defaults to &lsquo;<samp><span class="samp">purify</span></samp>&rsquo;. 
See <a href="#Interaction-with-Purify">Interaction with Purify</a>, for more information about Purify options.

     <br><dt><samp><span class="option">--purify-opts </span><var>option-string</var></samp><dd>Use <var>option-string</var> as additional options to Rational Purify. 
If this option is not specified on the command line, it defaults to
a system-specific value. 
See <a href="#Interaction-with-Purify">Interaction with Purify</a>, for more information about Purify options.

     <br><dt><samp><span class="option">--tmpdir </span><var>pathname</var></samp><dd>Put temporary files (the annotated <samp><span class="file">.int.c</span></samp> files and temporary
object files created prior to linking) in the indicated directory. 
If this option is not specified on the command line or in an options file,
it defaults to a system-specific default, <samp><span class="file">/tmp/</span></samp> on Unix platforms or the
directory specified by the <samp><span class="env">TMP</span></samp> or <samp><span class="env">TEMP</span></samp> environment variables on
Windows.  The directory must exist and be writable.

     <br><dt><samp><span class="option">-v</span></samp><dt><samp><span class="option">--verbose</span></samp><dd>Print commands (to <code>stderr</code>) before executing them.

     <br><dt><samp><span class="option">-n</span></samp><dd>Print commands (to <code>stderr</code>), but don't execute them. 
</dl>

<div class="node">
<p><hr>
<a name="Mangel-annotation-options"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Options-files-for-Mangel">Options files for Mangel</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mangel-configuration-options">Mangel configuration options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel-options">Mangel options</a>

</div>

<h5 class="subsubsection">7.4.2.3 Mangel annotation options</h5>

<p>Mangel passes these options to the wurzel preprocessor, which adds
instrumentation to the code and produces a <samp><span class="file">.decls</span></samp> file for each
source file.

     <dl>
<dt><samp><span class="option">--decls-file </span><var>filename</var></samp><dd>Specify <var>filename</var> as the name of the <samp><span class="file">.decls</span></samp> file for this
compilation unit.  If this option is not specified, declarations are
written to a file in the current directory with a name derived from
the current compilation unit.

     <br><dt><samp><span class="option">--dtrace-file </span><var>filename</var></samp><dd>Specify <var>filename</var> as the name of the <samp><span class="file">.dtrace</span></samp> file for this
program.  This option is only used if the compilation unit contains a
definition for <code>main</code>.  If this option is not specified, trace
output is written to a file in the current directory when the executable
is run, with a name derived from the file containing the definition of
<code>main</code>.

     <p>If you specify a <var>filename</var> of &lsquo;<samp><span class="samp">-</span></samp>&rsquo;, trace output is written to
stdout.  In this case, regular program output to stdout is redirected to
the terminal (on Unix) or console (on Windows).  This allows you to
redirect trace output to a file or pipe on the command line, without
mingling the two output streams.

     <br><dt><samp><span class="option">--dtrace-append</span></samp><dd>Specify that output should be appended to an existing <samp><span class="file">.dtrace</span></samp> file,
rather than overwriting it. 
This option is only used if the compilation unit contains a
definition for <code>main</code>.

     <br><dt><samp><span class="option">--dtrace-gzip</span></samp><dd>Produce gzipped (compressed) trace output. 
This is implemented by filtering the trace output through <samp><span class="command">gzip</span></samp>. 
This option is only used if the compilation unit contains a
definition for <code>main</code>.

     <p>The runtime library invokes gzip as a subprocess, via a pipe.  If you
have gzip installed in a nonstandard location on your system, you can
specify its pathname using the <samp><span class="env">GZIP</span></samp> environment variable.

     <br><dt><samp><span class="option">--ignore-globals</span></samp><dd>Ignore global, file-scope static, and function-scope static
variables when emitting program point state. 
The default behavior is to emit declarations and trace information for
static variables and global variables
that are defined (not just declared as <code>extern</code>) in the compilation
unit and are in scope at the given program point,
as well as (for C++ class member functions) static member variables of
the containing class.

     <br><dt><samp><span class="option">--ignore-static-vars</span></samp><dd>Ignore file-scope and function-scope static variables when emitting
program point state, but include global variables defined in the compilation
unit.

     <br><dt><samp><span class="option">--nesting-depth </span><var>depth</var></samp><dd>Specify the recursion depth for examining fields of nested <code>struct</code>,
<code>union</code>, and <code>class</code> types.  The default value is 2.

     <br><dt><samp><span class="option">--flatten-arrays</span></samp><dd>This option forces the flattening of statically-sized arrays into
separate variables, one for each element.  For example, an array
<var>foo</var> of size 3 would be flattened into 3 variables: <var>foo[0]</var>,
<var>foo[1]</var>, <var>foo[2]</var>.  By default, Mangel-Wurzel flattens
arrays only after is has already exhausted the one level of sequences
that Daikon allows in the .dtrace output format.

     <br><dt><samp><span class="option">--max-flatten-array-size </span><var>size</var></samp><dd>Specify the maximum <var>size</var> of any dimension for arrays to be flattened. 
The default value is 10, so that (for instance) a 10x10x20 array would be
broken down into 100 variables each containing a 20-element sequence.  If
any one dimension to be flattened is larger than <var>size</var>, then Mangel-Wurzel
doesn't output the contents of the array.

     <br><dt><samp><span class="option">--max-array-size </span><var>size</var></samp><dd>Specify the maximum <var>size</var> of one-dimensional arrays, which are
output as sequences in the .dtrace file.  If the static array dimension is
larger than <var>size</var>, then Mangel-Wurzel doesn't output the contents of
the array.  The default is 100.

     <br><dt><samp><span class="option">--ignore-system-structs</span></samp><dd>If you specify this option, Mangel-Wurzel ignores fields of
<code>struct</code>, <code>union</code>, and <code>class</code> types declared in system
include files (e.g., those included via the
&lsquo;<samp><span class="samp">#include &lt;</span><var>file.h</var><span class="samp">&gt;</span></samp>&rsquo; syntax rather than
&lsquo;<samp><span class="samp">#include "</span><var>file.h</var><span class="samp">"</span></samp>&rsquo;.) 
These are typically interfaces like <code>FILE</code>
whose internal representations are not interesting to &ldquo;regular&rdquo;
programmers or portable across operating systems.

     <br><dt><samp><span class="option">--ppt-select-pattern </span><var>regex</var></samp><dd>Only emit program points that match <var>regex</var>. 
Specifically, a program point is considered to match <var>regex</var> if any of
the function name, program point name, or containing class name (for C++)
match <var>regex</var>.

     <p>This option can be specified multiple times, but cannot be used in
conjunction with <samp><span class="option">--ppt-omit-pattern</span></samp>.

     <br><dt><samp><span class="option">--ppt-omit-pattern </span><var>regex</var></samp><dd>Suppress program points that match <var>regex</var>. 
Specifically, a program point is considered to match <var>regex</var> if any of
the function name, program point name, or containing class name (for C++)
match <var>regex</var>.

     <p>This option can be specified multiple times, but cannot be used in
conjunction with <samp><span class="option">--ppt-select-pattern</span></samp>.

   </dl>

<div class="node">
<p><hr>
<a name="Options-files-for-Mangel"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mangel-annotation-options">Mangel annotation options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel-options">Mangel options</a>

</div>

<h5 class="subsubsection">7.4.2.4 Options files for Mangel</h5>

<p>In addition to specifying mangel options on the command line, you can
also put them in an options file.  This is most useful for customizing the
defaults for the configuration options (<a href="#Mangel-configuration-options">Mangel configuration options</a>) which control how wurzel and the host compiler and linker
should be invoked, but you can put any command-line options in the file.

   <p>Mangel looks for an options file in the following places, and will use
the first one it finds.

     <ol type=1 start=1>
<li><samp><span class="file">.mangelrc</span></samp>
<li><samp><span class="file">$HOME/.mangelrc</span></samp>
<li><samp><span class="file">$MANGEL_DIR/.mangelrc</span></samp>
        </ol>

   <p>Option files are formatted with one option, or option/value pair, per
line.  Everything following the option keyword on the same line is
considered to be a value.  Value strings should not be quoted (even if they
contain embedded spaces).  Blank lines are ignored.

   <p>Here is an example of an options file:

<pre class="example">     --preprocessor wurzel
     --preprocessor_opts --sys_include=/usr/include
     
     --compiler cc
     --compiler_opts -g -Dsetjmp=_setjmp -Dva_copy=__va_copy
     
     --linker cc
     --linker_opts -lstdc++
     
     --purify purify
     --purify_opts -log-file=/dev/null -append-logfile
</pre>
   <div class="node">
<p><hr>
<a name="Pointer%2farray-disambiguation-in-Mangel-Wurzel"></a>
<a name="Pointer_002farray-disambiguation-in-Mangel_002dWurzel"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mangel_002dWurzel-usage-notes">Mangel-Wurzel usage notes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mangel-options">Mangel options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel_002dWurzel">Mangel-Wurzel</a>

</div>

<h4 class="subsection">7.4.3 Pointer/array disambiguation in Mangel-Wurzel</h4>

<p>Wurzel currently does not support any form of pointer/array
disambiguation.  In other words, an object of type &lsquo;<samp><span class="samp">int *</span></samp>&rsquo; is
treated as a pointer to a single integer, not as the address of an array
of <code>int</code>.  This is in contrast to the default behavior of Kvasir
(<a href="#Kvasir">Kvasir</a>), which assumes the more general case that pointers point to
arrays rather than single objects.  The difference in behavior is due
to differences in the underlying runtime support; Purify does not track
the length of arrays or provide an API for querying this information.

   <p>Wurzel does, however, make use of static type information to emit trace
information for function arguments and global and static variables with
fully-defined array types as arrays.  Note that a &ldquo;fully-defined&rdquo; array type
includes a complete set of (constant) dimensions.

   <p>Wurzel also assumes that variables with type <code>char *</code>, or arrays of
<code>char</code>, are likely to be null-terminated strings rather than pointers to
a single <code>char</code> object.  The runtime code which prints strings
first performs a &ldquo;sanity check&rdquo; to make sure the string is of
reasonable length and contains only printable characters (as determined by
the C library functions <code>isprint</code> and <code>isspace</code>) rather than
arbitrary byte values.  If these conditions are not met, the string is
printed as its first character followed by &lsquo;<samp><span class="samp">...</span></samp>&rsquo; (such as &lsquo;<samp><span class="samp">"a..."</span></samp>&rsquo;),
or as &ldquo;nonsensical&rdquo; if the first character is not printable.

   <p>On the other hand, variables with type <code>signed char *</code> or
<code>unsigned char *</code>, or arrays of explicitly <code>signed</code> or
<code>unsigned char</code>, are treated as byte pointers or byte arrays,
respectively, and the elements print as normal integer values rather than
as strings.  Multidimensional <code>char</code> arrays also print as byte arrays
rather than as arrays of strings.

<div class="node">
<p><hr>
<a name="Mangel-Wurzel-usage-notes"></a>
<a name="Mangel_002dWurzel-usage-notes"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Interaction-with-Purify">Interaction with Purify</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pointer_002farray-disambiguation-in-Mangel_002dWurzel">Pointer/array disambiguation in Mangel-Wurzel</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel_002dWurzel">Mangel-Wurzel</a>

</div>

<h4 class="subsection">7.4.4 Mangel-Wurzel usage notes</h4>

<p>You do not need to instrument all compilation units in a program with
Mangel-Wurzel if you are only interested in analyzing certain parts of it with
Daikon; you can simply compile the &ldquo;uninteresting&rdquo; files in the normal
way with your usual C compiler.  However, you must either instrument the
compilation unit including the definition of <code>main</code> so that the
necessary runtime initialization is performed when the program starts, or
insert an explicit call to <code>mw_init</code> in your program before any of the
instrumented code is executed.  You should also use mangel to link
your program.

   <p>The wurzel preprocessor produces the same dialect of code that it receives as
input, that is C, C99, or C++.  It does not translate C++ to C.  This ensures
that preprocessed code is link-compatible with system C++ libraries and other
code that is not processed with wurzel.

   <p>While wurzel recognizes standard C++, its support of instrumentation for
C++ programs is rather rudimentary at this point.  In particular, it
ignores anything having to do with templates.  Wurzel is smart enough to
only generate references to class fields that are accessible at a given
program point, to avoid errors in the compilation phase, but at this
time it will not also generate references to accessible base classes and
their members.  (This should be optional in any case because it will
greatly increase the number of variables at a given program point.)

<!-- TODO: How does one do this? -->
<!-- TODO: Does this belong in the ``installation'' section instead? -->
   <p>If you are using the C++ libraries that came with your host C++
compiler, you will probably have to add the locations of the include
files to the search path passed to wurzel, as well adding the libraries
themselves to your link options.

   <p>If your source code uses extensions specific to a particular host compiler,
you may need to use the <samp><span class="option">--gcc</span></samp> or <samp><span class="option">--microsoft</span></samp> flags to enable
the appropriate compatibility mode. 
Wurzel recognizes many other command-line options supported by the
underlying EDG front end to customize the language dialects it accepts,
as described in the EDG documentation.  You can set these options using
the <samp><span class="option">--preprocessor-opts</span></samp> flag to mangel.

   <p>If your code compiles with your host compiler, but not with
Mangel-Wurzel, you can try these approaches:

     <ol type=1 start=1>

     <li>If you are getting compilation errors from wurzel that can't be resolved
with one of the above compatibility flags or with appropriate defines, a
possible workaround is to preprocess the code with the host compiler's
preprocessor before running it through Mangel-Wurzel.

     <li>If you are getting compilation errors from the host C compiler, you can
use the &lsquo;<samp><span class="samp">-E</span></samp>&rsquo; option to mangel to produce a <samp><span class="file">.int.c</span></samp> file
containing the code as preprocessed by wurzel, which you can examine to track
down the cause of the errors.

        </ol>

   <p>Note that since the output of wurzel is compilable source code, it is possible
to perform the preprocessing on one machine and then compile, link, and run
on another platform supported by Rational Purify.

<ul class="menu">
<li><a accesskey="1" href="#Using-Mangel_002dWurzel-on-Unix">Using Mangel-Wurzel on Unix</a>
<li><a accesskey="2" href="#Using-Mangel_002dWurzel-on-Windows">Using Mangel-Wurzel on Windows</a>
</ul>

<div class="node">
<p><hr>
<a name="Using-Mangel-Wurzel-on-Unix"></a>
<a name="Using-Mangel_002dWurzel-on-Unix"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-Mangel_002dWurzel-on-Windows">Using Mangel-Wurzel on Windows</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mangel_002dWurzel-usage-notes">Mangel-Wurzel usage notes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel_002dWurzel-usage-notes">Mangel-Wurzel usage notes</a>

</div>

<h5 class="subsubsection">7.4.4.1 Using Mangel-Wurzel on Unix</h5>

<p>GCC is the standard compiler on most Unix-based systems.  You may find
it necessary to specify the <samp><span class="option">--gcc</span></samp> option to wurzel to make it
correctly process system
include files, even if your code doesn't use GCC extensions itself.

   <p>Not all of the preprocessor symbols predefined by GCC's cpp are correctly
predefined by the EDG front end's GCC compatibility mode, so you may
need to specify some of these preprocessor symbols yourself.  If you run
into such preprocessing errors, consider creating a <samp><span class="file">mwdefines.h</span></samp> file
instead of trying to define every necessary macro on the command line
for wurzel:

     <ol type=1 start=1>
<li>Create a file with a list of all of cpp's
built-in defines: &lsquo;<samp><span class="samp">cpp -dM &gt; mwdefines.h</span></samp>&rsquo;

     <li>Edit the file, wrapping each of the &lsquo;<samp><span class="samp">#define</span></samp>&rsquo;s in an
&lsquo;<samp><span class="samp">#ifndef...#endif</span></samp>&rsquo; to prevent multiple definition.

     <li>In the <samp><span class="option">--preprocessor-opts</span></samp> value in your <samp><span class="file">.mangelrc</span></samp>, add
<samp><span class="option">--preinclude=</span><var>filename</var></samp>, where <var>filename</var> is the name of your
new <samp><span class="file">mwdefines.h</span></samp> file.
        </ol>

<div class="node">
<p><hr>
<a name="Using-Mangel-Wurzel-on-Windows"></a>
<a name="Using-Mangel_002dWurzel-on-Windows"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-Mangel_002dWurzel-on-Unix">Using Mangel-Wurzel on Unix</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel_002dWurzel-usage-notes">Mangel-Wurzel usage notes</a>

</div>

<h5 class="subsubsection">7.4.4.2 Using Mangel-Wurzel on Windows</h5>

<p>Rational Purify on Windows only supports the Microsoft Visual C/C++ compiler,
not GCC.  Therefore Mangel-Wurzel will only work with the Microsoft compiler
on this platform as well.  Currently, Mangel-Wurzel is not integrated with
the Visual Studio IDE, and runs as a command-line utility only.

   <p>You can run Mangel-Wurzel and programs instrumented with Mangel-Wurzel
from within a Cygwin shell, Makefile, and the like, as well as from the
default Windows &lsquo;<samp><span class="samp">cmd</span></samp>&rsquo; shell in a console window.  However, another
limitation of Rational Purify on Windows is that instrumented
executables will only run from a console window, not an XTerm or other
Cygwin pty.  (This is because Purify, like some other Windows console programs,
does not like having its standard input or output redirected to pipes.)

   <p>Since Mangel-Wurzel runs as a regular Windows console application, it
expects all pathname arguments and environment variables to be in
regular Windows pathname syntax even when you run it from inside a
Cygwin shell.

<div class="node">
<p><hr>
<a name="Interaction-with-Purify"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installing-Mangel_002dWurzel">Installing Mangel-Wurzel</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mangel_002dWurzel-usage-notes">Mangel-Wurzel usage notes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel_002dWurzel">Mangel-Wurzel</a>

</div>

<h4 class="subsection">7.4.5 Interaction with Purify</h4>

<p>If you are interested in obtaining Purify diagnostics for your code, you
should run Purify on the uninstrumented program.  The remainder of this
section explains why this is the case.  It is not necessary to fix all
the problems that Purify diagnoses before running Mangel-Wurzel. 
However, fixing them is likely to correct bugs and make your code more
robust, so it is recommended.

   <p>Mangel-Wurzel's runtime library relies on the Purify API to test the
validity of pointers &mdash; in particular, to check for pointers to
unallocated memory and pointers to memory that has been allocated but
not initialized.  It performs these checks so that it can avoid
dereferencing bad pointers and uninitialized variables when printing
values at program points to the <samp><span class="file">.dtrace</span></samp> file.  (Instead,
it prints a value of &ldquo;nonsensical&rdquo; for those variables, which has a
special meaning to Daikon (see <a href="developer.html#Nonsensical-values">Nonsensical values</a>).)

   <p>Both the Unix and Windows versions of Purify have problems identifying
uninitialized variables on the stack.  In Mangel-Wurzel, this manifests
itself by uninitialized block-scope automatic variables sometimes
printing as garbage values rather than as &ldquo;nonsensical&rdquo;, which in turn
might cause Daikon to find inaccurate invariants.

   <p>Normally, mangel is configured to tell Purify to discard all of its
diagnostic messages.  This is because, due to limitations of the Purify
API, it isn't possible for the Mangel-Wurzel runtime to run Purify
completely silently, and the diagnostics will contain bogus messages
generated by the Mangel-Wurzel runtime as well as genuine diagnostics
about the program that has been instrumented.

   <p>Specifically, since the Unix versions of Purify don't provide any API
functions
for checking the validity of pointers without generating messages, the
Mangel-Wurzel runtime works around this by enabling message batching and
by discarding the batched messages as processing of each program point
is completed.

<div class="node">
<p><hr>
<a name="Installing-Mangel-Wurzel"></a>
<a name="Installing-Mangel_002dWurzel"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Interaction-with-Purify">Interaction with Purify</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Mangel_002dWurzel">Mangel-Wurzel</a>

</div>

<h4 class="subsection">7.4.6 Installing Mangel-Wurzel</h4>

<p>Since Mangel-Wurzel is based on the proprietary EDG C/C++ front end, we
distribute it, at <a href="http://pag.csail.mit.edu/daikon/download/">http://pag.csail.mit.edu/daikon/download/</a>, in
binary rather than source format.  (If the web page does not currently
contain a binary for your architecture, send mail to
<a href="mailto:daikon-developers@lists.csail.mit.edu">daikon-developers@lists.csail.mit.edu</a> and we may be able to
produce one for you.)  The distribution does not include Purify, which
you must install separately (either purchase it or download an
evaluation copy).

   <p>Installation requires unpacking the distribution, setting the
<samp><span class="env">MANGEL_DIR</span></samp> and <samp><span class="env">PURIFY_DIR</span></samp> environment
variables, optionally customizing the defaults for how mangel operates,
and optionally running its tests.

     <ol type=1 start=1>
<li>Download the archive from
<a href="http://pag.csail.mit.edu/daikon/download/">http://pag.csail.mit.edu/daikon/download/</a> and unpack it in the
parent of the directory where you wish to install Mangel-Wurzel. 
Unpacking creates a directory named <samp><span class="file">mangel-wurzel</span></samp>.
          <ul>
<li>On the Linux/x86 platform, execute these two commands (other Unix
platforms are similar):

          <pre class="smallexample">               wget http://pag.csail.mit.edu/daikon/download/binaries/mangel-wurzel-linux-x86.tar.gz
               tar xvzf mangel-wurzel-linux-x86.tar.gz
</pre>
          <li>On Windows, download, then unzip,
<a href="http://pag.csail.mit.edu/daikon/download/binaries/mangel-wurzel-linux-x86.tar.gz">http://pag.csail.mit.edu/daikon/download/binaries/mangel-wurzel-linux-x86.tar.gz</a> .

     </ul>

     <li>Set these environment variables:

          <dl>
<dt><samp><span class="env">MANGEL_DIR</span></samp><dd><a name="index-MANGEL_005fDIR-environment-variable-186"></a>Set to the full pathname of the <samp><span class="file">mangel-wurzel</span></samp> directory. 
<br><dt><samp><span class="env">PATH</span></samp><dd>Add <samp><var>MANGEL_DIR</var><span class="file">/bin</span></samp> to your path. 
<br><dt><samp><span class="env">PURIFY_DIR</span></samp><dd><a name="index-PURIFY_005fDIR-environment-variable-187"></a>Set to the directory in your Purify distribution containing
<samp><span class="file">libpurify_stubs.a</span></samp>. 
</dl>

     <li>Customize the default commands and options mangel uses to
invoke the wurzel preprocessor, the host compiler and linker, and
Purify.  Make these changes in the system options file
<samp><span class="file">mangel-wurzel/.mangelrc</span></samp>; see <a href="#Options-files-for-Mangel">Options files for Mangel</a> for
details about the format of this file.

     <p>A suggested version of <samp><span class="file">.mangelrc</span></samp> for each supported platform is
included with the distribution.  For example, <samp><span class="file">.mangelrc.linux</span></samp> is
provided for Linux.  You should copy the appropriate file to <samp><span class="file">.mangelrc</span></samp>
and make any necessary changes there.  The most likely things you may need to
customize are:

          <ul>
<li>Make sure that the <samp><span class="option">--compiler</span></samp> and <samp><span class="option">--linker</span></samp> commands are
correct.  For example, if you want to use gcc, on some systems you may
need to specify &lsquo;<samp><span class="samp">gcc</span></samp>&rsquo; explicitly instead of &lsquo;<samp><span class="samp">cc</span></samp>&rsquo;, or use a
full pathname.  On Windows, you should use &lsquo;<samp><span class="samp">cl</span></samp>&rsquo; only.

          <li>You may need to alter the default system include paths, specified with
<samp><span class="option">--sys_include</span></samp> in the <samp><span class="option">--preprocessor_opts</span></samp> option.  See
<a href="#Using-Mangel_002dWurzel-on-Unix">Using Mangel-Wurzel on Unix</a>, and <a href="#Using-Mangel_002dWurzel-on-Windows">Using Mangel-Wurzel on Windows</a>,
for details.

               <ul>
<li>On Unix, you must specify the full set of search paths for include files in
your <samp><span class="file">.mangelrc</span></samp> file, since these are normally hard-wired into GCC
instead of configured with an environment variable. 
These include your gcc include directory (run &lsquo;<samp><span class="samp">gcc
-print-libgcc-file-name | sed s/libgcc.a/include/</span></samp>&rsquo;),
<samp><span class="file">/usr/local/include</span></samp>, and <samp><span class="file">/usr/include</span></samp> (after the gcc
include directory).

               <li>On Windows, Mangel-Wurzel uses the same <samp><span class="env">INCLUDE</span></samp> environment variable as the
Microsoft compiler to set up the system include paths, so in theory you
should not have to specify any additional paths in your <samp><span class="file">.mangelrc</span></samp>
configuration file. 
Do be sure that you specify &lsquo;<samp><span class="samp">cl</span></samp>&rsquo; (the Microsoft C compiler) for
both the <samp><span class="option">--compiler</span></samp> and <samp><span class="option">--linker</span></samp> options and that you have
your <samp><span class="env">PATH</span></samp> environment variable set up to include both the path to the
cl compiler and related Visual C utilities, and the path for Rational Purify.

               <p>Make sure you set up your <samp><span class="file">.mangelrc</span></samp> to compile with debugging
information enabled; otherwise Rational Purify does not detect
uninitialized memory references, which is a critical feature for
Mangel-Wurzel's data structure traversal.  On Windows, Purify also has
problems reliably detecting uninitialized stack locations which manifest
themselves in Mangel-Wurzel as uninitialized block-scope automatic
variables sometimes being reported as having garbage values instead of as
being &ldquo;nonsensical&rdquo;, which is treated specially by Daikon
(see <a href="developer.html#Nonsensical-values">Nonsensical values</a>).

               <p>You will probably need to specify the <samp><span class="option">--microsoft</span></samp> compatibility mode
option as the default in your <samp><span class="file">.mangelrc</span></samp> file.

          </ul>

          <li>You might also want to add some additional options, such as specifying
<samp><span class="option">--gcc</span></samp> or <samp><span class="option">--microsoft</span></samp> to enable the appropriate compatibility
mode for your normal C compiler by default. 
</ul>

     <p>For debugging the options file, you can use the <samp><span class="option">-n</span></samp> or
<samp><span class="option">-v</span></samp> options to see the actual commands mangel is generating to
invoke each phase.

     <li><!-- TODO Does this require Daikon to be installed? -->
Optionally (but recommended), run Mangel-Wurzel's tests.
     <pre class="example">          cd tests
          make
</pre>
        </ol>

<div class="node">
<p><hr>
<a name="dfepl"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#convertcsv_002epl">convertcsv.pl</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mangel_002dWurzel">Mangel-Wurzel</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>

</div>

<h3 class="section">7.5 Perl front end dfepl</h3>

<p><a name="index-front-end-for-Perl-188"></a><a name="index-Perl-front-end-189"></a><a name="index-dfepl-_0028front-end-for-Perl_0029-190"></a><a name="index-instrumentation_002c-of-Perl-programs-191"></a>
This section contains details about dfepl, the Daikon front end for
Perl.  For a brief introduction to dfepl, see <a href="#Perl-examples">Perl examples</a> and
<a href="#Instrumenting-Perl-programs">Instrumenting Perl programs</a>.

   <p>dfepl works with Perl versions 5.8 and later. (To be precise, Perl
programs instrumented with dfepl can also be run with Perl 5.6, but
the instrumentation engine, which is itself written in Perl, requires
version 5.8).  dfepl reads the source code for Perl modules or
programs, and writes out instrumented versions of that code that
keep track of function parameters, and make calls to routines in the
<samp><span class="file">daikon_runtime</span></samp> package whenever an instrumented subroutine is
entered or exited.

   <p>The instrumentation engine recognizes parameters as those variables
that are declared with <code>my(...)</code> or <code>local(...)</code> and, in the
same expression, assigned to from a value related to the argument
array <code>@_</code>, but only among the first contiguous series of such
assignments in the body of a subroutine.  This will capture the most
common assignment idioms, such as <code>my $self = shift;</code> (where
<code>shift</code> is short for <code>shift @_</code>), <code>my $x = $_[0];</code>, and
<code>my($x, $y, @a) = @_;</code>, but the arguments to subroutines which
access them only directly through <code>@_</code>, or that perform other
operations before reading their arguments, will not be recognized.

   <p>If the uninstrumented code requested warnings via the <code>use
warnings</code> pragma or by adding the <samp><span class="option">-w</span></samp> flag on the <code>#!</code>
line, the instrumented code will also request warnings.  In this case,
or if <samp><span class="option">-w</span></samp> is specified on the command line when running it, the
instrumented code may produce warnings that the original code did
not.  There are several situations in which the instrumented code
produced by dfepl, while functionally equivalent to the original,
generates more warnings.  The most common such problem, which arises
from code that captures the scalar-context return value of a
subroutine that returns a list, has been avoided in the current
version by disabling the warning in question.  Other warnings which
are known to be produced innocuously in this way include
&lsquo;<samp><span class="samp">Ambiguous call resolved as CORE::foo(), qualify as such or use
&amp;</span></samp>&rsquo; (caused by code that uses <code>CORE::</code> to distinguish a built-in
function from a user subroutine of the same name), and &lsquo;<samp><span class="samp">Constant
subroutine foo redefined</span></samp>&rsquo; (caused by loading both instrumented and
uninstrumented versions of a file).  Though some such warnings
represent deficiencies in the instrumentation engine, they can be
safely ignored when they occur.

   <p>Because Perl programs do not contain static type information to
distinguish, for instance, between strings and numbers, the Perl
front end incorporates an additional dynamic analysis to infer these
types.  This type guessing, which occurs as a first pass before the
program can be instrumented to produce output for Daikon, operates in
a manner somewhat analogous to Daikon itself: watching the execution
of a program, the runtime system chooses the most restrictive type for
a variable that is not contradicted during that execution.  These
types indicate, for instance, whether a scalar value always holds an
integer, a possibly fractional numeric value, or a reference to
another object.  It should not be necessary to examine or modify this
type information directly, but for the curious, the syntax of the type
information is described in comments in the <samp><span class="file">Daikon::PerlType</span></samp>
module.

   <p>The safest course is to infer types for variables using exactly the
same program executions (e.g., test cases) which will later be used to
generate traces for Daikon, as this guarantees that the type
information will match the actual data written to the trace file. 
However, because the type-guessing-instrumented versions of programs
run fairly slowly in the current version, you may be tempted to use a
subset of the input data for type guessing.  Doing so is possible, but
it will only work correctly if the smaller tests exercise all of the
instrumented subroutines and exit points with all the types of data
they will later be used with.  If the trace runtime tries to output a
data value that doesn't match the inferred type, the value may
silently be converted according to Perl's usual conventions (for
instance, a non-numeric string may be treated as the number zero), or
it may cause an error during tracing (for instance, trying to
dereference a supposed array reference that isn't).  Also, if a
subroutine exit point is traced but was never encountered during type
guessing, the generated <samp><span class="file">.decls</span></samp> and <samp><span class="file">.dtrace</span></samp> files will be
incompatible in a way that will cause Daikon to abort with an error
message of the form &lsquo;<samp><span class="samp">Program point foo():::EXIT22 appears in dtrace
file but not in any decl file</span></samp>&rsquo;.

   <div class="float">
<a name="dfepl_002dflow"></a><div align="center"><img src="images/dfepl-flow.jpg" alt="images/dfepl-flow.jpg"></div>
   <p><strong class="float-caption">Figure 7.1: Workflow of instrumenting Perl code with dfepl.</strong></p></div>

   <p>dfepl works by reading one or more Perl programs
or modules, and writing out new versions of those files, instrumented
to capture information about their execution, by default to another
directory.  dfepl is used in two passes: first, before type
information is available, instrumented versions are written to a
directory <samp><span class="file">daikon-untyped</span></samp>.  These untyped programs, when run,
will write
files containing dynamically inferred type information (with the
extension <samp><span class="file">.types</span></samp>), by default to the <samp><span class="file">daikon-instrumented</span></samp>
directory.  When dfepl is rerun with this type information, it
produces type-aware instrumented code in the
<samp><span class="file">daikon-instrumented</span></samp> directory, which when run produces
execution traces in files with the extension <samp><span class="file">.dtrace</span></samp> in the a
directory <samp><span class="file">daikon-output</span></samp>.

<ul class="menu">
<li><a accesskey="1" href="#dfepl-options">dfepl options</a>
</ul>

<div class="node">
<p><hr>
<a name="dfepl-options"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dfepl">dfepl</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dfepl">dfepl</a>

</div>

<h4 class="subsection">7.5.1 dfepl options</h4>

     <dl>
<dt><samp><span class="option">--absolute</span></samp><dt><samp><span class="option">--no-absolute</span></samp><dd><samp><span class="option">--absolute</span></samp> stores the absolute path to the output directories
(by default named <samp><span class="file">daikon-untyped</span></samp>, <samp><span class="file">daikon-instrumented</span></samp> or
<samp><span class="file">daikon-output</span></samp>) in the instrumented programs, so that no matter
where the instrumented program is run, the output will go to a fixed
location.  Even if these directories are given as relative paths (as is
the default), <samp><span class="option">--absolute</span></samp> specifies that they should always be
taken as relative to the directory that was the working directory when
dfepl was run.

     <p><samp><span class="option">--no-absolute</span></samp> specifies the opposite, causing the output paths
to be interpreted relative to the current working directory each time
the instrumented program is invoked.  The default, when neither option
is specified, is for <samp><span class="file">.types</span></samp> files to use an absolute path, but
all others to use relative path, so that the <samp><span class="file">.types</span></samp> files will
always be in the same place as the instrumented source files that
generated them, but the <samp><span class="file">daikon-output</span></samp> directory will be created
in the current directory when the program runs.

     <br><dt><samp><span class="option">--accessor-depth=</span><var>num</var></samp><dd>Controls the number of nested invocations of object accessor methods
to examine.  For instance, suppose that the <code>Person</code> class has a
method <code>mother()</code> that returns another person (and has been
specified to dfepl as an accessor), and that <code>$me</code> is
an instrumented variable.  If the accessor depth is 1, only
<code>$me-&gt;mother()</code> will be examined.  If the depth is 2,
<code>$me-&gt;mother()-&gt;mother()</code> will also be examined.  Specifying large
accessor depths is generally not advisable, especially with many
accessor methods, as the number of variables examined can be too many
for Daikon to process efficiently.

     <p>By default, the Daikon Perl trace runtime will examine at most a
single level of accessors.

     <br><dt><samp><span class="option">-A</span></samp><dt><samp><span class="option">--accessors-dir=</span><var>directory</var></samp><dd>Look for files containing accessor lists in <var>directory</var>, or the
current directory if <var>directory</var> is omitted.  For a class
<code>Acme::Foo</code>, accessors are methods that return information about
an object but do not modify it.  dfepl cannot determine on
its own which methods are accessors, but when a list of them is
provided, it can call an object's accessors when examining a variable
of that class to obtain more information about the object.  To tell
dfepl about the accessors for <code>Acme::Foo</code>, make a file
listing the names of each accessor method, one per line with no other
punctuation, named <samp><span class="file">Acme/Foo.accessors</span></samp> in the same directory as
<samp><span class="file">Acme/Foo.pm</span></samp>.

     <br><dt><samp><span class="option">--decls-dir=</span><var>directory</var></samp><dd>Put generated declaration files in <var>directory</var> and its
subdirectories.  The default is <samp><span class="file">daikon-output</span></samp>.

     <br><dt><samp><span class="option">--decls-style=</span><var>style</var></samp><dd><var>style</var> should be one of <samp><span class="option">combined</span></samp>, <samp><span class="option">flat</span></samp>, or
<samp><span class="option">tree</span></samp>.  A style of <samp><span class="option">combined</span></samp> specifies that the
declarations for all packages should be merged, in a file named
<samp><span class="file">prog-combined.decls</span></samp> where <samp><span class="file">prog</span></samp> is the name of the
program.  A style of <samp><span class="option">flat</span></samp> specifies that the declarations for
each package should be in a separate file named after the package, but
that these files should go in a single directory; for instance, the
declarations for <code>Acme::Trampoline</code> and
<code>Acme::Skates::Rocket</code> would go in files named
<samp><span class="file">Acme::Trampoline.decls</span></samp> and <samp><span class="file">Acme::Skates::Rocket.decls</span></samp>.  A
style of <samp><span class="option">tree</span></samp> specifies that each package should have its own
declarations file, and that those files should be arranged in
directories whose structure matches the structure of their package
names; in the example above, the files would be
<samp><span class="file">Acme/Trampoline.decls</span></samp> and <samp><span class="file">Acme/Skates/Rocket.decls</span></samp>.

     <p>The default is <samp><span class="option">tree</span></samp>.  Note that <samp><span class="option">--decls-style</span></samp> and
<samp><span class="option">--types-style</span></samp> are currently constrained to be the same; if
one is specified, the other will use the same value.

     <br><dt><samp><span class="option">--dtrace-append</span></samp><dt><samp><span class="option">--no-dtrace-append</span></samp><dd>When <samp><span class="option">--dtrace-append</span></samp> is specified, the instrumented program
will append trace information to the appropriate
<samp><span class="file">.dtrace</span></samp> file each time it runs.  When
<samp><span class="option">--no-dtrace-append</span></samp> is specified, it will overwrite the file
instead.

     <p>The default behavior is to overwrite.  This choice can also be
overridden, when the program is run, to always append by setting the
environment variable <samp><span class="env">DTRACEAPPEND</span></samp> to 1.

     <p>When appending to a <samp><span class="file">.dtrace</span></samp> file, no declaration information is
ever produced, because it would be redundant to do so and Daikon does
not permit re-declarations of program points.

     <br><dt><samp><span class="option">--dtrace-dir=</span><var>directory</var></samp><dd>Put generated trace files in <var>directory</var> and its
subdirectories.  The default is <samp><span class="file">daikon-output</span></samp>.

     <br><dt><samp><span class="option">--dtrace-style=</span><var>style</var></samp><dd><var>style</var> should be one of <samp><span class="option">combined</span></samp>, <samp><span class="option">flat</span></samp>, or
<samp><span class="option">tree</span></samp>.  A style of <samp><span class="option">combined</span></samp> specifies that the traces
for all packages should be merged, in a file named
<samp><span class="file">prog-combined.dtrace</span></samp>, where <samp><span class="file">prog</span></samp> is the name of the
program.  A style of <samp><span class="option">flat</span></samp> specifies that the
traces for each package should be in a separate file named after the
package, but that these files should go in a single directory; for
instance, the declarations for <code>Acme::Trampoline</code> and
<code>Acme::Skates::Rocket</code> would go in files named
<samp><span class="file">Acme::Trampoline.dtrace</span></samp> and
<samp><span class="file">Acme::Skates::Rocket.dtrace</span></samp>.  A style of <samp><span class="option">tree</span></samp> specifies
that each package should have its own trace file, and that
those files should be arranged in directories whose structure matches
the structure of their package names; in the example above, the files
would be <samp><span class="file">Acme/Trampoline.dtrace</span></samp> and
<samp><span class="file">Acme/Skates/Rocket.dtrace</span></samp>.

     <p>The default is <samp><span class="option">combined</span></samp>.

     <br><dt><samp><span class="option">--help</span></samp><dd>Print a short options summary.

     <br><dt><samp><span class="option">--instr-dir=</span><var>directory</var></samp><dd><!-- dfec option - do not rename (yet) -->
<dt><samp><span class="option">--instrsourcedir=</span><var>directory</var></samp><dd>Put instrumented source files in <var>directory</var> and its
subdirectories.  The default is <samp><span class="file">daikon-untyped</span></samp>, or
<samp><span class="file">daikon-instrumented</span></samp> if type information is available.

     <br><dt><samp><span class="option">--list-depth=</span><var>DEPTH</var></samp><dd>Consider as many as <var>DEPTH</var> of the first elements of a list to be
distinct entities, for the purpose of guessing their types.  When
subroutines return a list of values, each value may have a distinct
meaning, or the list may be homogeneous.  When trying to assign types
to the elements of a list, the Daikon Perl trace runtime will try
making separate guesses about the types of the elements of a short
list, but it would be inefficient to make retain this distinction for
many elements.  This parameter controls how many elements of a list
will be examined individually; all the others will be treated
uniformly.

     <p>The default is 3.

     <br><dt><samp><span class="option">--output-dir=</span><var>directory</var></samp><dd>Put all of the files that are the output of the tracing process (and
therefore input to the Daikon invariant detection engine) in
<var>directory</var> and its subdirectories.  This option is a shorthand
equivalent to setting both <samp><span class="option">--decls-dir</span></samp> and
<samp><span class="option">--dtrace-dir</span></samp> to the same value.

     <p>The default behavior is as if <samp><span class="option">--output-dir=daikon-output</span></samp> had
been specified.

     <br><dt><samp><span class="option">--perl=</span><var>path</var></samp><dd>Use <var>path</var> as the location of Perl when calling the annotation
back end (a module named <code>B::DeparseDaikon</code>), rather than the
version of Perl under which <samp><span class="command">dfepl</span></samp> itself is running, which
is probably the first <samp><span class="command">perl</span></samp> that occurs on your path.  For
instance, if the first version of <samp><span class="command">perl</span></samp> on your path isn't
version 5.8 or later, you should this option to specify another
<samp><span class="command">perl</span></samp> program that is.

     <br><dt><samp><span class="option">--nesting-depth=</span><var>num</var></samp><dd>When examining nested data structures, traverse as many as <var>num</var>
nested references.  For instance, suppose that <code>@a</code> is the array

     <pre class="example">          @a = ({1 =&gt; [2, 3]}, {5 =&gt; [4, 2]})
</pre>
     <p>If the depth is 0, then when examining <code>@a</code>, Daikon's Perl trace
runtime will consider it to be an array whose elements are references,
but it won't examine what those references point to.  If the depth is
1, it will consider it to be an array of references to hashes whose
keys are integers and whose values are references, but it won't
examine what <em>those</em> references point to.  Finally, if the depth
is 2 or more, it will consider <code>@a</code> to be an array of references
to hashes whose keys are integers and whose values are references to
arrays of integers.

     <p>The default nesting depth is 3.

     <p>When referenced objects have accessor methods, or when accessors
return references, the <samp><span class="option">--accessor-depth</span></samp> and
<samp><span class="option">--nesting-depth</span></samp> options interact.  Specifically, if these
depths are A and R, the behavior is as if the runtime has a budget of
1 unit, which it can use either on accessors which cost 1/A or
references which cost 1/R.  It may thus sometimes be useful to specify
fractional values for <samp><span class="option">--accessor-depth</span></samp> and
<samp><span class="option">--nesting-depth</span></samp>; in fact, the default accessor depth is
1.5.

     <br><dt><samp><span class="option">--types-append</span></samp><dt><samp><span class="option">--no-types-append</span></samp><dd>When <samp><span class="option">--types-append</span></samp> is specified, the instrumented program
will append type information to the appropriate
<samp><span class="file">.types</span></samp> file each time it runs.  When
<samp><span class="option">--no-types-append</span></samp> is specified, it will overwrite the file
instead.

     <p>The default behavior is to append.  If <samp><span class="option">--no-types-append</span></samp> is
specified, however, this choice can also be overridden, when the
program is run, to append by setting the environment variable
<samp><span class="env">TYPESAPPEND</span></samp> to 1.  There is no way to use environment variables
to force the runtime to overwrite a types file, but an equivalent
effect can be obtained by simply removing the previous types file
before each run.

     <br><dt><samp><span class="option">-T</span></samp><dt><samp><span class="option">--types-dir=</span><var>directory</var></samp><dd>Look for <samp><span class="file">.types</span></samp> files in <var>directory</var>, or
<samp><span class="file">daikon-instrumented</span></samp> if <var>directory</var> is omitted.  When
instrumenting a module <code>Acme::Trampoline</code>, used in a program
<samp><span class="file">coyote.pl</span></samp>,  dfepl will look for
files named <samp><span class="file">coyote-combined.types</span></samp>, <samp><span class="file">Acme::Trampoline.types</span></samp>, and
<samp><span class="file">Acme/Trampoline.types</span></samp>, corresponding to the possible choices of
<samp><span class="option">--types-style</span></samp>.  Once discovered, the files are used in the
same way as for <samp><span class="option">-t</span></samp>.

     <br><dt><samp><span class="option">--types-file=</span><var>file</var></samp><dt><samp><span class="option">-t </span><var>file</var></samp><dd>Include type information from <var>file</var> when instrumenting programs
or modules.  Since Daikon needs to know the types of variables when
they are declared, useful <samp><span class="file">.decls</span></samp> and <samp><span class="file">.dtrace</span></samp> files can
only be produced by source code instrumented with type
information.  Since Perl programs don't include this information to
begin with, and it would be cumbersome to produce by hand, type
information must usually be produced by running a version of the
program that has itself been annotated, but without type
information.  The Daikon Perl trace runtime will automatically decide
whether to output types, or declarations and traces, depending on
whether the source was instrumented without or with types.  This option
may occur multiple times, to read information from multiple types
files (irrelevant type information will be ignored).

     <br><dt><samp><span class="option">--types-basedir=</span><var>directory</var></samp><dd>Put files containing type information in <var>directory</var> and its
subdirectories.  By default, this is whatever <samp><span class="option">--instr-dir</span></samp>
is, usually <samp><span class="file">daikon-instrumented</span></samp>.

     <br><dt><samp><span class="option">--types-style=</span><var>style</var></samp><dd><var>style</var> should be one of <samp><span class="option">combined</span></samp>, <samp><span class="option">flat</span></samp>, or
<samp><span class="option">tree</span></samp>.  A style of <samp><span class="option">combined</span></samp> specifies that the types
for all packages should be merged, in a file named
<samp><span class="file">prog-combined.types</span></samp>, where <samp><span class="file">prog</span></samp> is the name of the
program.  A style of <samp><span class="option">flat</span></samp> specifies that the
types for each package should be in a separate file named after the
package, but that these files should go in a single directory; for
instance, the declarations for <code>Acme::Trampoline</code> and
<code>Acme::Skates::Rocket</code> would go in files named
<samp><span class="file">Acme::Trampoline.types</span></samp> and
<samp><span class="file">Acme::Skates::Rocket.types</span></samp>.  A style of <samp><span class="option">tree</span></samp> specifies
that each package should have its own trace file, and that
those files should be arranged in directories whose structure matches
the structure of their package names; in the example above, the files
would be <samp><span class="file">Acme/Trampoline.types</span></samp> and
<samp><span class="file">Acme/Skates/Rocket.types</span></samp>.

     <p>The default is <samp><span class="option">tree</span></samp>.  Note that <samp><span class="option">--types-style</span></samp> and
<samp><span class="option">--decls-style</span></samp> are currently constrained to be the same; if
one is specified, the other will use the same value.

     <br><dt><samp><span class="option">--verbose</span></samp><dt><samp><span class="option">-v</span></samp><dd>Print additional information about what dfepl is doing,
including external commands invoked. 
</dl>

<div class="node">
<p><hr>
<a name="convertcsv.pl"></a>
<a name="convertcsv_002epl"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Other-front-ends">Other front ends</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dfepl">dfepl</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>

</div>

<h3 class="section">7.6 Comma-separated-value front end convertcsv.pl</h3>

<p><a name="index-csv-files-192"></a><a name="index-comma_002ddelimited-files-193"></a><a name="index-comma_002dseparated_002dvalue-files-194"></a><a name="index-tab_002dseparated-files-195"></a><a name="index-Excel-files-196"></a><a name="index-spreadsheet-files-197"></a>
Daikon can process data from spreadsheets such as Excel.  In order to
use such files, first save them in <a href="http://en.wikipedia.org/wiki/Comma-separated_values">comma-separated-value</a>, also known
as csv or comma-delimited or comma-separated-list, format. 
Then, convert the <samp><span class="file">.csv</span></samp> file into a <samp><span class="file">.dtrace</span></samp> file (and a
<samp><span class="file">.decls</span></samp> file) to be used by Daikon by running the
<samp><span class="command">convertcsv.pl</span></samp> program found in the <samp><span class="file">$DAIKONDIR/bin</span></samp>
directory.  For example,
<pre class="example">     convertcsv.pl myfile.csv
</pre>
   <p class="noindent">produces files <samp><span class="file">myfile.decls</span></samp> and <samp><span class="file">myfile.dtrace</span></samp>.

   <p>Important:  run <samp><span class="command">convertcsv.pl</span></samp> without any arguments in order
to see a usage message.

   <p>In order to ensure all data is processed, use Daikon with the
<samp><span class="option">--nohierarchy</span></samp> option, as follows:
<pre class="example">     java daikon.Daikon --nohierarchy myfile.decls myfile.dtrace
</pre>
   <p class="noindent">In a future release, the <samp><span class="option">--nohierarchy</span></samp> option may not be necessary,
but it should always be safe to use this option.

   <p>Before running <samp><span class="command">convertcsv.pl</span></samp>, you may need to install
Text::CSV, a Perl package that <samp><span class="command">convertcsv.pl</span></samp> uses.

<div class="node">
<p><hr>
<a name="Other-front-ends"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#convertcsv_002epl">convertcsv.pl</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>

</div>

<h3 class="section">7.7 Other front ends</h3>

<p>It is relatively easy to create a Daikon front end for another language
or run-time system.  For example, people have done this without any help
at all from the Daikon developers.  For more information about building
a new front end, see <a href="developer.html#New-front-ends">New front ends</a>.

   <p><a name="index-front-end-for-Eiffel-198"></a><a name="index-Eiffel-front-end-199"></a><a name="index-instrumentation_002c-of-Eiffel-programs-200"></a>
A front end for the Eiffel programming language is distributed
separately; see <a href="http://se.inf.ethz.ch/people/polikarpova/citadel.html">http://se.inf.ethz.ch/people/polikarpova/citadel.html</a>.

   <p><a name="index-front-end-for-IOA-201"></a><a name="index-IOA-front-end-202"></a><a name="index-instrumentation_002c-of-IOA-programs-203"></a>
A front end for the IOA programming language is distributed separately;
see <a href="http://groups.csail.mit.edu/tds/ioa.html">http://groups.csail.mit.edu/tds/ioa.html</a>.

   <p><a name="index-front-end-for-Lisp-204"></a><a name="index-Lisp-front-end-205"></a><a name="index-instrumentation_002c-of-Lisp-programs-206"></a>
An earlier version of Daikon included a Lisp front end, but it is no
longer supported.

   <p>An earlier version of Daikon provided a source-based front end for Java
named dfej.  It has been superseded by Chicory (see <a href="#Chicory">Chicory</a>).

   <p>An earlier version of Daikon provided a source-based front end for C
named dfec.  It has been superseded by Kvasir  (binary-based, for
Linux/x86; see <a href="#Kvasir">Kvasir</a>) and
Mangel-Wurzel (source-based, for all other platforms; see <a href="#Mangel_002dWurzel">Mangel-Wurzel</a>).

<div class="node">
<p><hr>
<a name="Tools"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Troubleshooting">Troubleshooting</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Tools for use with Daikon</h2>

<p>This chapter describes various tools that are included with the Daikon
distribution.

<ul class="menu">
<li><a accesskey="1" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>
<li><a accesskey="2" href="#DtraceDiff-utility">DtraceDiff utility</a>
</ul>

<div class="node">
<p><hr>
<a name="Tools-for-manipulating-invariants"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#DtraceDiff-utility">DtraceDiff utility</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tools">Tools</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tools">Tools</a>

</div>

<h3 class="section">8.1 Tools for manipulating invariants</h3>

<p><a name="index-g_t_002einv-files_002c-tools-for-manipulating-207"></a><a name="index-inv-files_002c-tools-for-manipulating-208"></a>
This section gives information about tools that manipulate invariants
(in the form of <samp><span class="file">.inv</span></samp> files).

<ul class="menu">
<li><a accesskey="1" href="#Printing-invariants">Printing invariants</a>
<li><a accesskey="2" href="#MergeInvariants">MergeInvariants</a>
<li><a accesskey="3" href="#Invariant-Diff">Invariant Diff</a>
<li><a accesskey="4" href="#Annotate">Annotate</a>
<li><a accesskey="5" href="#AnnotateNullable">AnnotateNullable</a>
<li><a accesskey="6" href="#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a>
<li><a accesskey="7" href="#InvariantChecker">InvariantChecker</a>
<li><a accesskey="8" href="#LogicalCompare">LogicalCompare</a>
</ul>

<div class="node">
<p><hr>
<a name="Printing-invariants"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#MergeInvariants">MergeInvariants</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>

</div>

<h4 class="subsection">8.1.1 Printing invariants</h4>

<p><a name="index-printing-invariants-209"></a><a name="index-PrintInvariants-program-210"></a>
Daikon provides many options for controlling how invariants are printed. 
Often, you may want to print the same set of invariants several
different ways.  However, you only want to run Daikon once, since it may
be very time consuming.  The PrintInvariants utility prints a set of
invariants from a <samp><span class="file">.inv</span></samp> file.

   <p>PrintInvariants is invoked as follows:
<pre class="example">     java daikon.PrintInvariants <i>[</i><var>flags</var><i>]</i> <var>inv-file</var>
</pre>
   <p>PrintInvariants shares many flags with Daikon. 
These flags are only briefly summarized here. 
For more information about these flags, see <a href="#Daikon-configuration-options">Daikon configuration options</a>.

     <dl>
<dt><samp><span class="option">--help</span></samp><dd>Print usage message.

     <br><dt><samp><span class="option">--format </span><var>name</var></samp><dd>Produce output in the given format.  See <a href="#Invariant-syntax">Invariant syntax</a>.

     <br><dt><samp><span class="option">--output_num_samples</span></samp><dd>Output numbers of values and samples for invariants and program points;
for debugging.

     <br><dt><samp><span class="option">--ppt-select-pattern</span></samp><dd>Only outputs program points that match the specified regular expression

     <br><dt><samp><span class="option">--config </span><var>filename</var></samp><dd>Load the configuration settings specified in the given file. 
See <a href="#Configuration-options">Configuration options</a>, for details.

     <br><dt><samp><span class="option">--config_option </span><var>name</var><span class="option">=</span><var>value</var></samp><dd>Specify a single configuration setting. 
See <a href="#Configuration-options">Configuration options</a>, for details.

     <br><dt><samp><span class="option">--dbg </span><var>category</var></samp><dt><samp><span class="option">--debug</span></samp><dd>Enable debug loggers.

     <br><dt><samp><span class="option">--track </span><var>class</var><span class="option">&lt;</span><var>var1</var><span class="option">,</span><var>var2</var><span class="option">,</span><var>var3</var><span class="option">&gt;@</span><var>ppt</var></samp><dd>Track information on specified invariant class, variables and program point. 
For more information, also see <a href="developer.html#Track-logging">Track logging</a>.

   </dl>

<div class="node">
<p><hr>
<a name="MergeInvariants"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Invariant-Diff">Invariant Diff</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Printing-invariants">Printing invariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>

</div>

<h4 class="subsection">8.1.2 MergeInvariants</h4>

<p><a name="index-invariant-merge-211"></a><a name="index-merge-invariants-212"></a>
The MergeInvariants utility merges multiple serialized invariant files
to create a single serialized invariant file that contains the
invariants that are true across each of the input files.  The results
of merging N serialized invariant files should be the same as running
Daikon on the N original dtrace files.

   <p>MergeInvariants is invoked as follows:
<pre class="example">     java daikon.MergeInvariants <i>[</i><var>flags</var><i>]...</i> <var>file1</var> <var>file2</var>...
</pre>
   <p><var>file1</var> and <var>file2</var> are files containing serialized invariants
produced by running Daikon.  At least two invariant files must be specified.

   <p>MergeInvariants shares many flags with Daikon. 
These flags are only briefly summarized here. 
For more information about these flags, see <a href="#Daikon-configuration-options">Daikon configuration options</a>.

     <dl>
<dt><samp><span class="option">-h --help</span></samp><dd>Print usage message.

     <br><dt><samp><span class="option">-o </span><var>inv_file</var></samp><dd>Output serialized invariants to the specified file; they can later be
postprocessed, compared, etc.  If not specified, the results are written
to standard out.

     <br><dt><samp><span class="option">--config_option </span><var>name</var><span class="option">=</span><var>value</var></samp><dd>Specify a single configuration setting. 
See <a href="#Configuration-options">Configuration options</a>, for details.

     <br><dt><samp><span class="option">--dbg </span><var>category</var></samp><dd>Enable debug loggers.

     <br><dt><samp><span class="option">--track </span><var>class</var><span class="option">&lt;</span><var>var1</var><span class="option">,</span><var>var2</var><span class="option">,</span><var>var3</var><span class="option">&gt;@</span><var>ppt</var></samp><dd>Track information on specified invariant class, variables and program point. 
For more information, also see <a href="developer.html#Track-logging">Track logging</a>. 
</dl>

<div class="node">
<p><hr>
<a name="Invariant-Diff"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Annotate">Annotate</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#MergeInvariants">MergeInvariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>

</div>

<h4 class="subsection">8.1.3 Invariant Diff</h4>

<p><a name="index-invariant-diff-213"></a><a name="index-diff_002c-over-invariants-214"></a><a name="index-comparing-invariants-215"></a>
The invariant diff utility is designed to output the differences between
two sets of invariants.  This is useful, for example, if you want to
compare the invariants generated by two versions of the same program.

   <p>Invariant diff is invoked as follows:
<pre class="example">     java daikon.diff.Diff <i>[</i><var>flags</var><i>]...</i> <var>file1</var> [<var>file2</var>]
</pre>
   <p><var>file1</var> and <var>file2</var> are files containing serialized invariants
produced by running Daikon or Diff
with the <samp><span class="option">-o</span></samp> flag.  If <var>file2</var> is not specified,
<var>file1</var> is compared with the empty set of invariants.

   <p>This section describes the optional flags.

     <dl>
<dt><samp><span class="option">--help</span></samp><dd>Print usage message.

     <br><dt><samp><span class="option">-d</span></samp><dd>Display the tree of differing invariants (default).  Invariants that are
the same in <var>file1</var> and <var>file2</var> are not printed.  At least one of the
invariants must be justified.  Does not print &ldquo;uninteresting&rdquo; invariants
(currently some OneOf and Bound invariants).

     <br><dt><samp><span class="option">-u</span></samp><dd>Include &ldquo;uninteresting&rdquo; invariants in the tree of differing invariants.

     <br><dt><samp><span class="option">-y</span></samp><dt><samp><span class="option">--ignore_unjustified</span></samp><dd>Include (statistically) unjustified invariants.

     <br><dt><samp><span class="option">-a</span></samp><dd>Display the tree of all invariants.  Includes invariants that are the
same in file1 and file2, and unjustified invariants.

     <br><dt><samp><span class="option">-s</span></samp><dd>For internal use only.  Display the statistics between two sets of
invariants.  The pairs of invariants are placed in bins according to the
type of the invariant and the type of the difference.

     <br><dt><samp><span class="option">-t</span></samp><dd>For internal use only.  Display the same statistics as <samp><span class="option">-s</span></samp>, but as a
tab-separated list.

     <br><dt><samp><span class="option">-m</span></samp><dd>Compute (<var>file1</var> - <var>file2</var>).  This is all the invariants that appear in
<var>file1</var> but not <var>file2</var>.  Unjustified invariants are treated as if they
don't exist.  Output is written as a serialized InvMap to the file
specified with the <samp><span class="option">-o</span></samp> option.  To view the contents of the serialized
InvMap, run <samp><span class="command">java daikon.diff.Diff </span><var>file</var></samp>.

     <br><dt><samp><span class="option">-x</span></samp><dd>Compute (<var>file1</var> XOR <var>file2</var>). 
This is all the invariants that appear in
one file but not the other.  Unjustified invariants are treated as if
they don't exist.  Output is written as a serialized InvMap to the file
specified with the <samp><span class="option">-o</span></samp> option.  To view the contents of the serialized
InvMap, run <samp><span class="command">java daikon.diff.Diff </span><var>file</var></samp>.

     <br><dt><samp><span class="option">-n</span></samp><dd>Compute (<var>file1</var> UNION <var>file2</var>). 
This is all the invariants that appear in
either file.  If the same invariant appears in both files, the one with
the better justification is chosen.  Output is written as a serialized
InvMap to the file specified with the <samp><span class="option">-o</span></samp> option.  To view the contents
of the serialized InvMap, run <samp><span class="command">java daikon.diff.Diff </span><var>file</var></samp>.

     <br><dt><samp><span class="option">-o </span><var>inv_file</var></samp><dd>Used in combination with the <samp><span class="option">-m</span></samp> or <samp><span class="option">-x</span></samp> option.  Writes
the output as a serialized InvMap to the specified file.

     <br><dt><samp><span class="option">-j</span></samp><dd>For internal use only.  Treat justification as a continuous value when
gathering statistics.  By default, justification is treated as
a binary value &mdash; an invariant is either justified or it is not.  For
example, assume invariant I1 has a probability of .01, and I2 has a
probability of .5.  By default, this will be a difference of 1,
since I1 is justified but I2 is not.  With this option, this will be a
difference of .49, the difference in the probabilities.  This only
applies when one invariant is justified, and the other is unjustified.

     <br><dt><samp><span class="option">-p</span></samp><dd>Examine all program points.  By default, only procedure entries and
combined procedure exits are examined.  This option also causes
conditional program points to be examined.

     <br><dt><samp><span class="option">-e</span></samp><dd>Print empty program points.  By default, program points are not printed
if they contain no differences.

     <br><dt><samp><span class="option">-v</span></samp><dd>Verbose output.  Invariants are printed using the <code>repr()</code> method, instead
of the <code>format()</code> method.

     <br><dt><samp><span class="option">-l</span></samp><dd>For debugging use only.  Prints logging information describing the state
of the program as it runs.

     <br><dt><samp><span class="option">--invSortComparator1 </span><var>classname</var></samp><dt><samp><span class="option">--invSortComparator2 </span><var>classname</var></samp><dt><samp><span class="option">--invPairComparator </span><var>classname</var></samp><dd>Use the specified class as a custom comparator.  A custom comparator can
be used for any of 3 operations: sorting the first set of invariants,
sorting the second set of invariants, and combining the two sets into
the pair tree.  The specified class must implement the Comparator
interface, and accept objects of type Invariant.

   </dl>

<div class="node">
<p><hr>
<a name="Annotate"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#AnnotateNullable">AnnotateNullable</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Invariant-Diff">Invariant Diff</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>

</div>

<h4 class="subsection">8.1.4 Annotate</h4>

<p><a name="index-Annotate-tool-216"></a><a name="index-MergeESC-tool_002c-see-Annotate-tool-217"></a>
The Annotate program inserts Daikon-generated invariants into Java
source code as annotations in  DBC, ESC, Java or JML format. 
These annotations are comments that can be automatically verified or
otherwise manipulated by other tools. 
The Daikon website has an example of code after invariant
insertion:  <a href="http://pag.csail.mit.edu/daikon/StackAr.html">http://pag.csail.mit.edu/daikon/StackAr.html</a>.

   <p>Invoke Annotate like this:
<pre class="example">     java daikon.tools.jtb.Annotate Myprog.inv Myprog.java Myprog2.java ...
</pre>
   <p>The first argument is a Daikon <samp><span class="file">.inv</span></samp> or <samp><span class="file">.inv.gz</span></samp> file
produced by running
Daikon with the <samp><span class="option">-o</span></samp> command-line argument.  All subsequent
arguments are <samp><span class="file">.java</span></samp> files.  The original <samp><span class="file">.java</span></samp> files are left
unmodified, but Annotate produces new versions of the <samp><span class="file">.java</span></samp> files
(with names suffixed as <samp><span class="file">-escannotated</span></samp>, <samp><span class="file">-jmlannotated</span></samp>, or
<samp><span class="file">-dbcannotated</span></samp>) that include the Daikon invariants as comments.

   <p>The options are:
     <dl>
<dt><samp><span class="option">--format </span><var>name</var></samp><dd>Produce output in the given format.  See <a href="#Invariant-syntax">Invariant syntax</a>.

     <br><dt><samp><span class="option">--no_reflection</span></samp><dd>Do not use reflection to find information about the classes being
instrumented.  This allows Annnotate to run without having access
to the class files.  Since the class files are necessary to generate &ldquo;also&rdquo;
tags, those tags will be left out when this option is chosen.

     <br><dt><samp><span class="option">--max_invariants_pp </span><var>count</var></samp><dd>Output at most <var>count</var> invariants per program point (which ones are chosen
is not specified).

     <br><dt><samp><span class="option">--wrap_xml</span></samp><dd>Each invariant is printed using the given format (ESC, JML or DBC),
but the invariant expression is wrapped inside XML tags, along with other
information about the invariant.

     <p>For example, if this switch is set, the output format is ESC,
and an invariant for method <code>foo(int x)</code> normally prints as

     <pre class="example">          /* requires x != 0; */
</pre>
     <p>Then the resulting output will look something like this (all
in one line; we break it up here for clarity):

     <pre class="example">          /* requires &lt;INVINFO&gt;
          &lt;INV&gt; x != 0 &lt;/INV&gt;
          &lt;SAMPLES&gt; 100 &lt;/SAMPLES&gt;
          &lt;DAIKON&gt; x != 0 &lt;/DAIKON&gt;
          &lt;DAIKONCLASS&gt; daikon.inv.unary.scalar.NonZero &lt;/DAIKONCLASS&gt;
          &lt;METHOD&gt; foo() &lt;/METHOD&gt;
          &lt;/INVINFO&gt; ; */
</pre>
     <p>Note that the comment will no longer be a legal ESC/JML/DBC
comment.  To make it legal again, you must replace the XML tags with
the string between the &lt;INV&gt; tag.

     <p>Also note the extra information printed with the invariant: the number
of samples from which the invariant was inferred, the Daikon
representation (i.e., the Daikon output format), the Java class that
the invariant corresponds to, and the method that the invariant
belongs to (<code>null</code> for object invariants).

   </dl>

   <p><a name="index-Annotate-warning_003a-Daikon-knows-nothing-about-field-218"></a><a name="index-Daikon-knows-nothing-about-field_003a--warning-from-Annotate-219"></a>If Annotate issues a warning message of the form
<pre class="example">       Warning: Annotate: Daikon knows nothing about field ...
</pre>
   <p class="noindent">then the Annotate tool found a variable in the source code that is was
computed by Daikon.  This can happen if Daikon was run omitting the
variable, for instance due to &ndash;std-visibility.  It can also happen due
to a bug in Annotate or Daikon; if that is the case, please report it to
the Daikon developers.

   <p><strong>Known bug (logical shift in Java).</strong>
Daikon's Java parser (adopted from javacc and JTB) accepts Java 1.5 syntax. 
An error in the new parser
may produce illegal Java in the annotated file, if the source file to be
annotated includes logical shift operators. See <a href="#Known-bugs">Known bugs</a>.

<div class="node">
<p><hr>
<a name="AnnotateNullable"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Annotate">Annotate</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>

</div>

<h4 class="subsection">8.1.5 AnnotateNullable</h4>

<p><a name="index-AnnotateNullable-tool-220"></a><a name="index-NonNull-type-inference-221"></a><a name="index-Nullable-type-inference-222"></a><a name="index-g_t_0040_0040NonNull-type-inference-223"></a><a name="index-g_t_0040_0040Nullable-type-inference-224"></a><a name="index-type-inference_002c-Nullable-225"></a><a name="index-inference_002c-of-Nullable-type-226"></a>
AnnotateNullable determines which variables in a Java program were ever
null during execution.  Its primary use is for performing inference for
a type system that detects null dereference errors.  An example is the
Nullness checker that is part of the
<a href="http://types.cs.washington.edu/checker-framework/">Checker Framework</a>.

   <p>The Nullness checker requires a programmer to annotate some references
with <code>@Nullable</code>, meaning the variable might be null; references
that are left unannotated are never null at run time.  (Alternately, the
checker can use <code>@NonNull</code> for references that are never
null, and leave unannotated for references that might be null.  The
Nullness checker supports either choice of default.)  The checker
then warns the programmer about possible null dereference errors.

   <p>The Nullness checker is useful, but writing all the annotations is tedious. 
The AnnotateNullable tool automatically and soundly determines a subset of the
proper <code>@Nullable</code> annotations.  Each annotation that it infers is
correct.  The programmer may need to write some additional
<code>@Nullable</code> annotations, but that is much easier than writing them all.

   <p>To insert <code>@Nullable</code> annotations in your program,
follow these steps:

     <ol type=1 start=1>
<li>Run your application one or more times to create a trace file.  As
always, the runs should exercise the application as thoroughly as
possible.  No incorrect <code>@Nullable</code> annotations are ever produced,
but more thorough runs produce a larger number of <code>@Nullable</code>
annotations.

     <pre class="smallexample">          java daikon.Chicory --dtrace-file=an.dtrace.gz <em>your-command-and-options</em>
</pre>
     <li>Run Daikon on the resulting .dtrace file:

     <pre class="smallexample">          java daikon.Daikon an.dtrace.gz --no_text_output \
              --config <var>daikondir</var>/java/daikon/annotate_nullable.config
</pre>
     <p>The example uses the <samp><span class="file">annotate_nullable.config</span></samp> configuration file
that is included in the Daikon distribution. 
You may use any configuration file, or none, as long as the NonZero
invariant is enabled.  The <samp><span class="file">annotate_nullable.config</span></samp> enables
<em>only</em> the NonZero invariant.  This makes Daikon run much faster,
but the resulting <samp><span class="file">.inv</span></samp> file is useful only for the
AnnotateNullable tool.

     <!-- This is an implementation detail, so leave it out of the manual. -->
     <!-- AnnotateNullable determines which variables have seen null values by -->
     <!-- looking at the NonZero invariant.  If NonZero is @emph{not} present for -->
     <!-- a variable @code{v}, then during the program execution, @code{v} must -->
     <!-- have been null at least once. -->
     <li>Run the AnnotateNullable tool to create an annotation index file. 
AnnotateNullable writes its output to standard out, so you should
redirect its output to a <samp><span class="file">.jaif</span></samp> file.

     <pre class="smallexample">          java daikon.AnnotateNullable an.inv.gz &gt; nullable-annotations.jaif
</pre>
     <li>Use the
<a href="http://types.cs.washington.edu/annotation-file-utilities/">Annotation File Utilities</a> to insert the annotations in your .class or .java
file.

     <pre class="smallexample">          insert-annotations <var>mypackage.MyClass</var> nullable-annotations.jaif
          insert-annotations-to-source nullable-annotations.jaif \
              mypackage/MyClass.java annotated/mypackage/MyClass.java
</pre>
        </ol>

   <p>AnnotateNullable is invoked as follows:
<pre class="smallexample">     java daikon.AnnotateNullable <i>[</i><var>flags</var><i>]</i> <var>inv-file</var>
</pre>
   <p>The flags are:

     <dl>
<dt><samp><span class="option">-n --nonnull-annotations</span></samp><dd>Adds NonNull annotations as well as Nullable annotations.  Unlike Nullable
annotations, NonNull annotations are not guaranteed to be correct.

   </dl>

<div class="node">
<p><hr>
<a name="Runtime-check-instrumenter"></a>
<a name="Runtime_002dcheck-instrumenter"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#InvariantChecker">InvariantChecker</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#AnnotateNullable">AnnotateNullable</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>

</div>

<h4 class="subsection">8.1.6 Runtime-check instrumenter (runtimechecker)</h4>

<p><a name="index-runtime_002dcheck-instrumenter-227"></a><a name="index-runtimechecker-instrumenter-228"></a>
The runtimechecker instrumenter inserts, into a Java file,
instrumentation code that checks invariants as the program executes. 
For a full list of options, run:

<pre class="example">     java daikon.tools.runtimechecker.Main help
</pre>
   <p>The <code>instrument</code> command to runtimechecker creates a new directory
<samp><span class="file">instrumented-classes</span></samp> containing a new version of the
user-specified Java files, instrumented to check invariants at runtime
and to record a list of invariant violations in a Java data structure.

   <p>Note that the instrumented program does not do anything with the list of
violations; it merely creates the list.  You will need to write your own
code to process that list; see <a href="#Accessing-violations">Accessing violations</a>.

   <p>Here is an example of use of the runtime-check instrumenter. 
To create a version of file
<samp><span class="file">ubs/BoundedStack.java</span></samp> that checks the invariants in
invariant file <samp><span class="file">BoundedStack.inv.gz</span></samp>, do:
<pre class="example">     java daikon.tools.runtimechecker.Main instrument BoundedStack.inv.gz \
         ubs/BoundedStack.java
</pre>
   <p class="noindent">The instrumented Java code references classes in the
<code>daikon.tools.runtimechecker</code> package, so those classes must be
present in the classpath when the instrumented classes are compiled and
executed.

   <p>Invariants are evaluated at the program points at which they should
hold.  Three things can happen when evaluating an
invariant:

     <ul>
<li>It evaluates to true, which means that the invariant holds. 
Program execution continues normally.

     <li>It evaluates to false, which means that the invariant doesn't
hold.  In this case the corresponding
<code>daikon.tools.runtimechecker.Property</code> is added to a list in the
class <code>daikon.tools.runtimechecker.Runtime</code>.  A programmer can
obtain the growing list of violated invariants through the method
<code>daikon.tools.runtimechecker.Runtime.getViolations()</code>. (See
that class for other useful methods.)

     <li>A <code>Throwable</code> (exception) is thrown when evaluating the
invariant.  In this case, the throwable is added to the list
<code>daikon.tools.runtimechecker.Runtime.internalInvariantEvaluationErrors</code>. 
The throwable is not rethrown.

   </ul>

<ul class="menu">
<li><a accesskey="1" href="#Accessing-violations">Accessing violations</a>
</ul>

<div class="node">
<p><hr>
<a name="Accessing-violations"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a>

</div>

<h5 class="subsubsection">8.1.6.1 Accessing violations</h5>

<p>The instrumented class handles violations silently:
it simply adds them to a list in the class
<code>daikon.tools.runtimechecker.Runtime.</code>
No &ldquo;invariant violation&rdquo; exceptions are thrown, and the violated
invariants can only be obtained dynamically from class
<code>daikon.tools.runtimechecker.Runtime</code>.

   <p>A future release of Daikon will provide tools that process the list in
the following ways:
     <ol type=1 start=1>
<a name="index-WriteViolationFile-tool-229"></a><li>To write a file of all the violations for a program execution. 
A prototype of such a tool is provided in the Daikon distribution, as
program <code>daikon.tools.runtimechecker.WriteViolationFile</code>.  If you
would ordinarily run your program as &lsquo;<samp><span class="samp">java MyProg arg1 arg2</span></samp>&rsquo;,
then running &lsquo;<samp><span class="samp">java daikon.tools.runtimechecker.WriteViolationFile
MyProg arg1 arg2</span></samp>&rsquo; creates a file called <samp><span class="file">violations.txt</span></samp> in the
current directory.  If the program under test calls
<code>System.exit</code>, then no <samp><span class="file">violations.txt</span></samp> file is created. 
<li>Throw an exception when any violation occurs.
        </ol>

   <p>The following code snippet contains a method <code>callMethod()</code> which
presumably calls one of the methods in the instrumented class. 
The code detects if any violations occurred, and if so, prints
a message.

<pre class="example">     daikon.tools.runtimechecker.Runtime.resetViolations();
     daikon.tools.runtimechecker.Runtime.resetErrors();
     
     callMethod();
     
     List&lt;Violation&gt; vs = daikon.tools.runtimechecker.Runtime.getViolations();
     
     if (!vs.isEmpty())
       System.out.println("Violations occurred.");
</pre>
   <p>In addition, the instrumenter adds the following two methods to the
instrumented class:

     <ul>
<li><code>isDaikonInstrumented()</code>.  Returns true (you could calling
this method to see if the class has been instrumented).

     <li><code>getDaikonInvariants()</code>.  Returns the array of properties being checked. 
</ul>

   <p><strong>Known bug (logical shift in Java).</strong>
Daikon's Java parser (adopted from javacc and JTB) accepts Java 1.5 syntax. 
An error in the new parser
may produce illegal Java in the instrumented file, if the source file to
be instrumented includes logical shift operators. See <a href="#Known-bugs">Known bugs</a>.

<div class="node">
<p><hr>
<a name="InvariantChecker"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#LogicalCompare">LogicalCompare</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>

</div>

<h4 class="subsection">8.1.7 InvariantChecker</h4>

<p><a name="index-InvariantChecker-tool-230"></a>
The InvariantChecker program takes a set of invariants found by Daikon
and a set of data trace files.  It checks each sample in the data trace
files against each of the invariants.  Any sample that violates an invariant
is noted, via a message printed to standard output or to a specified
output file.

   <p>InvariantChecker is invoked as follows:
<pre class="example">     java daikon.tools.InvariantChecker [<var>options</var>] <var>invariant-file</var> <var>dtrace-files</var>
</pre>
   <p>The <var>invariant-files</var> are invariant files (<samp><span class="file">.inv</span></samp>) created by
running Daikon.  The <var>dtrace-files</var> are data trace (<samp><span class="file">.dtrace</span></samp>)
files created by running the instrumented program.  The files may appear
in any order; the file type is determined by whether the file name
contains <samp><span class="file">.dtrace</span></samp>, or <samp><span class="file">.inv</span></samp>.

   <p>The options are:
     <dl>
<dt><samp><span class="option">--help</span></samp><dd>Print usage message.

     <br><dt><samp><span class="option">--output </span><var>output-file</var></samp><dd>Write any violations to the specified file.

     <br><dt><samp><span class="option">--conf</span></samp><dd>Checks only invariants that are above the default confidence level.

     <br><dt><samp><span class="option">--filter</span></samp><dd>Checks only invariants that are not filtered by the default filters.

     <br><dt><samp><span class="option">--verbose</span></samp><dd>Print all samples that violate an invariant.  By default only the totals
are printed.

     <br><dt><samp><span class="option">--dir </span><var>directory-name</var></samp><dd>Processes all invariant files in the given directory and reports the
number of invariants that failed on any of the dtrace files in that
directory.  We only process invariants above the default confidence
level and invariants that have not been filtered out by the default
filters.

     <br><dt><samp><span class="option">--config_option </span><var>name</var><span class="option">=</span><var>value</var></samp><dt><samp><span class="option">--dbg </span><var>category</var></samp><dt><samp><span class="option">--track </span><var>class</var><span class="option">&lt;</span><var>var1</var><span class="option">,</span><var>var2</var><span class="option">,</span><var>var3</var><span class="option">&gt;@</span><var>ppt</var></samp><dd>These switches are the same as for Daikon.  They are described in
<a href="#Running-Daikon">Running Daikon</a>.

   </dl>

<div class="node">
<p><hr>
<a name="LogicalCompare"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#InvariantChecker">InvariantChecker</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>

</div>

<h4 class="subsection">8.1.8 LogicalCompare</h4>

<p><a name="index-LogicalCompare-tool-231"></a><a name="index-implication-checking-tool-232"></a><a name="index-comparison-tool_002c-logical-233"></a>
Given two sets of invariants describing the operation of a software
module, or describing two implementations of a module with the same
interface, we can define one set of invariants to be &ldquo;stronger&rdquo; than
another roughly if in any situation where the &ldquo;stronger&rdquo; invariants
hold, the &ldquo;weaker&rdquo; invariants also hold.  The LogicalCompare tool
examines two sets of invariants, and checks using the Simplify
automatic theorem prover whether they satisfy a precise version of
this relationship.

   <p>Simplify must be separately obtained (from
<a href="http://www.hpl.hp.com/downloads/crl/jtk/">http://www.hpl.hp.com/downloads/crl/jtk/</a>) and installed in
order to use this program.

   <p>The LogicalCompare program takes two mandatory arguments, which are
<samp><span class="file">.inv</span></samp> files containing invariants; the invariants will be
checked to verify if the invariants in the first file are weaker
(implied by) the invariants in the second file, and exceptions to this
implication are printed.  If no other regular arguments are supplied,
all the method or function program points that exist in both files
will be compared, with a exception message reported for each method
that exists in the &ldquo;weaker&rdquo; set but not the &ldquo;stronger&rdquo;. 
Alternatively, one or two additional arguments may be supplied, which name an
<code>:::ENTER</code> program point and an <code>:::EXIT</code> program point to examine
(if only an <code>:::ENTER</code> program point is supplied,
the corresponding combined <code>:::EXIT</code> point
is selected automatically).  To be precise, for each
pair of program points representing a single method or function,
LogicalCompare will check that each precondition (<code>:::ENTER</code> point
invariant) in the &ldquo;stronger&rdquo; invariant set is implied by some
combination of invariants in the &ldquo;weaker&rdquo; invariant set, and that
each postcondition (<code>:::EXIT</code> point invariant) in the &ldquo;weaker&rdquo; invariant
set is implied by some combination of postconditions in the
&ldquo;stronger&rdquo; set and preconditions in the &ldquo;weaker&rdquo; set.  In summary,
the syntax of an invocation of LogicalCompare will have the following
form:

<pre class="example">     java daikon.tools.compare.LogicalCompare [<var>options</var>] \
           <var>weak-invs</var> <var>strong-invs</var> [<var>enter-ppt</var> [<var>exit-ppt</var>]]
</pre>
   <p>LogicalCompare accepts the following options:

     <dl>
<dt><samp><span class="option">--assume </span><var>file</var></samp><dd>Read additional assumptions about the behavior of compared routines
from the file <var>file</var>.  The assumptions file should consist of lines
starting with &lsquo;<samp><span class="samp">PPT_NAME</span></samp>&rsquo;, followed by the complete name of an
<code>:::ENTER</code> program point, followed by lines each consisting of a Simplify
formula, optionally followed by a <code>#</code> and a human-readable
annotation.  Blank lines and lines beginning with a <code>#</code> are
ignored.  The assumption properties will be used as if they were
invariants true at the strong <code>:::EXIT</code> point when checking
weak <code>:::EXIT</code> point invariants.

     <br><dt><samp><span class="option">--cfg </span><var>option</var><span class="option">=</span><var>value</var></samp><dd>Specify a single configuration setting.  The available settings are the
same as can be passed to Daikon's <samp><span class="option">--config_option</span></samp> option,
though because the invariants have already been generated, some will
have no effect.  For a list of
available options, see <a href="#Configuration-options">Configuration options</a>.

     <br><dt><samp><span class="option">--config-file=</span><var>file</var></samp><dd>Read configuration options from the file <var>file</var>.  This file should
have the same format as one passed to Daikon's <samp><span class="option">--config</span></samp>
option, though because the invariants have already been generated,
some will have no effect.

     <br><dt><samp><span class="option">--debug-all</span></samp><dt><samp><span class="option">--dbg </span><var>category</var></samp><dd>These options have the same effect as the <samp><span class="option">--debug</span></samp> and
<samp><span class="option">--dbg</span></samp> options to Daikon, causing debugging logs to be
printed.

     <br><dt><samp><span class="option">--filters=[bBoOmjpi]</span></samp><dd>Control which invariants are removed from consideration before
implications are checked.  Note that except as controlled by this
option, LogicalCompare does not perform any of the filters that
normally control whether invariants are printed by Daikon.  Also,
invariants that cannot be formatted for the Simplify automatic theorem
prover will be discarded in any case, as there would be no other way
to process them.  Each letter controls a filter: an invariant is rejected
if it is rejected by any filter (or, equivalently, kept only if it
passes through every filter).

          <dl>
<dt><samp><span class="option">b</span></samp><dd>Discard upper-bound and lower-bound invariants
(such as &ldquo;x &lt;= c&rdquo; and &ldquo;x &gt;= c&rdquo; for a
constant c), when Daikon considers the constant to be uninteresting. 
Currently, Daikon has a configurable range of interesting constant: by
default, -1, 0, 1, and 2 are interesting, and no other numbers are.

          <br><dt><samp><span class="option">B</span></samp><dd>Discard all bound invariants, whether or not the constants in them are
considered interesting.

          <br><dt><samp><span class="option">o</span></samp><dd>Discard &ldquo;one-of&rdquo; invariants (which signify that a variable always
had one of a small set of values at runtime), when the values that the
variable took are considered uninteresting by Daikon.

          <br><dt><samp><span class="option">O</span></samp><dd>Discard all &ldquo;one-of&rdquo; invariants, whether or not the values involved
are interesting.

          <br><dt><samp><span class="option">m</span></samp><dd>Discard invariants for which it was never the case that all the
variables involved in the invariant were present at the same time.

          <br><dt><samp><span class="option">j</span></samp><dd>Discard invariants that Daikon determines to be statistically
unjustified, according to its tests.

          <br><dt><samp><span class="option">p</span></samp><dd>Discard invariants that refer to the values of pass-by-value
parameters in the postcondition, or to the values of objects pointed
to by parameters in postconditions, when the pointer is not
necessarily the same as at the entrance to the method or function. 
Usually such invariants reflect implementation details that would not
be visible to the caller of a method.

          <br><dt><samp><span class="option">i</span></samp><dd>Discard implication invariants when they appear in <code>:::ENTER</code> program
points. 
</dl>

     <p>The default set of filters corresponds to the letters <samp><span class="option">ijmp</span></samp>.

     <br><dt><samp><span class="option">--help</span></samp><dd>Print a brief summary of available command-line options.

     <br><dt><samp><span class="option">--no-post-after-pre-failure</span></samp><dd>If implication is not verified between two invariant sets after
examining the preconditions, do not continue to check the implication
involving postconditions.  Because the postconditions aren't formally
meaningful outside the domain specified by the preconditions, this is
the safest behavior, but in practice trivial precondition mismatches
may prevent an otherwise meaningful postcondition comparison.  See also
<samp><span class="option">--post-after-pre-failure</span></samp>.

     <br><dt><samp><span class="option">--proofs</span></samp><dd>For each implication among invariants that is verified, print a
minimal set of conditions that establish the truth of the conclusion. 
The set is minimal, in the sense that if any condition were removed,
the conclusion would no longer logically follow according to Simplify,
but it is not the least such set: there may exist a smaller set of
conditions that establish the conclusion, if that set is not a subset
of the set printed.  Beware that because this option uses a naive
search technique, it may significantly slow down output.

     <br><dt><samp><span class="option">--post-after-pre-failure</span></samp><dd>Even if implication is not verified between two invariant sets after
examining the preconditions, continue to check the implication
involving postconditions.  This is somewhat dangerous, in that if the
implication does not hold between the preconditions, the invariant
sets may be inconsistent, in which case reasoning about the
postconditions is formally nonsensical, but the tool will attempt to
ignore the contradiction and carry on in this case.  This is now the
default behavior, so the option has no effect, but it is retained for
backward compatibility.  See also <samp><span class="option">--no-post-after-pre-failure</span></samp>.

     <br><dt><samp><span class="option">--show-count</span></samp><dd>Print a count of the number of invariants checked for implication.

     <br><dt><samp><span class="option">--show-formulas</span></samp><dd>For each invariant, show how it is represented as a logical formula
passed to Simplify.

     <br><dt><samp><span class="option">--show-sets</span></samp><dd>Rather than testing implications among invariants, simply print the
sets of weak and strong <code>:::ENTER</code> and <code>:::EXIT</code> point invariants that would
normally be compared.  The invariants are selected and filtered as
implied by other options.

     <br><dt><samp><span class="option">--show-valid</span></samp><dd>Print invariants that are verified to be implied (&ldquo;valid&rdquo;), as well
as those for which the implication could not be verified (&ldquo;invalid&rdquo;
invariants, which are always printed).

     <br><dt><samp><span class="option">--timing</span></samp><dd>For each set of invariants checked, print the total time required for
the check.  This time includes both processing done by LogicalCompare
directly, and time spent waiting for processing done by Simplify, but
does not include time spent de-serializing the <samp><span class="file">.inv</span></samp> input
files.

   </dl>

<div class="node">
<p><hr>
<a name="DtraceDiff-utility"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tools">Tools</a>

</div>

<h3 class="section">8.2 DtraceDiff utility</h3>

<p>DtraceDiff is a utility for comparing data trace (<samp><span class="file">.dtrace</span></samp>) files. 
It checks that the same program points are visited in the same order in
both files, and that the number, names, types, and values of variables
at each program point are the same.  The differences are found using a
content-based, rather than text-based, comparison of the two files.

   <p>DtraceDiff stops by signalling an error when it finds a difference
between the two data trace files.  (Once execution paths have
diverged, continuing to emit record-by-record differences is likely to
produce output that is far too voluminous to be useful.)  It also
signals an error when it detects incompatible program point
declarations or when one file is shorter than the other.

   <p>DtraceDiff is invoked as follows:
<pre class="example">     java daikon.tools.DtraceDiff [<var>flags</var>] \
        [<var>declsfiles1</var>] <var>dtracefile1</var>  [<var>declsfiles2</var>] <var>dtracefile2</var>
</pre>
   <p>Corresponding declarations (<samp><span class="file">.decls</span></samp>) files can optionally be
specified on the command line before each of the two <samp><span class="file">.dtrace</span></samp>
files.  Multiple <samp><span class="file">.decls</span></samp> files can be specified.  If no
<samp><span class="file">.decls</span></samp> file is specified, DtraceDiff assumes that the
declarations are included in the <samp><span class="file">.dtrace</span></samp> file instead.

   <p>DtraceDiff supports the following Daikon command-line flags:

     <dl>
<dt><samp><span class="option">--help</span></samp><dd>Print usage message.

     <br><dt><samp><span class="option">--config </span><var>filename</var></samp><dd>Load the configuration settings specified in the given file. 
See <a href="#Configuration-options">Configuration options</a>, for details.

     <br><dt><samp><span class="option">--config_option </span><var>name</var><span class="option">=</span><var>value</var></samp><dd>Specify a single configuration setting. 
See <a href="#Configuration-options">Configuration options</a>, for details.

     <br><dt><samp><span class="option">--ppt-select-pattern=</span><var>ppt_regexp</var></samp><dd>Only process program points whose names match the regular expression.

     <br><dt><samp><span class="option">--ppt-omit-pattern=</span><var>ppt_regexp</var></samp><dd>Do not process program points whose names match the regular expression. 
This takes priority over the <samp><span class="option">--ppt-select-pattern</span></samp> argument.

     <br><dt><samp><span class="option">--var-select-pattern=</span><var>ppt_regexp</var></samp><dd>Only process variables (whether in the trace file or derived) whose
names match the regular expression.

     <br><dt><samp><span class="option">--var-omit-pattern=</span><var>var_regexp</var></samp><dd>Ignore variables (whether in the trace file or derived) whose names
match the regular expression, which uses Perl syntax.  This takes
priority over the <samp><span class="option">--var-select-pattern</span></samp> argument.

   </dl>

   <p>DtraceDiff uses appropriate comparisons for the type of the variables in
each program point being compared.  In particular:

     <ul>
<li>Hashcode (pointer or address) values may differ from one run of
the same program to the next, and there may not be a one-to-one mapping
of hashcode values between different program executions, so the
comparison function only looks for null versus non-null pointer values.

     <li>Floating-point values are subject to roundoff error from printing and
reading, so they are compared with a &ldquo;fuzzy&rdquo; rather than exact equality test. 
</ul>

<div class="node">
<p><hr>
<a name="Troubleshooting"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Details">Details</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tools">Tools</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Troubleshooting</h2>

<p><a name="index-troubleshooting-234"></a><a name="index-warning-messages-235"></a><a name="index-error-messages-236"></a>
This chapter gives solutions for certain problems you might have with
Daikon.  It also tells you how to report bugs in a useful manner.

   <p>If, after reading this section and other parts of the manual, you are
unable to solve your problem, you may wish to send mail to one of the
mailing lists (see <a href="#Mailing-lists">Mailing lists</a>).

<ul class="menu">
<li><a accesskey="1" href="#Daikon-problems">Daikon problems</a>
<li><a accesskey="2" href="#Large-dtrace-files">Large dtrace files</a>
<li><a accesskey="3" href="#Parsing-Java-5_002e0-code">Parsing Java 5.0 code</a>
<li><a accesskey="4" href="#Chicory-problems">Chicory problems</a>
<li><a accesskey="5" href="#Reporting-problems">Reporting problems</a>
<li><a accesskey="6" href="#Known-bugs">Known bugs</a>
<li><a accesskey="7" href="#Further-reading">Further reading</a>
</ul>

<div class="node">
<p><hr>
<a name="Daikon-problems"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Large-dtrace-files">Large dtrace files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Troubleshooting">Troubleshooting</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Troubleshooting">Troubleshooting</a>

</div>

<h3 class="section">9.1 Problems running Daikon</h3>

<p>You may find the debugging flags <samp><span class="option">--debug</span></samp> and <samp><span class="option">--dbg
</span><var>category</var></samp> useful if you wish to track down bugs or better
understand Daikon's operation; See <a href="#Daikon-debugging-options">Daikon debugging options</a>. 
See <a href="#Configuration-options">Configuration options</a>, for another way to adjust Daikon's output.

<ul class="menu">
<li><a accesskey="1" href="#Too-much-output">Too much output</a>
<li><a accesskey="2" href="#Missing-output-invariants">Missing output invariants</a>
<li><a accesskey="3" href="#No-samples">No samples</a>
<li><a accesskey="4" href="#No-return-from-procedure">No return from procedure</a>
<li><a accesskey="5" href="#Unsupported-class-version">Unsupported class version</a>
<li><a accesskey="6" href="#Out-of-memory">Out of memory</a>
<li><a accesskey="7" href="#Simplify-errors">Simplify errors</a>
<li><a accesskey="8" href="#Contradictory-invariants">Contradictory invariants</a>
<li><a accesskey="9" href="#Method-needs-to-be-implemented">Method needs to be implemented</a>
<li><a href="#Daikon-runs-slowly">Daikon runs slowly</a>
<li><a href="#Bigger-traces-cause-invariants-to-appear">Bigger traces cause invariants to appear</a>
</ul>

<div class="node">
<p><hr>
<a name="Too-much-output"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Missing-output-invariants">Missing output invariants</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Daikon-problems">Daikon problems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.1 Too much output</h4>

<p><a name="index-too-much-output-from-Daikon-237"></a><a name="index-useless-output-from-Daikon-238"></a><a name="index-irrelevant-output-from-Daikon-239"></a>
Sometimes, Daikon may produce a very large number of seemingly
irrelevant properties that obscure the facts that you were hoping to
see.  Which properties are irrelevant depends on your current task, so
Daikon provides ways for you to customize its output.  See Daikon's
command-line options (see <a href="#Running-Daikon">Running Daikon</a>), and the techniques for
enhancing its output (see <a href="#Enhancing-Daikon-output">Enhancing Daikon output</a>), including its
configuration options (see <a href="#Configuration-options">Configuration options</a>).  The options for
the front ends &mdash; such as Chicory (see <a href="#Chicory-options">Chicory options</a>) and Kvasir
(see <a href="#Kvasir-options">Kvasir options</a>) &mdash; give additional control.

   <p>Some irrelevant properties are over unrelated variables, like comparing
an array index to elements of the array.  You should always use the
DynComp tool (see <a href="#DynComp-for-Java">DynComp for Java</a>, <a href="#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a>) to
avoid producing such properties.

   <p>Some irrelevant properties are not relevant to the domain (e.g., bitwise
operations).  You can exclude whole classes of unhelpful invariants from
Daikon's output (see <a href="#Options-to-enable_002fdisable-specific-invariants">Options to enable/disable specific invariants</a>).

   <p>Some irrelevant properties are over variables you do not care about, or
are in parts of the program that you do not care about.  You can exclude
certain variables or procedures from Daikon's output (see
<a href="#Processing-only-part-of-the-trace-file">Processing only part of the trace file</a> and <a href="#Options-to-enable_002fdisable-derived-variables">Options to enable/disable derived variables</a>).

   <p>Some irrelevant properties are logically redundant &mdash; multiple
properties express the same facts in different ways.  You can eliminate
such properties from Daikon's output (see <a href="#Options-to-control-invariant-detection">Options to control invariant detection</a>).

   <p>Some irrelevant output indicates a deficiency in your test suite:
your test suite is so small that many arbitrary properties hold over it. 
This happens when the test suite does not execute the code with a broad
distribution of values, but only executes the code with a few specific
values.  This problem disappears if you augment your test suite so that
it exercises the code with more different values.

   <p>More generally, each property that Daikon produces is a true fact about
how the target
program behaved.  However, some of these facts would be true for any
execution of the target program, and others are accidents of the
particular executions that Daikon observed.  Both types of facts may be
useful:  the former tell you about your program, and the latter tell you
about your test suite (and how to improve it!).

<div class="node">
<p><hr>
<a name="Missing-output-invariants"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#No-samples">No samples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Too-much-output">Too much output</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.2 Missing output invariants</h4>

<p>Daikon will sometimes not output invariants that are expected.  There
are a number of reasons why this may happen:

     <ul>
<li>There is a sample that violates the invariant
<li>The invariant is true, but does not pass one of the output filters
<li>One or more of the variables in the invariant always has the same
value as another variable.  Daikon only prints invariants over one
variable (the leader) from the set of equal variables (see <a href="#Equal-variables">Equal variables</a>). 
<li>The program point had no samples (see <a href="#No-samples">No samples</a>). 
</ul>

   <p>There are two command line options (&ndash;disc_reason and &ndash;track) that
will display information about invariants that are not printed.  The
<var>&ndash;disc_reason</var> option will indicate why a particular invariant
was discarded in most cases.  If it does not provide enough
information, try the <var>&ndash;track</var> option which traces the invariant
through all of Daikon's processing steps.  See <a href="#Daikon-debugging-options">Daikon debugging options</a> for more information.

   <p>Note that in each case the description (class, variables, program
point) of the invariant must be entered carefully.  It may be helpful
to try the option on a similar invariant that is printed to make sure
that each is specified correctly.

<div class="node">
<p><hr>
<a name="No-samples"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#No-return-from-procedure">No return from procedure</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Missing-output-invariants">Missing output invariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.3 No samples and no output</h4>

<p><a name="index-no-output-from-Daikon-240"></a>
When Daikon produces no output, that is usually a result of it having no
samples from which to generalize.  Use the <samp><span class="option">--output_num_samples</span></samp>
flag to Daikon to find out how many samples it is observing.  This
section tells you how to debug your problem if the
answer is 0, but you believe that there are samples in the file you are
feeding to Daikon.

   <p>Using the normal dataflow hierarchy, Daikon only explicitly processes
<code>:::EXIT</code> program points.  Other program points, such as
<code>:::ENTER</code> program points, are processed indirectly when their
corresponding <code>:::EXIT</code> points are encountered. 
(You can disable this behavior with the
<samp><span class="option">--nohierarchy</span></samp> switch to Daikon;
see See <a href="#Options-to-control-invariant-detection">Options to control invariant detection</a>.) 
If no <code>:::EXIT</code> program points are present (perhaps every
execution threw an exception, you filtered out all the
<code>:::EXIT</code> program points, or the data trace is obtained from
spreadsheet data instead of from a program execution),
then Daikon will not process any of the other program points, such as
the <code>:::ENTER</code> program points.  You can make Daikon print information
about unmatched procedure entries
via the &lsquo;<samp><span class="samp">daikon.FileIO.unmatched_procedure_entries_quiet</span></samp>&rsquo;
configuration option (see <a href="#General-configuration-options">General configuration options</a>).

   <p>Another way to increase the number of invariants printed
out is to lower the confidence bound cutoff.  Daikon
only prints invariants whose confidence level is greater than
the bound specified by the <samp><span class="option">--conf_limit</span></samp> option
(see <a href="#Options-to-control-invariant-detection">Options to control invariant detection</a>).  In order to maximize
the number of invariants printed, use <samp><span class="option">--conf_limit 0</span></samp> to see all
invariants Daikon is considering printing.

   <p>To try to determine why an invariant is not printed, use the
<samp><span class="option">--track</span></samp> to determine why Daikon does not print an invariant
(see <a href="#Daikon-debugging-options">Daikon debugging options</a>).

<div class="node">
<p><hr>
<a name="No-return-from-procedure"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Unsupported-class-version">Unsupported class version</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#No-samples">No samples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.4 No return from procedure</h4>

<p><a name="index-no-return-from-procedure_002c-warning-241"></a><a name="index-return-from-procedure_002c-warning-242"></a>
Daikon sometimes issues a warning that a procedure in the target program
was entered but never exited (that is, the target program abnormally
terminated).  In other words, the <samp><span class="file">.dtrace</span></samp> file contains more
entry records
than exit records for the given procedure.  Some procedures that were
entered were never recorded to have exited: either they threw an
exception, skipping the instrumentation code that would have recorded
normal termination, or the target program's run was interrupted. 
When this happens, the entry sample is ignored; the rationale is that
the particular values seen led to exception exit, were probably
illegal, and so should not be factored into the method preconditions.

   <p><a name="index-invocation-nonce-243"></a><a name="index-nonce_002c-invocation-244"></a><a name="index-this_005finvocation_005fnonce-245"></a>
In some cases, exceptional exit from a procedure can cause procedure
entries and exits (in the trace file) to be incorrectly matched up; if
they are incorrectly matched, then the <code>orig(</code><var>x</var><code>)</code> values may
be incorrect.  Daikon has two techniques for associate procedure exits
with entries &mdash; the nonce technique and the stack technique.  If a
<samp><span class="file">.dtrace</span></samp> file uses the nonce technique, <code>orig(</code><var>x</var><code>)</code>
values are guaranteed to be correct.  If a <samp><span class="file">.dtrace</span></samp> file uses
the stack technique, then incorrect <code>orig(</code><var>x</var><code>)</code> values are
likely to occur.  You can tell which technique Daikon will use by
examining the <samp><span class="file">.dtrace</span></samp> file.  If the second line of each entry
in the <samp><span class="file">.dtrace</span></samp> file is &lsquo;<samp><span class="samp">this_invocation_nonce</span></samp>&rsquo;, then Daikon
uses the nonce technique.  Otherwise, it uses the stack technique. 
Which technique is used is determined by the front end, which creates
the <samp><span class="file">.dtrace</span></samp> file, and typically cannot be controlled by the
user.

<div class="node">
<p><hr>
<a name="Unsupported-class-version"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Out-of-memory">Out of memory</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#No-return-from-procedure">No return from procedure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.5 Unsupported class version</h4>

<p><a name="index-UnsupportedClassVersionError-246"></a><a name="index-java_002elang_002eUnsupportedClassVersionError-247"></a><a name="index-major_002eminor-version-error-248"></a>
Daikon requires a Java 5 JVM (see <a href="#Requirements">Requirements</a>). 
An error such as
<pre class="example">     Exception in thread "main" java.lang.UnsupportedClassVersionError:
     daikon/Daikon (Unsupported major.minor version 49.0)
</pre>
   <p class="noindent">indicates that you are trying to run Daikon on an older JVM.  You need to
install a newer version of Java in order to run Daikon.

<div class="node">
<p><hr>
<a name="Out-of-memory"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Simplify-errors">Simplify errors</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Unsupported-class-version">Unsupported class version</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.6 Out of memory</h4>

<p><a name="index-out-of-memory-error-249"></a><a name="index-java_002elang_002eOutOfMemoryError-250"></a><a name="index-memory-exhaustion-251"></a><a name="index-HotSpot-JVM-252"></a><a name="index-JVM-memory-management-253"></a><a name="index-permanent-generation-_0028in-HotSpot-JVM_0029-254"></a>
If Daikon runs out of memory, generating a message like
<pre class="example">     Exception in thread "main" java.lang.OutOfMemoryError
             &lt;&lt;no stack trace available&gt;&gt;
</pre>
   <p class="noindent">then it is likely that it has created more invariants than will fit
in memory.  The number of invariants created depends on the number of
program points and the number of variables at each program point. 
In addition to the solutions discussed in <a href="#Reducing-program-points">Reducing program points</a>,
you can try increasing the amount of memory available to Java
with the <samp><span class="option">-mx</span></samp> argument to <samp><span class="command">java</span></samp>.  (This flag is
JVM-specific; see your JVM documentation for details.  For instance,
its correct name in JDK versions 1.3 and later is <samp><span class="option">-Xmx</span></samp>.) 
However, the value you use should be less your system's total amount
of physical memory. 
The default may be 64 megabytes or less; to permit use of up to 256
megabytes, you would run Java like so:
<pre class="example">     java -mx256m ...
</pre>
   <p>When using the Java HotSpot JVM, an additional parameter may need to
be increased.  HotSpot uses a separately-limited memory region, called
the &ldquo;permanent generation&rdquo;, for several special kinds of allocation,
one of which (interned strings) Daikon sometimes uses heavily.  It may
be necessary to increase this limit as well, with the
<samp><span class="option">-XX:MaxPermSize=</span></samp> option.  For instance, to use 512 megabytes,
of which at most 256 can be used for the permanent generation, you
would run Java like so:
<pre class="example">     java -Xmx512m -XX:MaxPermSize=256m
</pre>
   <p>Another possible problem is the creation of too many derived variables. 
If you supply the <samp><span class="option">--output_num_samples</span></samp> option to Daikon
(see <a href="#Options-to-control-Daikon-output">Options to control Daikon output</a>), then it will list all
variables at each program point.  If some of these are of no interest,
you may wish to suppress their creation.  For information on how to do that,
see <a href="#Options-to-enable_002fdisable-derived-variables">Options to enable/disable derived variables</a>.  Also see
<a href="#Reducing-variables">Reducing variables</a> for other techniques.

   <p>Any output generated before the out-of-memory error is perfectly valid.

<div class="node">
<p><hr>
<a name="Simplify-errors"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Contradictory-invariants">Contradictory invariants</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Out-of-memory">Out of memory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.7 Simplify errors</h4>

<p><a name="index-Simplify_002c-could-not-utilize-255"></a>
The warning &ldquo;Could not utilize Simplify&rdquo; indicates that the Simplify
theorem-prover could not be run; this usually indicates that the
Simplify binary was not found on the user's path. 
Simplify must be separately obtained (from
<a href="http://www.hpl.hp.com/downloads/crl/jtk/">http://www.hpl.hp.com/downloads/crl/jtk/</a>) and installed.

   <p>If Simplify is not used, certain redundant (logically implied)
invariants may appear in Daikon's output.  The output is
correct, but more verbose than it would be if you used Simplify.

<div class="node">
<p><hr>
<a name="Contradictory-invariants"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Method-needs-to-be-implemented">Method needs to be implemented</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Simplify-errors">Simplify errors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.8 Contradictory invariants</h4>

<p><a name="index-contradictory-invariants-256"></a><a name="index-inconsistent-invariants-257"></a><a name="index-invariants_002c-inconsistent-258"></a><a name="index-invariants_002c-contradictory-259"></a>
The invariants Daikon produces are all true statements about the
supplied program executions, so they should be mutually consistent. 
Sometimes, however, because of a bug or a limitation in Daikon,
contradictory invariants are produced.

   <p>One known problem involves object invariants.  Daikon infers object
invariants by observing the state of an object when its public methods
are called.  However, if an object has publicly accessible fields that
are changed by code outside the class, after which no public methods
are called, invariants about the state of the object as seen by other
code can contradict the class's object invariants.  A workaround is to
allow changes to an object's state from outside the class only by
way of public methods.

   <p>Besides confusing the user, contradictory invariants also cause
trouble for the Simplify theorem prover that implements the
<samp><span class="option">--suppress_redundant</span></samp> option.  When the invariants at a
particular program point contradict each other or background
information (such as the types of objects), Simplify becomes unable to
distinguish redundant invariants from non-redundant ones.

   <p>The best solution in such cases is to fix the underlying cause of the
contradictory invariants, but since that is sometimes not possible,
Daikon will try to work around the problem by avoiding the invariants
that cause a contradiction.  Daikon will attempt to find a small subset
of the invariants that aren't mutually consistent, and remove one,
repeating this process until the remaining invariants are consistent. 
(Note that the invariants are removed only for the purposes of
processing by Simplify; this does not affect whether they will be
printed in the final output).  While this technique can allow
redundant invariants to be found when they otherwise wouldn't be, it
has some drawbacks: the choice of which invariant to remove is
somewhat arbitrary, and the process of finding contradictory subsets
can be time consuming.  The removal process can be disabled with the
<samp><span class="option">daikon.simplify.LemmaStack.remove_contradictions</span></samp>
configuration option.

<div class="node">
<p><hr>
<a name="Method-needs-to-be-implemented"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Daikon-runs-slowly">Daikon runs slowly</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Contradictory-invariants">Contradictory invariants</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.9 Method needs to be implemented</h4>

<p><a name="index-method-needs-to-be-implemented-warning-260"></a><a name="index-needs-to-be-implemented-warning-261"></a>
Daikon may produce output like the following (but all on one line):
<pre class="example">     method daikon.inv.binary.twoSequence.SubSequence.format_esc()
     needs to be implemented:
     this.theArray[0..this.topOfStack] is a subsequence of
     orig(this.theArray[0..this.topOfStack])
</pre>
   <p class="noindent">This indicates that a particular invariant (shown on the last two lines
above) cannot be formatted using the current formatting.  In this example,
the invariant can be formatted using Daikon's default
formatting (which is how it is shown above), but (as of April 2002)
Daikon cannot output it in ESC format, so Daikon prints the above
message instead.  The message also shows exactly what Java method needs
to be implemented to correct the problem.  You can ignore such messages,
or else use an output formatting that can handle those invariants. 
Annotate (see <a href="#Annotate">Annotate</a>) automatically ignores unformattable invariants.

<div class="node">
<p><hr>
<a name="Daikon-runs-slowly"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bigger-traces-cause-invariants-to-appear">Bigger traces cause invariants to appear</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Method-needs-to-be-implemented">Method needs to be implemented</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.10 Daikon runs slowly</h4>

<p><a name="index-slow-operation_002c-of-Daikon-262"></a><a name="index-runtime_002c-of-Daikon-263"></a>
It can sometimes be slow to create a trace for Daikon to analyze, and it
can be slow for Daikon to analyze that trace.

   <p>For additional details on improving Daikon's performance, see <a href="#Out-of-memory">Out of memory</a>, and <a href="#Large-dtrace-files">Large dtrace files</a>.

<h5 class="subsubsection">9.1.10.1 Slow creation of large trace files</h5>

<p><a name="index-large-trace-files_002c-creating-264"></a>
Creating a trace can take a long time, because of the time to traverse
and print the values of many variables.  If your invariant detection
process runs slowly, you might want to separate the creation and
analysis of the trace file, to help you understand which part (or both)
are at fault.  Reducing the number of program points or variables can
speed up both creation and analysis of trace files.  For instance, you
might eliminate helper procedures from the analysis, or eliminate large
arrays that get repeatedly output.

<h5 class="subsubsection">9.1.10.2 Slow inference of invariants</h5>

<p><a name="index-large-trace-files_002c-creating-265"></a>
Daikon's runtime and space depend on the particular data that it analyzes. 
Informally, invariant detection time can be characterized as
<pre class="example">     O((<var>vars</var>^3 * <var>falsetime</var> + <var>trueinvs</var> * <var>testsuite</var>) * <var>procedures</var>)
</pre>
   <p class="noindent">where <var>vars</var> is the number of variables <em>at a program point</em>,
<var>falsetime</var> is the (small constant)
time to falsify a potential invariant,
<var>trueinvs</var> is the (small) number of
true invariants at a program point,
<var>testsuite</var> is the size of the test
suite, and
<var>procedures</var> is the number of instrumented program points.  The first
two products multiply a number of invariants by the time to test each
invariant.

   <p>If there are many true invariants over an input, then Daikon continues
to check them all over the entire input.  By contrast, if not many
invariants are true, then Daikon need no longer check them once they
are falsified (which in practice happens quickly).  Daikon processes
each procedure independently.

   <p>Another important factor affecting Daikon's runtime is the number of
variables.  Because invariants involve up to three variables each, the
number of invariants to check is cubic in the number of variables at a
single program point.  Derived variables (such as <code>a[i]</code>,
introduced whenever there is both an array <code>a</code> and an integer
<code>i</code>) can increase the number of variables substantially. 
The <samp><span class="option">daikon.derive.Derivation.disable_derived_variables</span></samp> and individual
<samp><span class="option">daikon.derive.*.*.enabled</span></samp> configuration variables
(see <a href="#Options-to-enable_002fdisable-derived-variables">Options to enable/disable derived variables</a>) may be used
to disable derived variables altogether or selectively, at the cost of
detecting fewer invariants, especially over sequences.

<div class="node">
<p><hr>
<a name="Bigger-traces-cause-invariants-to-appear"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Daikon-runs-slowly">Daikon runs slowly</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Daikon-problems">Daikon problems</a>

</div>

<h4 class="subsection">9.1.11 Bigger traces cause invariants to appear</h4>

<p>Suppose that you run Daikon twice.  The first time, you supply Daikon
with traces <i>T</i>.  The second time you supply Daikon with traces
<i>T</i>+<i>T'</i>:  either more files, or file(s) that are supersets of the
original one(s).  The second Daikon execution may report fewer
invariants, more invariants, or a mix.

   <p>The second execution may report <strong>fewer</strong> invariants, because the
additional data has eliminated overfitting (false positives).  There may
have been some accidental property of the shorter executions that is not
true in the longer ones.

   <p>Even though fewer invariants are true on the second execution, Daikon may
report invariants that it did not report on the first execution.  We
mention two reasons that Daikon might not report an invariant that is true:
statistical justification, and implication.

   <p>The second execution may report <strong>more</strong> invariants, because of Daikon's
statistical justification tests.  Daikon only reports a property if it is
statistically justified, and Daikon needs to see enough samples for the
statistical test to work.  So, there may have been a property that was true
both in the short trace and in the long one, but Daikon only reported it
for the long one.  If you want to prevent this from happening, you can
adjust the confidence limit so that the property is reported even in the
short executions; see the command-line option <code>--conf_limit</code>.  For
instance, supplying <code>--conf_limit 0</code> causes all properties that have
not been falsified to be printed.

   <p>Another reason that the second execution might report <strong>more</strong>
invariants (more specifically, might report an invariant that did not
appear in the first execution) is because Daikon does not report
redundant, or implied, invariants.  Suppose that both <code>i &lt; j</code> and
<code>i &lt;= j</code> were true on the first execution.  Daikon would report
only <code>i &lt; j</code>; Daikon would not report <code>i &lt;= j</code>, which is
implied by what Daikon has reported.  Further suppose that the second
execution had a sample containing <code>i=22, j=22</code>.  Only <code>i &lt;= j</code>
would be true in the second execution, and Daikon would report it. 
(The invariant <code>i &lt; j</code> is an example of a false positive or
overfitting in the first execution.)

<div class="node">
<p><hr>
<a name="Large-dtrace-files"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Parsing-Java-5_002e0-code">Parsing Java 5.0 code</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Daikon-problems">Daikon problems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Troubleshooting">Troubleshooting</a>

</div>

<h3 class="section">9.2 Large data trace (.dtrace) files</h3>

<p><a name="index-data-trace-files_002c-too-large-266"></a><a name="index-large-data-trace-files-267"></a>
Running instrumented code can create very large <samp><span class="file">.dtrace</span></samp> files. 
This can be a problem because writing the large files can slow the
target programs substantially, or because the large files may fill up
your disk.

   <p>This section describes ways to work around this problem.

<ul class="menu">
<li><a accesskey="1" href="#Run-Daikon-online">Run Daikon online</a>
<li><a accesskey="2" href="#Multiple-smaller-files">Multiple smaller files</a>
<li><a accesskey="3" href="#Less-information-per-file">Less information per file</a>
<li><a accesskey="4" href="#Reducing-program-points">Reducing program points</a>
<li><a accesskey="5" href="#Reducing-variables">Reducing variables</a>
<li><a accesskey="6" href="#Reducing-executions">Reducing executions</a>
</ul>

<div class="node">
<p><hr>
<a name="Run-Daikon-online"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Multiple-smaller-files">Multiple smaller files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Large-dtrace-files">Large dtrace files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Large-dtrace-files">Large dtrace files</a>

</div>

<h4 class="subsection">9.2.1 Run Daikon online</h4>

<p>The term &ldquo;online execution&rdquo; refers to running Daikon at the same time
as the target program.  The front end supplies information to Daikon
directly over a socket or pipe, without writing any information to a
file.  This can avoid some I/O overhead, and it prevents filling up your
disk with files.

   <p>The Chicory front end supports online execution via use of the
<samp><span class="option">--daikon-online</span></samp> option (see <a href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a>). 
The Kvasir front end supports online execution via use of (normal or
named) Unix pipes (see <a href="#Online-execution">Online execution</a>).

   <p>In the future, Daikon may be able to output partial results as the
target program is executing.

<div class="node">
<p><hr>
<a name="Multiple-smaller-files"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Less-information-per-file">Less information per file</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Run-Daikon-online">Run Daikon online</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Large-dtrace-files">Large dtrace files</a>

</div>

<h4 class="subsection">9.2.2 Create multiple smaller data trace files</h4>

<p>It is usually possible to create an <samp><span class="file">.inv</span></samp> file equivalent to
the one that Daikon would have computed, had Daikon been able to
process your entire program over its full test suite.  First, use the
techniques below (see <a href="#Reducing-program-points">Reducing program points</a>) to split your
<samp><span class="file">.dtrace</span></samp> file into parts.  Next, run Daikon on each resulting
<samp><span class="file">.dtrace</span></samp> file.  Finally, use the <a href="#MergeInvariants">MergeInvariants</a> tool
to combine the resulting <samp><span class="file">.inv</span></samp> files into one.

<div class="node">
<p><hr>
<a name="Less-information-per-file"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reducing-program-points">Reducing program points</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Multiple-smaller-files">Multiple smaller files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Large-dtrace-files">Large dtrace files</a>

</div>

<h4 class="subsection">9.2.3 Record or read less information in the data trace file</h4>

<p>You can record less information from each program execution, or you can
make Daikon read less information from the trace files.  It's usually
most efficient to do the pruning as early in the process as possible. 
For example, it is better to have the front end output less information,
rather than have Daikon ignore some of the information.

<ul class="menu">
<li><a accesskey="1" href="#Reducing-program-points">Reducing program points</a>
<li><a accesskey="2" href="#Reducing-variables">Reducing variables</a>
<li><a accesskey="3" href="#Reducing-executions">Reducing executions</a>
</ul>

<div class="node">
<p><hr>
<a name="Reducing-program-points"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reducing-variables">Reducing variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Less-information-per-file">Less information per file</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Large-dtrace-files">Large dtrace files</a>

</div>

<h4 class="subsection">9.2.4 Reducing program points (functions)</h4>

<p>Here are ways to compute invariants over a subset of the program
points (functions) in your program.
     <ol type=1 start=1>
<li>Make your front end instrument fewer files.  This is often mast
applicable if you are using a source-based front end.

     <li>You can instrument fewer procedures.
          <ul>
<li>With Chicory, use the <samp><span class="option">--ppt-omit-pattern</span></samp> or
<samp><span class="option">--ppt-select-pattern</span></samp> options (see <a href="#Processing-only-part-of-the-trace-file">Processing only part of the trace file</a>, <a href="#Chicory-options">Chicory options</a>) to
restrict which program points are traced.  Running the
instrumented program will result in a smaller <samp><span class="file">.dtrace</span></samp> file that
contains fewer records. 
<li>With Kvasir, use the <samp><span class="option">--ppt-list-file</span></samp> option to specify a list
of program points that should be traced (see <a href="#Tracing-only-part-of-a-program">Tracing only part of a program</a> section for more details). 
<!-- @item With dfec, split your program into multiple files, then -->
<!-- instrument only some of them (see below). -->

          <li><a name="index-trace_002dpurge_002dfns_002epl-script-268"></a>You can remove some program points (functions) from your
<samp><span class="file">.dtrace</span></samp> file.  The <samp><span class="command">trace-purge-fns.pl</span></samp> script takes as
arguments a (Perl) regular expression and a list of files.  It
modifies each file in place, removing every program point (function)
whose name matches the regular expression.  The <samp><span class="option">-v</span></samp> flag means
to retain rather than discard matching program points.  For instance,
to create two subparts of a <samp><span class="file">.dtrace</span></samp> file &mdash; one containing the
getters and setters, and the other containing all other functions &mdash;
use the following commands:
          <pre class="example">               cp myprog.dtrace myprog-setters.dtrace
               trace-purge-fns.pl -v 'set|get' myprog-setters.dtrace
               cp myprog.dtrace myprog-non-setters.dtrace
               trace-purge-fns.pl 'set|get' myprog-non-setters.dtrace
</pre>
          <li>You can make Daikon ignore some program points.  With the
<samp><span class="option">--ppt-select-pattern=</span><var>ppt_regexp</var></samp>
flag (see <a href="#Processing-only-part-of-the-trace-file">Processing only part of the trace file</a>),
only program points matching
the regular expression are processed.  Likewise, the
<samp><span class="option">--ppt-omit-pattern=</span><var>ppt_omit_regexp</var></samp> option causes program points
matching the regular expression to be ignored.

          <p>Also, the configuration variable <samp><span class="option">daikon.Daikon.ppt_perc</span></samp>
allows a percentage of the program points to be processed. 
See <a href="#General-configuration-options">General configuration options</a>, for details.

     </ul>

        </ol>

<div class="node">
<p><hr>
<a name="Reducing-variables"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reducing-executions">Reducing executions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reducing-program-points">Reducing program points</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Large-dtrace-files">Large dtrace files</a>

</div>

<h4 class="subsection">9.2.5 Reducing variables</h4>

<p>Here are ways to compute invariants over a subset of the variables in
your program.  This changes the resulting invariants, because
invariants over the missing variables (including any relationship
between a missing variable and a retained variable) are not detected
or reported.  For instance, you might remove uninteresting variables
(or ones that shouldn't be compared to certain others) or variables
that use a lot of memory (such as some arrays).

     <ol type=1 start=1>

     <li>You can reduce the number of variables that are output by instrumented
code &mdash; for instance, output &lsquo;<samp><span class="samp">a</span></samp>&rsquo; and &lsquo;<samp><span class="samp">a.b</span></samp>&rsquo; but not
&lsquo;<samp><span class="samp">a.b.c</span></samp>&rsquo;.  Do this by reducing the class/structure instrumentation
depth.
          <ul>
<li>With Chicory, use the <samp><span class="option">--nesting-depth=</span><var>N</var></samp> option. 
Also see the <samp><span class="option">--linked-lists=false</span></samp> option. 
<li>With Kvasir, use the <samp><span class="option">--struct-depth=</span><var>N</var></samp> or the
<samp><span class="option">--nesting-depth=</span><var>N</var></samp> option. 
<li>With Mangel-Wurzel, use the <samp><span class="option">--struct-depth=</span><var>N</var></samp> or the
<samp><span class="option">--nesting-depth=</span><var>N</var></samp> option. 
</ul>

     <li>With Kvasir, you can either ignore all global and/or static variables with the
<samp><span class="option">--ignore-globals</span></samp> and <samp><span class="option">--ignore-static-vars</span></samp> options or manually
specify a subset of variables to trace using the
<samp><span class="option">--var-list-file</span></samp> option (see <a href="#Tracing-only-part-of-a-program">Tracing only part of a program</a>
section for details)

     <li>You can pare down an existing <samp><span class="file">.dtrace</span></samp> file using the
<samp><span class="command">trace-purge-vars.pl</span></samp> script.  Analogously to the
<samp><span class="command">trace-purge-fns.pl</span></samp> script, it removes certain variables from
all program points in a function (or retains them, with the
<samp><span class="option">-v</span></samp> flag).  After running this command, you will need
to edit the corresponding <samp><span class="file">.decls</span></samp> file by hand to remove the
same variables.

     <li>You can make Daikon ignore certain variables rather than modifying
the <samp><span class="file">.dtrace</span></samp> file directly.  Analogously with the
<samp><span class="option">--ppt-select-pattern</span></samp> and <samp><span class="option">--ppt-omit-pattern</span></samp> flags, the
<samp><span class="option">--var-select-pattern</span></samp> and <samp><span class="option">--var-omit-pattern</span></samp> flags
restrict which variables Daikon processes
(see <a href="#Processing-only-part-of-the-trace-file">Processing only part of the trace file</a>, and <a href="#Chicory-options">Chicory options</a>).

        </ol>

<div class="node">
<p><hr>
<a name="Reducing-executions"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reducing-variables">Reducing variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Large-dtrace-files">Large dtrace files</a>

</div>

<h4 class="subsection">9.2.6 Reducing executions</h4>

<p>Here are ways to run Daikon over fewer executions of each program
point.  (You cannot combine the resulting invariants in order to
obtain the same result as running Daikon over all the executions.)

     <ol type=1 start=1>
<li>If you have multiple <samp><span class="file">.dtrace</span></samp> files (perhaps resulting from
multiple program runs), you can run Daikon on just some of them.

     <li><a name="index-trace_002duntruncate-program-269"></a>You can terminate the instrumented program when it has created a
sufficiently large <samp><span class="file">.dtrace</span></samp> file.  If you interrupt the program
while it is in the middle of writing a record to the <samp><span class="file">.dtrace</span></samp>
file, the last record may be only partially written.  Use the
<samp><span class="command">daikon/bin/trace-untruncate</span></samp> program to remove the last,
possibly partial, record from the file:
     <pre class="example">          trace-untruncate myfile.dtrace
</pre>
     <p class="noindent">modifies <samp><span class="file">myfile.dtrace</span></samp> in place to remove the last record.

     <p>Alternately, you can use the
<samp><span class="command">daikon/bin/trace-untruncate-fast</span></samp> program.  It operates much
faster on very large files.  In order to use
<samp><span class="command">trace-untruncate-fast</span></samp>, you must have already compiled it
(see <a href="#Installing-Daikon">Installing Daikon</a>).

     <li>You can cause the front end to record only a subset of executions of a
given procedure,
rather than every execution.  For example, Chicory's
<samp><span class="option">--sample-start</span></samp> command-line option does this (see <a href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a>).

        </ol>

<div class="node">
<p><hr>
<a name="Parsing-Java-5.0-code"></a>
<a name="Parsing-Java-5_002e0-code"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Chicory-problems">Chicory problems</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Large-dtrace-files">Large dtrace files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Troubleshooting">Troubleshooting</a>

</div>

<h3 class="section">9.3 Parsing Java 5.0 code</h3>

<p>The Annotate (see <a href="#Annotate">Annotate</a>) and runtimechecker (see <a href="#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a>) tools use an external library (JTB,
<a href="http://compilers.cs.ucla.edu/jtb/">http://compilers.cs.ucla.edu/jtb/</a>) for parsing Java code.  That
external library has an error in parsing logical shift operators such as
<code>x &lt;&lt; y</code> or <code>x &gt;&gt; y</code>.  Therefore, such invariants (along with
a few other invariants that cannot be properly formatted as Java code)
are suppressed from the output of these tools.  (Annotate inserts them
as comments, and runtimechecker silently ignores them.)

<div class="node">
<p><hr>
<a name="Chicory-problems"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reporting-problems">Reporting problems</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Parsing-Java-5_002e0-code">Parsing Java 5.0 code</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Troubleshooting">Troubleshooting</a>

</div>

<h3 class="section">9.4 Problems with Chicory</h3>

<p>Before reporting or investigating a problem with Chicory, always check
that the program executes properly when not being run under Chicory's
control.

   <p>For example, if a command such as
<pre class="example">     java daikon.Chicory DataStructures.StackArTester
</pre>
   <p class="noindent">fails with an error, then first try
<pre class="example">     java DataStructures.StackArTester
</pre>
   <p class="noindent">which is likely to fail with the same error.

   <p>If the latter command also fails, the problem is not with Chicory. 
First solve your Java problem, then once again attempt to use Chicory.

   <p>If the latter command does not fail, then you have found a bug in
Chicory; please report it if it is not already explained in this manual.

<ul class="menu">
<li><a accesskey="1" href="#VerifyError-constant-pool-index-error">VerifyError constant pool index error</a>
</ul>

<div class="node">
<p><hr>
<a name="VerifyError-constant-pool-index-error"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Chicory-problems">Chicory problems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Chicory-problems">Chicory problems</a>

</div>

<h4 class="subsection">9.4.1 VerifyError constant pool index error</h4>

<p><a name="index-VerifyError_002c-when-running-Chicory-270"></a><a name="index-java_002elang_002eVerifyError_002c-when-running-Chicory-271"></a><a name="index-illegal-constant-pool-index-error_002c-when-running-Chicory-272"></a><a name="index-constant-pool-index-error_002c-when-running-Chicory-273"></a>
If Chicory throws an error such as the following:
<pre class="smallexample">     Exception in thread "main" java.lang.VerifyError:
       (class: ps1/PublicTest, method: &lt;init&gt; signature: (Ljava/lang/String;)V)
       Illegal constant pool index
</pre>
   <p class="noindent">then the problem is most likely that your classpath contains a version
of the BCEL library (<samp><span class="file">bcel.jar</span></samp>) that is not compatible with Java
5.  You should either remove that version of BCEL from your classpath,
or you should ensure that it appears after <samp><span class="file">daikon.jar</span></samp>.  (If you
are running Daikon from sources rather than from <samp><span class="file">daikon.jar</span></samp>, then
ensure that <samp><span class="file">$DAIKONDIR/java/lib/bcel.jar</span></samp> is the first version of
BCEL on your classpath.)

<!-- @node    Eclipse plug-in problems, Reporting problems, dfej problems, Troubleshooting -->
<!-- @section Problems with Eclipse plug-in -->
<!-- @cindex Eclipse plug-in, troubleshooting -->
<!-- If you have trouble with the Eclipse plug-in, one good way to debug the -->
<!-- difficulty is to run the command-line tools (because the plug-in does -->
<!-- nothing more than run those tools for you).  If the command-line -->
<!-- versions work properly, then you have isolated the bug to the plug-in. -->
<!-- If the command-line versions do not work properly, then you can submit a -->
<!-- more specific bug report that is easier for the developers to reproduce -->
<!-- and correct. -->
<div class="node">
<p><hr>
<a name="Reporting-problems"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Known-bugs">Known bugs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Chicory-problems">Chicory problems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Troubleshooting">Troubleshooting</a>

</div>

<h3 class="section">9.5 Reporting problems</h3>

<p><a name="index-reporting-bugs-274"></a><a name="index-bugs_002c-reporting-275"></a><a name="index-reporting-problems-276"></a><a name="index-problems_002c-reporting-277"></a>
If you have any questions, can suggest ways to improve the
documentation, find bugs in the system, or have suggestions for its
improvement, please send email to
<a href="mailto:daikon-developers@lists.csail.mit.edu">daikon-developers@lists.csail.mit.edu</a>.  (If you can't figure
out how to do something or do not understand why Daikon works the way it
does, that is a bug, too &mdash; in the Daikon documentation.  Please report
those as well.) 
We will try to assist you and to correct any
problems, so please don't hesitate to ask for help or report
difficulties.  Additionally, if you can contribute enhancements or bug
fixes, those will be gratefully accepted.

   <p>In order for us to assist you, please provide a complete and useful bug
report.  Your bug report must provide all the information that is
required in order to replicate the bug and verify that our fix corrects
the problem.  If you do not provide complete information, we will not be
able to assist you.

   <p>Your bug report should include:
     <ul>
<li>the version of Daikon, which appears in the file <samp><span class="file">daikon/README</span></samp>
and is also printed when you run Daikon. 
<!-- ; also, whether you are running -->
<!-- from the @file{.class} files or from the @file{.jar} file. -->
If you are not using the most recent version, download a newer version
from <a href="http://pag.csail.mit.edu/daikon/">http://pag.csail.mit.edu/daikon/</a> to see whether your problem
has already been corrected. 
If you are using a modified version of Daikon, you should verify that
the problem exists in Daikon as distributed. 
<li>a description of exactly what you did (in sufficient detail for others
to reproduce the problem), exactly what happened, and what
you expected to happen instead. 
One good way to describe what you did is a list of
commands that, if executed, reproduces your error.  A good way to show
what happened is a transcript of execution of all of the commands.  (A
list of commands and a transcript are <strong>much</strong> more useful than a
vague description; please don't give vague English when you can supply a
more precise specification instead.)  It is crucial that you not omit
steps in your report.  For example, include instructions for installing
your software and all customizations to the software or your
environment, including all relevant environment variables.  Please do
not force the
developers to speculate about what you did; that is a waste of their
time, since you already have the knowledge. 
<li>input files that permit the problem to be replicated (by following the
detailed steps in your bug report).  The
most important thing is the original, uninstrumented source files (e.g.,
<samp><span class="file">.java</span></samp>), and any inputs/tests used when you ran the program. 
It is also helpful to include instrumented source files,
<samp><span class="file">.decl</span></samp> files, and <samp><span class="file">.dtrace</span></samp> files. 
<li>the operating system and revision you are using (e.g., Debian stable,
Windows XP service pack 2, etc)
<li>any other information that you consider relevant. 
</ul>

   <p>When users provide an inadequate bug report,
it is frequently more difficult for us to reproduce an error than to correct
it.  If you make it easy for us to reproduce and verify the problem, then it is
much more likely to be corrected.  Thanks for helping us to help you!

   <p>You may also wish to take advantage of the Daikon mailing lists
(see <a href="#Mailing-lists">Mailing lists</a>).

<div class="node">
<p><hr>
<a name="Known-bugs"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Further-reading">Further reading</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reporting-problems">Reporting problems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Troubleshooting">Troubleshooting</a>

</div>

<h3 class="section">9.6 Known bugs</h3>

<!-- @c Use the following if there are no known problems. -->
<!-- There are no outstanding user-reported problems at this time. -->
<!-- The following problems are already known.  (You may report them again, -->
<!-- to encourage us to fix them faster, if the problems are important to you.) -->
     <ul>
<li>This problem affects <a href="#Annotate">Annotate</a> and the <a href="#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a>, which output Java source code.  If
the java file to be annotated/instrumented uses logical
shift operators (<code>&gt;&gt;</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;&gt;</code>), the
annotated/instrumented java may contain extra brackets in these
operators.  For example, the expression <code>x &lt;&lt; y</code> in the input source
file may erroneously be translated as <code>x &lt;&lt;&lt;&lt;&lt;&lt; y</code> in the
annotated/instrumented file.

     <p>This error's presence will be immediately apparent if you try to compile
the annotated/instrumented file and it fails to compile because the
extra brackets make it syntactically illegal.  In this case, the best
solution we can recommend is that you manually fix the occurrence of the
logical shift operator.

     <p>This error is caused by a bug in the parser generator that generates
Daikon's Java parser.  We expect it will be fixed by the next release. 
</ul>

<div class="node">
<p><hr>
<a name="Further-reading"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Known-bugs">Known bugs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Troubleshooting">Troubleshooting</a>

</div>

<h3 class="section">9.7 Further reading</h3>

<p>More information on Daikon can be found in the Daikon Developer Manual
(see <a href="developer.html#Top">Top</a>). 
For instance, the Daikon Developer Manual indicates how to extend
Daikon with new invariants, new derived variables, and front ends for
new languages.  It also contains information about the implementation
and about how to debug.

   <p>You may find discussions on the mailing lists (see <a href="#Mailing-lists">Mailing lists</a>)
helpful.  The mailing list archives may contain helpful information, but
we strive to incorporate that information in this manual so that you
don't have to search the archives as well.

   <p>For further reading, see the list of publications at the
Daikon homepage, <a href="http://pag.csail.mit.edu/daikon/pubs/">http://pag.csail.mit.edu/daikon/pubs/</a>.

<div class="node">
<p><hr>
<a name="Details"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Index">Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Troubleshooting">Troubleshooting</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 Details</h2>

<p>The Daikon invariant detector is named after an Asian radish. 
&ldquo;Daikon&rdquo; is pronounced like the combination of the two one-syllable
English words &ldquo;die-con&rdquo;.

   <p>More information on Daikon can be found in the Daikon Developer Manual
(see <a href="developer.html#Top">Top</a>). 
For instance, the Daikon Developer Manual indicates how to extend
Daikon with new invariants, new derived variables, and front ends for
new languages.  It also contains information about the implementation
and about debugging flags.

<ul class="menu">
<li><a accesskey="1" href="#History">History</a>
<li><a accesskey="2" href="#License">License</a>
<li><a accesskey="3" href="#Mailing-lists-reminder">Mailing lists reminder</a>
<li><a accesskey="4" href="#Credits">Credits</a>
<li><a accesskey="5" href="#Citing-Daikon">Citing Daikon</a>
</ul>

<div class="node">
<p><hr>
<a name="History"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#License">License</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Details">Details</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Details">Details</a>

</div>

<h3 class="section">10.1 History</h3>

<p><a name="index-history-of-Daikon-278"></a>
This manual describes Daikon version 4.6.4, released June 23, 2010. 
A more detailed list of revisions since mid-2001 can be found in file
<samp><span class="file">daikon/doc/CHANGES</span></samp> in the distribution; this section gives a
high-level view of the package's history.

   <p>There have been four major releases of Daikon, with different features
and capabilities.  User experiences and technical papers should be
judged based on the version of Daikon current at the time of use.

   <p><a name="index-Lisp-front-end-279"></a><a name="index-front-end-for-Lisp-280"></a><!-- @cindex loop heads, instrumenting -->
<!-- @cindex instrumenting loop heads -->
<a name="index-Python-implementation-of-Daikon-281"></a><a name="index-Daikon-version-4_002e6_002e4-282"></a>
Daikon 1 was written in the Python programming language in 1998.  It included
front ends for C, Java, and Lisp.  The C front end was extremely limited
and failed to operate correctly on all C programs:  sometimes it
suffered a segmentation fault while instrumenting a target program, and even
when that did not happen, sometimes the instrumented program
segmentation-faulted while running.  The Lisp front end operated
correctly on all Lisp programs, but only instrumented certain common
constructs, leaving other language features uninstrumented.  The Java front
end was reasonably reliable.  The Lisp front end instrumented procedure
entries, exits, and loop heads; the C front ends instrumented only
procedure entries and exits; and the Java front end instrumented program
points for object invariants as well as procedure entries and exits.

   <p>Daikon 2 was a complete rewrite in the Java programming language and was
the first version to contain a substantive manual.  Daikon 2 uses the
same source-based Java front end as did Daikon 1, though with certain
enhancements.  Its C front end was rewritten from scratch; it
instruments only procedure entries and exits.  A front end also exists
for the IOA programming language, but is not included in the Daikon
distribution.

   <p>Daikon 3 is a redesign of the invariant detection engine to work
incrementally &mdash; that is, to examine each sample (execution of a
program point) once, then discard it.  By contrast, Daikon 1 and
Daikon 2 made multiple passes over the data.  This simplified their
algorithms but required storing all the data in memory at once, which
was prohibitive, particularly since data trace files may be gigabytes
in size.  Daikon 3 also introduces the idea of a <em>dataflow
hierarchy</em>, a way to relate and connect program points based on their
variables.

   <p>Daikon 4 includes new binary front ends for Java and for C.  These front
ends make Daikon much easier to use.  Daikon 4 makes <samp><span class="file">.decls</span></samp> files
optional; program point declarations are permitted to appear in
<samp><span class="file">.dtrace</span></samp> files.  Daikon 4 is released under more liberal licensing
conditions that place no restrictions on use.

<div class="node">
<p><hr>
<a name="License"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mailing-lists-reminder">Mailing lists reminder</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#History">History</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Details">Details</a>

</div>

<h3 class="section">10.2 License</h3>

<p><a name="index-license-283"></a>
Copyright &copy; 1998-2008 Massachusetts Institute of Technology

   <p>Copyright &copy; 2008-2009 University of Washington

   <p>Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
&ldquo;Software&rdquo;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   <p>The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

   <p>The names and trademarks of copyright holders may not be used in
advertising or publicity pertaining to the software without specific prior
permission. Title to copyright in this software and any associated
documentation will at all times remain with the copyright holders.

   <p>THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

<!-- As a condition of use, you agree to promptly communicate any changes, -->
<!-- improvements, or enhancements to the authors for inclusion in a -->
<!-- future release, and to promptly report any errors, problems, or -->
<!-- bugs. -->
<!-- Other licensing terms are available; -->
<!-- send mail to @email{mernst@@csail.mit.edu}. -->
   <pre class="sp">

</pre>

Daikon uses the Java port of the GNU getopt library, which is
copyright 1998 Aaron M. Renn.  The getopt library is free software, and
may be redistributed or modified under the terms of the GNU Library
General Public License version 2.  A copy of this license is included
with the Daikon distribution as the file
<samp><span class="file">java/gnu/getopt/COPYING.LIB</span></samp>.

   <p>Daikon's unit tests use the JUnit testing framework, which is governed
by the Common Public License, version 1.0.  JUnit is provided on an
&ldquo;as is&rdquo; basis, without warranties or conditions of any kind, either
express or implied including, without limitation, any warranties or
conditions of title, non-infringement, merchantability or fitness for
a particular purpose.  Neither the Daikon developers nor the authors of
the JUnit framework shall have any liability for any direct, indirect,
incidental, special, exemplary, or consequential damages (including
without limitation lost profits), however caused and on any theory of
liability, whether in contract, strict liability, or tort (including
negligence or otherwise) arising in any way out of the use or
distribution of JUnit or the exercise of any rights granted in
the Common Public License, even if advised of the possibility of such
damages.  Those portions of JUnit that appear in the Daikon
distribution may be redistributed under the same terms as Daikon
itself; this offer is made by the Daikon developers exclusively and
not by any other party.  The Common Public License is included with the
Daikon distribution as the file <samp><span class="file">java/junit/cpl-v10.html</span></samp>.

   <p>Note that the front ends discussed in this manual are separate
programs, and some are made available under different licenses. 
<!-- All -->
<!-- of the software in the main Daikon distribution is made available -->
<!-- under the same license as the Daikon tool proper, or a less -->
<!-- restrictive license.  However, -->
Because the front ends are separate
programs not derived from the Daikon invariant detection tool, you are
neither required nor entitled to use the Daikon invariant detector
itself under these other licenses.

   <p>The Daikon Perl front end dfepl may be used and distributed under the
regular Daikon license or, at your option, either the GNU General
Public License or the Perl Artistic License (that is, under the same
terms as Perl itself).

   <p>The Daikon C/C++ front end Kvasir is based in part on the Valgrind
dynamic program supervision framework, copyright 2000-2004 Julian
Seward, the Sparrow Valgrind tool, copyright 2002 Nicholas Nethercote,
the MemCheck Valgrind tool, copyright 2000-2004 Julian Seward, the
readelf program of the GNU Binutils, copyright 1998-2003 the Free
Software Foundation, Inc., the GNU C Library, copyright 1995, 1996,
1997, 2000  the Free Software Foundation, Inc., and the Diet libc,
copyright Felix von Leitner et al.  Kvasir is free software; you can
redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version. 
Kvasir is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.  You should have received a copy of the GNU General
Public License along with Kvasir, in a file kvasir/COPYING;
if not, write to the Free
Software Foundation, Inc., 51 Franklin St., Fifth Floor, Boston, MA
02110-1301, USA.

   <p>The Windows version of the Mangel-Wurzel C/C++ front end incorporates
the regular expression library written by Henry Spencer, which bears
this copyright notice:

   <blockquote>
Copyright 1992, 1993, 1994, 1997 Henry Spencer.  All rights reserved. 
This software is not subject to any license of the American Telephone
and Telegraph Company or of the Regents of the University of California.

        <p>Permission is granted to anyone to use this software for any purpose on
any computer system, and to alter it and redistribute it, subject
to the following restrictions:

          <ol type=1 start=1>

          <li>The author is not responsible for the consequences of use of this
   software, no matter how awful, even if they arise from flaws in it.

          <li>The origin of this software must not be misrepresented, either by
   explicit claim or by omission.  Since few users ever read sources,
   credits must appear in the documentation.

          <li>Altered versions must be plainly marked as such, and must not be
   misrepresented as being the original software.  Since few users
   ever read sources, credits must appear in the documentation.

          <li>This notice may not be removed or altered.
             </ol>
</blockquote>

<div class="node">
<p><hr>
<a name="Mailing-lists-reminder"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Credits">Credits</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#License">License</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Details">Details</a>

</div>

<h3 class="section">10.3 Mailing lists reminder</h3>

<p>If you use Daikon, please subscribe to the daikon-announce and
daikon-discuss mailing lists (see <a href="#Mailing-lists">Mailing lists</a>).  The
daikon-announce list will inform you of new versions, enhancements,
and bug fixes.  On the daikon-discuss mailing list, you can obtain
help from, and offer help to, other users.  We would also appreciate a
brief description of how you are using Daikon, sent to
<a href="mailto:daikon-developers@lists.csail.mit.edu">daikon-developers@lists.csail.mit.edu</a>.  We are curious about how
users exploit Daikon, and we are eager for anecdotes about its
successes and failures, so that we can make Daikon more effective for
its users.

<div class="node">
<p><hr>
<a name="Credits"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Citing-Daikon">Citing Daikon</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mailing-lists-reminder">Mailing lists reminder</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Details">Details</a>

</div>

<h3 class="section">10.4 Credits</h3>

<p><a name="index-contributors-to-Daikon-284"></a>
The following individuals have contributed to Daikon:
Yuriy Brun,
Jake Cockrell,
David Cok,
Adam Czeisler,
Brian Demsky,
Alan Donovan,
Nii Dodoo,
Alan Dunn,
Michael Ernst,
Eric Fellheimer,
William Griswold,
Philip Guo,
Melissa Hao,
Michael Harder,
Dieter von Holten,
Greg Jay,
Josh Kataoka,
Lee Lin,
Sandra Loosemore,
Vikash Mansinghka,
Stephen McCamant,
Samir Meghani,
Benjamin Morse,
Jelani Nelson,
Ryan Newton,
Jeremy Nimmer,
Toh Ne&nbsp;<!-- /@w -->Win,
David Notkin,
Carlos Pacheco,
Jeff Perkins,
Jaime Quinonez,
Robert Rudd,
Alexandru Salcianu,
Todd Schiller,
Kathryn Shih,
Matthew Tschantz,
Iuliu Vasilescu,
Chen Xiao,
Tao Xie,
Jeff Yuan.

   <p>Craig Kaplan carved the Daikon logo.

   <p>The feedback of Daikon users has been very valuable.  We are
particularly grateful to
B. Thomas Adler,
Rich Angros,
Tadashi Araragi,
Seung Mo Cho,
Christoph Csallner,
Dorothy Curtis,
Diego Garbervetsky,
Mangala Gowri,
Madeline Hardojo,
Engelbert Hubbers,
Nadya Kuzmina,
Scott McMaster,
Charles O'Donnell,
Alex Orso,
Rodric Rabbah,
Manos Renieris,
Rosie Wacha. 
Many others have also been generous with their feedback, for which we
are also grateful.

   <p>If your name has been inadvertently omitted from this section, please
let us know so we can correct the oversight.

   <p>Financial support has been provided by:
National Science Foundation (NSF),
Defense Advanced Research Projects Agency (DARPA),
ABB,
Edison Design Group,
IBM,
NTT,
MIT Oxygen Project,
Raytheon,
Toshiba.

<div class="node">
<p><hr>
<a name="Citing-Daikon"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Credits">Credits</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Details">Details</a>

</div>

<h3 class="section">10.5 Citing Daikon</h3>

<p>If you wish to cite Daikon in a publication, we recommend that you
reference one of the scholarly papers listed at
<a href="http://pag.csail.mit.edu/daikon/pubs/#invariant-detection">http://pag.csail.mit.edu/daikon/pubs/#invariant-detection</a> in lieu
of, or in addition to, referencing this manual and the Daikon website
(<a href="http://pag.csail.mit.edu/daikon/">http://pag.csail.mit.edu/daikon/</a>).

<div class="node">
<p><hr>
<a name="Index"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Details">Details</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-g_t_0040code_007b_002d1_007d-array-index-_0028counts-from-end-of-array_0029-59"><code>-1</code> array index (counts from end of array)</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-g_t_0040code_007b_002egetClass_0028_0029_007d-variable-62"><code>.getClass()</code> variable</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-g_t_002einv-files_002c-tools-for-manipulating-207">.inv files, tools for manipulating</a>: <a href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a></li>
<li><a href="#index-g_t_0040code_007b_002elength_007d-variable-name-63"><code>.length</code> variable name</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-g_t_002espinfo-file-109">.spinfo file</a>: <a href="#Splitter-info-file">Splitter info file</a></li>
<li><a href="#index-g_t_0040code_007b_002etoString_007d-variable-64"><code>.toString</code> variable</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-g_t_0040code_007b_002f_007d-variable-_0028C-global-or-file_002dstatic_0029-69"><code>/</code> variable (C global or file-static)</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-g_t64_002dbit-AMD64-architecture_002c-and-Kvasir-175">64-bit AMD64 architecture, and Kvasir</a>: <a href="#Kvasir-limitations">Kvasir limitations</a></li>
<li><a href="#index-g_t_003a_003a_003aCLASS-program-point-51">:::CLASS program point</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-g_t_003a_003a_003aENTER-program-point-41">:::ENTER program point</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-g_t_003a_003a_003aEXIT-program-point-44">:::EXIT program point</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-g_t_003a_003a_003aOBJECT-program-point-49">:::OBJECT program point</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-g_t_0040code_007b_0040_0040_007d-variable-_0028C-function_002dscoped-static_0029-70"><code>@</code> variable (C function-scoped static)</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-g_t_0040_0040NonNull-type-inference-223">@NonNull type inference</a>: <a href="#AnnotateNullable">AnnotateNullable</a></li>
<li><a href="#index-g_t_0040_0040Nullable-type-inference-224">@Nullable type inference</a>: <a href="#AnnotateNullable">AnnotateNullable</a></li>
<li><a href="#index-g_t_0040code_007b_005b_005d_007d-variable-name-_0028array-contents_0029-61"><code>[]</code> variable name (array contents)</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-abstract-types_002c-for-C_002fC_002b_002b-159">abstract types, for C/C++</a>: <a href="#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a></li>
<li><a href="#index-abstract-types_002c-for-Java-148">abstract types, for Java</a>: <a href="#DynComp-for-Java">DynComp for Java</a></li>
<li><a href="#index-AMD64-architecture_002c-and-Kvasir-171">AMD64 architecture, and Kvasir</a>: <a href="#Kvasir-limitations">Kvasir limitations</a></li>
<li><a href="#index-Annotate-tool-216">Annotate tool</a>: <a href="#Annotate">Annotate</a></li>
<li><a href="#index-Annotate-warning_003a-Daikon-knows-nothing-about-field-218">Annotate warning: Daikon knows nothing about field</a>: <a href="#Annotate">Annotate</a></li>
<li><a href="#index-AnnotateNullable-tool-220">AnnotateNullable tool</a>: <a href="#AnnotateNullable">AnnotateNullable</a></li>
<li><a href="#index-bugs_002c-reporting-275">bugs, reporting</a>: <a href="#Reporting-problems">Reporting problems</a></li>
<li><a href="#index-C_002fC_002b_002b-front-end-156">C/C++ front end</a>: <a href="#Kvasir">Kvasir</a></li>
<li><a href="#index-C_002fC_002b_002b-front-end-_0028deprecated_0029-178">C/C++ front end (deprecated)</a>: <a href="#Mangel_002dWurzel">Mangel-Wurzel</a></li>
<li><a href="#index-call_002dsite_002ddependent-invariant-105">call-site-dependent invariant</a>: <a href="#Conditional-invariants">Conditional invariants</a></li>
<li><a href="#index-category_002c-for-debugging-17">category, for debugging</a>: <a href="#Daikon-debugging-options">Daikon debugging options</a></li>
<li><a href="#index-Chicory-_0028front-end-for-Java_0029-131">Chicory (front end for Java)</a>: <a href="#Chicory">Chicory</a></li>
<li><a href="#index-class-invariants-55">class invariants</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-CLASS-program-point-52">CLASS program point</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-cluster-analysis-for-splitters-116">cluster analysis for splitters</a>: <a href="#Cluster-analysis-for-splitters">Cluster analysis for splitters</a></li>
<li><a href="#index-comma_002ddelimited-files-193">comma-delimited files</a>: <a href="#convertcsv_002epl">convertcsv.pl</a></li>
<li><a href="#index-comma_002dseparated_002dvalue-files-194">comma-separated-value files</a>: <a href="#convertcsv_002epl">convertcsv.pl</a></li>
<li><a href="#index-command-line-options-for-Daikon-9">command line options for Daikon</a>: <a href="#Running-Daikon">Running Daikon</a></li>
<li><a href="#index-comparability_002c-for-C_002fC_002b_002b-160">comparability, for C/C++</a>: <a href="#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a></li>
<li><a href="#index-comparability_002c-for-Java-149">comparability, for Java</a>: <a href="#DynComp-for-Java">DynComp for Java</a></li>
<li><a href="#index-comparing-invariants-215">comparing invariants</a>: <a href="#Invariant-Diff">Invariant Diff</a></li>
<li><a href="#index-comparison-tool_002c-logical-233">comparison tool, logical</a>: <a href="#LogicalCompare">LogicalCompare</a></li>
<li><a href="#index-conditional-invariant-100">conditional invariant</a>: <a href="#Conditional-invariants">Conditional invariants</a></li>
<li><a href="#index-confidence-limit-13">confidence limit</a>: <a href="#Options-to-control-invariant-detection">Options to control invariant detection</a></li>
<li><a href="#index-configuration-options-90">configuration options</a>: <a href="#Configuration-options">Configuration options</a></li>
<li><a href="#index-constant-pool-index-error_002c-when-running-Chicory-273">constant pool index error, when running Chicory</a>: <a href="#VerifyError-constant-pool-index-error">VerifyError constant pool index error</a></li>
<li><a href="#index-context_002dsensitive-invariant-104">context-sensitive invariant</a>: <a href="#Conditional-invariants">Conditional invariants</a></li>
<li><a href="#index-contradictory-invariants-256">contradictory invariants</a>: <a href="#Contradictory-invariants">Contradictory invariants</a></li>
<li><a href="#index-contributors-to-Daikon-284">contributors to Daikon</a>: <a href="#Credits">Credits</a></li>
<li><a href="#index-CPATH-environment-variable-184">CPATH environment variable</a>: <a href="#Standard-compiler-options-for-Mangel">Standard compiler options for Mangel</a></li>
<li><a href="#index-CreateSpinfo-113">CreateSpinfo</a>: <a href="#Static-analysis-for-splitters">Static analysis for splitters</a></li>
<li><a href="#index-CreateSpinfoC-114">CreateSpinfoC</a>: <a href="#Static-analysis-for-splitters">Static analysis for splitters</a></li>
<li><a href="#index-csv-files-192">csv files</a>: <a href="#convertcsv_002epl">convertcsv.pl</a></li>
<li><a href="#index-Cygwin-toolset-8">Cygwin toolset</a>: <a href="#Cygwin-shell">Cygwin shell</a></li>
<li><a href="#index-Daikon-knows-nothing-about-field_003a--warning-from-Annotate-219">Daikon knows nothing about field:  warning from Annotate</a>: <a href="#Annotate">Annotate</a></li>
<li><a href="#index-Daikon-output-format-26">Daikon output format</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-Daikon-version-4_002e6_002e4-282">Daikon version 4.6.4</a>: <a href="#History">History</a></li>
<li><a href="#index-daikon_002dannounce-mailing-list-2">daikon-announce mailing list</a>: <a href="#Mailing-lists">Mailing lists</a></li>
<li><a href="#index-daikon_002ddevelopers-mailing-list-4">daikon-developers mailing list</a>: <a href="#Mailing-lists">Mailing lists</a></li>
<li><a href="#index-daikon_002ddiscuss-mailing-list-3">daikon-discuss mailing list</a>: <a href="#Mailing-lists">Mailing lists</a></li>
<li><a href="#index-data-trace-files_002c-too-large-266">data trace files, too large</a>: <a href="#Large-dtrace-files">Large dtrace files</a></li>
<li><a href="#index-DBC-output-format-28">DBC output format</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-dcomp_005frt_002ejar-file-for-DynComp-151">dcomp_rt.jar file for DynComp</a>: <a href="#Instrumenting-the-JDK-with-DynComp">Instrumenting the JDK with DynComp</a></li>
<li><a href="#index-debugging-flags-16">debugging flags</a>: <a href="#Daikon-debugging-options">Daikon debugging options</a></li>
<li><a href="#index-derived-variables_002c-enabling_002fdisabling-95">derived variables, enabling/disabling</a>: <a href="#Options-to-enable_002fdisable-derived-variables">Options to enable/disable derived variables</a></li>
<li><a href="#index-derived-variables_002c-explanation-of-57">derived variables, explanation of</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-DerivedParameterFilter-83">DerivedParameterFilter</a>: <a href="#Invariant-filters">Invariant filters</a></li>
<li><a href="#index-dfepl-_0028front-end-for-Perl_0029-190">dfepl (front end for Perl)</a>: <a href="#dfepl">dfepl</a></li>
<li><a href="#index-diff_002c-over-invariants-214">diff, over invariants</a>: <a href="#Invariant-Diff">Invariant Diff</a></li>
<li><a href="#index-disambiguation-of-pointer-types-163">disambiguation of pointer types</a>: <a href="#Pointer-type-disambiguation">Pointer type disambiguation</a></li>
<li><a href="#index-dkconfig_005f-variables-91">dkconfig_ variables</a>: <a href="#Configuration-options">Configuration options</a></li>
<li><a href="#index-dtrace-file-name-144">dtrace file name</a>: <a href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a></li>
<li><a href="#index-DTRACEAPPEND-environment-variable-141">DTRACEAPPEND environment variable</a>: <a href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a></li>
<li><a href="#index-DTRACEFILE-environment-variable-139">DTRACEFILE environment variable</a>: <a href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a></li>
<li><a href="#index-dummy-invariant-106">dummy invariant</a>: <a href="#Conditional-invariants">Conditional invariants</a></li>
<li><a href="#index-dynamic-comparability_002c-for-C_002fC_002b_002b-161">dynamic comparability, for C/C++</a>: <a href="#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a></li>
<li><a href="#index-dynamic-comparability_002c-for-Java-150">dynamic comparability, for Java</a>: <a href="#DynComp-for-Java">DynComp for Java</a></li>
<li><a href="#index-DynComp_002c-for-C_002fC_002b_002b-158">DynComp, for C/C++</a>: <a href="#DynComp-for-C_002fC_002b_002b">DynComp for C/C++</a></li>
<li><a href="#index-DynComp_002c-for-Java-147">DynComp, for Java</a>: <a href="#DynComp-for-Java">DynComp for Java</a></li>
<li><a href="#index-Eiffel-front-end-199">Eiffel front end</a>: <a href="#Other-front-ends">Other front ends</a></li>
<li><a href="#index-EM64T-architecture_002c-and-Kvasir-174">EM64T architecture, and Kvasir</a>: <a href="#Kvasir-limitations">Kvasir limitations</a></li>
<li><a href="#index-ENTER-program-point-42">ENTER program point</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-environment-variable-DTRACEAPPEND-142">environment variable DTRACEAPPEND</a>: <a href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a></li>
<li><a href="#index-environment-variable-DTRACEFILE-140">environment variable DTRACEFILE</a>: <a href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a></li>
<li><a href="#index-error-messages-236">error messages</a>: <a href="#Troubleshooting">Troubleshooting</a></li>
<li><a href="#index-ESC_002fJava-output-format-32">ESC/Java output format</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-Excel-files-196">Excel files</a>: <a href="#convertcsv_002epl">convertcsv.pl</a></li>
<li><a href="#index-EXIT-program-point-45">EXIT program point</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-g_t_0040samp_007bExiting_007d_002c-in-Daikon-output-76">&lsquo;<samp><span class="samp">Exiting</span></samp>&rsquo;, in Daikon output</a>: <a href="#Interpreting-output">Interpreting output</a></li>
<li><a href="#index-FIFO_002c-as-data-trace-file-168">FIFO, as data trace file</a>: <a href="#Online-execution">Online execution</a></li>
<li><a href="#index-file-name_002c-for-dtrace-file-145">file name, for dtrace file</a>: <a href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a></li>
<li><a href="#index-filters-82">filters</a>: <a href="#Invariant-filters">Invariant filters</a></li>
<li><a href="#index-filters_002c-enabling_002fdisabling-92">filters, enabling/disabling</a>: <a href="#Options-to-enable_002fdisable-filters">Options to enable/disable filters</a></li>
<li><a href="#index-flags-for-Daikon-10">flags for Daikon</a>: <a href="#Running-Daikon">Running Daikon</a></li>
<li><a href="#index-front-end-126">front end</a>: <a href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a></li>
<li><a href="#index-front-end-for-C_002fC_002b_002b-155">front end for C/C++</a>: <a href="#Kvasir">Kvasir</a></li>
<li><a href="#index-front-end-for-C_002fC_002b_002b-_0028deprecated_0029-177">front end for C/C++ (deprecated)</a>: <a href="#Mangel_002dWurzel">Mangel-Wurzel</a></li>
<li><a href="#index-front-end-for-Eiffel-198">front end for Eiffel</a>: <a href="#Other-front-ends">Other front ends</a></li>
<li><a href="#index-front-end-for-IOA-201">front end for IOA</a>: <a href="#Other-front-ends">Other front ends</a></li>
<li><a href="#index-front-end-for-Java-128">front end for Java</a>: <a href="#Chicory">Chicory</a></li>
<li><a href="#index-front-end-for-Lisp-280">front end for Lisp</a>: <a href="#History">History</a></li>
<li><a href="#index-front-end-for-Lisp-204">front end for Lisp</a>: <a href="#Other-front-ends">Other front ends</a></li>
<li><a href="#index-front-end-for-Perl-188">front end for Perl</a>: <a href="#dfepl">dfepl</a></li>
<li><a href="#index-has-only-one-value_002c-in-invariant-output-77">has only one value, in invariant output</a>: <a href="#Has-only-one-value-variables">Has only one value variables</a></li>
<li><a href="#index-hashcode-type_002c-for-variables-78">hashcode type, for variables</a>: <a href="#Has-only-one-value-variables">Has only one value variables</a></li>
<li><a href="#index-hierarchical-cluster-analysis-119">hierarchical cluster analysis</a>: <a href="#Cluster-analysis-for-splitters">Cluster analysis for splitters</a></li>
<li><a href="#index-hierarchy-of-program-points-47">hierarchy of program points</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-hierarchy_002c-disabling-14">hierarchy, disabling</a>: <a href="#Options-to-control-invariant-detection">Options to control invariant detection</a></li>
<li><a href="#index-history-of-Daikon-278">history of Daikon</a>: <a href="#History">History</a></li>
<li><a href="#index-HotSpot-JVM-252">HotSpot JVM</a>: <a href="#Out-of-memory">Out of memory</a></li>
<li><a href="#index-IA_002d32e-architecture_002c-and-Kvasir-173">IA-32e architecture, and Kvasir</a>: <a href="#Kvasir-limitations">Kvasir limitations</a></li>
<li><a href="#index-illegal-constant-pool-index-error_002c-when-running-Chicory-272">illegal constant pool index error, when running Chicory</a>: <a href="#VerifyError-constant-pool-index-error">VerifyError constant pool index error</a></li>
<li><a href="#index-implication-checking-tool-232">implication checking tool</a>: <a href="#LogicalCompare">LogicalCompare</a></li>
<li><a href="#index-implication-invariant-102">implication invariant</a>: <a href="#Conditional-invariants">Conditional invariants</a></li>
<li><a href="#index-INCLUDE-environment-variable-183">INCLUDE environment variable</a>: <a href="#Standard-compiler-options-for-Mangel">Standard compiler options for Mangel</a></li>
<li><a href="#index-inconsistent-invariants-257">inconsistent invariants</a>: <a href="#Contradictory-invariants">Contradictory invariants</a></li>
<li><a href="#index-inference_002c-of-Nullable-type-226">inference, of Nullable type</a>: <a href="#AnnotateNullable">AnnotateNullable</a></li>
<li><a href="#index-installing-Daikon-5">installing Daikon</a>: <a href="#Installing-Daikon">Installing Daikon</a></li>
<li><a href="#index-installing-Kvasir-169">installing Kvasir</a>: <a href="#Installing-Kvasir">Installing Kvasir</a></li>
<li><a href="#index-instrumentation-127">instrumentation</a>: <a href="#Front-ends-_0028instrumentation_0029">Front ends (instrumentation)</a></li>
<li><a href="#index-instrumentation_002c-of-C_002fC_002b_002b-programs-157">instrumentation, of C/C++ programs</a>: <a href="#Kvasir">Kvasir</a></li>
<li><a href="#index-instrumentation_002c-of-C_002fC_002b_002b-programs-_0028deprecated_0029-179">instrumentation, of C/C++ programs (deprecated)</a>: <a href="#Mangel_002dWurzel">Mangel-Wurzel</a></li>
<li><a href="#index-instrumentation_002c-of-Eiffel-programs-200">instrumentation, of Eiffel programs</a>: <a href="#Other-front-ends">Other front ends</a></li>
<li><a href="#index-instrumentation_002c-of-IOA-programs-203">instrumentation, of IOA programs</a>: <a href="#Other-front-ends">Other front ends</a></li>
<li><a href="#index-instrumentation_002c-of-Java-programs-130">instrumentation, of Java programs</a>: <a href="#Chicory">Chicory</a></li>
<li><a href="#index-instrumentation_002c-of-Lisp-programs-206">instrumentation, of Lisp programs</a>: <a href="#Other-front-ends">Other front ends</a></li>
<li><a href="#index-instrumentation_002c-of-Perl-programs-191">instrumentation, of Perl programs</a>: <a href="#dfepl">dfepl</a></li>
<li><a href="#index-instrumented-JDK_002c-for-DynComp-152">instrumented JDK, for DynComp</a>: <a href="#Instrumenting-the-JDK-with-DynComp">Instrumenting the JDK with DynComp</a></li>
<li><a href="#index-Intel-64-architecture_002c-and-Kvasir-172">Intel 64 architecture, and Kvasir</a>: <a href="#Kvasir-limitations">Kvasir limitations</a></li>
<li><a href="#index-inv-files_002c-tools-for-manipulating-208">inv files, tools for manipulating</a>: <a href="#Tools-for-manipulating-invariants">Tools for manipulating invariants</a></li>
<li><a href="#index-invariant-diff-213">invariant diff</a>: <a href="#Invariant-Diff">Invariant Diff</a></li>
<li><a href="#index-invariant-filters-81">invariant filters</a>: <a href="#Invariant-filters">Invariant filters</a></li>
<li><a href="#index-invariant-list-79">invariant list</a>: <a href="#Invariant-list">Invariant list</a></li>
<li><a href="#index-invariant-merge-211">invariant merge</a>: <a href="#MergeInvariants">MergeInvariants</a></li>
<li><a href="#index-invariant-output-format-24">invariant output format</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-invariant_002c-conditional-101">invariant, conditional</a>: <a href="#Conditional-invariants">Conditional invariants</a></li>
<li><a href="#index-invariant_002c-dummy-107">invariant, dummy</a>: <a href="#Conditional-invariants">Conditional invariants</a></li>
<li><a href="#index-invariant_002c-implication-103">invariant, implication</a>: <a href="#Conditional-invariants">Conditional invariants</a></li>
<li><a href="#index-InvariantChecker-tool-230">InvariantChecker tool</a>: <a href="#InvariantChecker">InvariantChecker</a></li>
<li><a href="#index-invariants_002c-configuring-94">invariants, configuring</a>: <a href="#Other-invariant-configuration-parameters">Other invariant configuration parameters</a></li>
<li><a href="#index-invariants_002c-contradictory-259">invariants, contradictory</a>: <a href="#Contradictory-invariants">Contradictory invariants</a></li>
<li><a href="#index-invariants_002c-enabling_002fdisabling-93">invariants, enabling/disabling</a>: <a href="#Options-to-enable_002fdisable-specific-invariants">Options to enable/disable specific invariants</a></li>
<li><a href="#index-invariants_002c-inconsistent-258">invariants, inconsistent</a>: <a href="#Contradictory-invariants">Contradictory invariants</a></li>
<li><a href="#index-invariants_002c-list-of-all-80">invariants, list of all</a>: <a href="#Invariant-list">Invariant list</a></li>
<li><a href="#index-invocation-nonce-243">invocation nonce</a>: <a href="#No-return-from-procedure">No return from procedure</a></li>
<li><a href="#index-IOA-front-end-202">IOA front end</a>: <a href="#Other-front-ends">Other front ends</a></li>
<li><a href="#index-irrelevant-output-from-Daikon-239">irrelevant output from Daikon</a>: <a href="#Too-much-output">Too much output</a></li>
<li><a href="#index-Java-front-end-129">Java front end</a>: <a href="#Chicory">Chicory</a></li>
<li><a href="#index-Java-output-format-34">Java output format</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-java_002elang_002eOutOfMemoryError-250">java.lang.OutOfMemoryError</a>: <a href="#Out-of-memory">Out of memory</a></li>
<li><a href="#index-java_002elang_002eUnsupportedClassVersionError-247">java.lang.UnsupportedClassVersionError</a>: <a href="#Unsupported-class-version">Unsupported class version</a></li>
<li><a href="#index-java_002elang_002eVerifyError_002c-when-running-Chicory-271">java.lang.VerifyError, when running Chicory</a>: <a href="#VerifyError-constant-pool-index-error">VerifyError constant pool index error</a></li>
<li><a href="#index-JDK_002c-instrumented-for-DynComp-153">JDK, instrumented for DynComp</a>: <a href="#Instrumenting-the-JDK-with-DynComp">Instrumenting the JDK with DynComp</a></li>
<li><a href="#index-JML-output-format-36">JML output format</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-Jtest-DBC-output-format-30">Jtest DBC output format</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-JVM-memory-management-253">JVM memory management</a>: <a href="#Out-of-memory">Out of memory</a></li>
<li><a href="#index-kmeans-cluster-analysis-118">kmeans cluster analysis</a>: <a href="#Cluster-analysis-for-splitters">Cluster analysis for splitters</a></li>
<li><a href="#index-Kvasir-_0028binary-front-end-for-C_0029-154">Kvasir (binary front end for C)</a>: <a href="#Kvasir">Kvasir</a></li>
<li><a href="#index-Kvasir-installation-170">Kvasir installation</a>: <a href="#Installing-Kvasir">Installing Kvasir</a></li>
<li><a href="#index-large-data-trace-files-267">large data trace files</a>: <a href="#Large-dtrace-files">Large dtrace files</a></li>
<li><a href="#index-large-trace-files_002c-creating-264">large trace files, creating</a>: <a href="#Daikon-runs-slowly">Daikon runs slowly</a></li>
<li><a href="#index-license-283">license</a>: <a href="#License">License</a></li>
<li><a href="#index-linked-lists_002c-in-Chicory-138">linked lists, in Chicory</a>: <a href="#Variables-in-Chicory-output">Variables in Chicory output</a></li>
<li><a href="#index-Lisp-front-end-279">Lisp front end</a>: <a href="#History">History</a></li>
<li><a href="#index-Lisp-front-end-205">Lisp front end</a>: <a href="#Other-front-ends">Other front ends</a></li>
<li><a href="#index-local-variables-125">local variables</a>: <a href="#Loop-invariants">Loop invariants</a></li>
<li><a href="#index-local-variables-71">local variables</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-Logger-19">Logger</a>: <a href="#Daikon-debugging-options">Daikon debugging options</a></li>
<li><a href="#index-logging_002c-for-debugging-Daikon-18">logging, for debugging Daikon</a>: <a href="#Daikon-debugging-options">Daikon debugging options</a></li>
<li><a href="#index-LogicalCompare-tool-231">LogicalCompare tool</a>: <a href="#LogicalCompare">LogicalCompare</a></li>
<li><a href="#index-loop-invariants-124">loop invariants</a>: <a href="#Loop-invariants">Loop invariants</a></li>
<li><a href="#index-mailing-lists-1">mailing lists</a>: <a href="#Mailing-lists">Mailing lists</a></li>
<li><a href="#index-major_002eminor-version-error-248">major.minor version error</a>: <a href="#Unsupported-class-version">Unsupported class version</a></li>
<li><a href="#index-mangel-driver-180">mangel driver</a>: <a href="#Using-Mangel_002dWurzel">Using Mangel-Wurzel</a></li>
<li><a href="#index-Mangel_002dWurzel-_0028deprecated-source_002dbased-front-end-for-C_0029-176">Mangel-Wurzel (deprecated source-based front end for C)</a>: <a href="#Mangel_002dWurzel">Mangel-Wurzel</a></li>
<li><a href="#index-MANGEL_005fDIR-environment-variable-186">MANGEL_DIR environment variable</a>: <a href="#Installing-Mangel_002dWurzel">Installing Mangel-Wurzel</a></li>
<li><a href="#index-MANGEL_005fDIR-environment-variable-182">MANGEL_DIR environment variable</a>: <a href="#Standard-compiler-options-for-Mangel">Standard compiler options for Mangel</a></li>
<li><a href="#index-memory-exhaustion-251">memory exhaustion</a>: <a href="#Out-of-memory">Out of memory</a></li>
<li><a href="#index-merge-invariants-212">merge invariants</a>: <a href="#MergeInvariants">MergeInvariants</a></li>
<li><a href="#index-MergeESC-tool_002c-see-Annotate-tool-217">MergeESC tool, see Annotate tool</a>: <a href="#Annotate">Annotate</a></li>
<li><a href="#index-method-needs-to-be-implemented-warning-260">method needs to be implemented warning</a>: <a href="#Method-needs-to-be-implemented">Method needs to be implemented</a></li>
<li><a href="#index-Microsoft-Windows-7">Microsoft Windows</a>: <a href="#Running-Daikon-under-Windows">Running Daikon under Windows</a></li>
<li><a href="#index-mux-output-12">mux output</a>: <a href="#Options-to-control-Daikon-output">Options to control Daikon output</a></li>
<li><a href="#index-named-pipe_002c-as-data-trace-file-167">named pipe, as data trace file</a>: <a href="#Online-execution">Online execution</a></li>
<li><a href="#index-needs-to-be-implemented-warning-261">needs to be implemented warning</a>: <a href="#Method-needs-to-be-implemented">Method needs to be implemented</a></li>
<li><a href="#index-negative-array-index-_0028counts-from-end-of-array_0029-60">negative array index (counts from end of array)</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-no-output-from-Daikon-240">no output from Daikon</a>: <a href="#No-samples">No samples</a></li>
<li><a href="#index-no-return-from-procedure_002c-warning-241">no return from procedure, warning</a>: <a href="#No-return-from-procedure">No return from procedure</a></li>
<li><a href="#index-nonce_002c-invocation-244">nonce, invocation</a>: <a href="#No-return-from-procedure">No return from procedure</a></li>
<li><a href="#index-NonNull-type-inference-221">NonNull type inference</a>: <a href="#AnnotateNullable">AnnotateNullable</a></li>
<li><a href="#index-nonsensical-values-for-variables-58">nonsensical values for variables</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-nonsensical-values-for-variables_002c-guarding_002e-97">nonsensical values for variables, guarding.</a>: <a href="#General-configuration-options">General configuration options</a></li>
<li><a href="#index-Nullable-type-inference-222">Nullable type inference</a>: <a href="#AnnotateNullable">AnnotateNullable</a></li>
<li><a href="#index-object-invariants-53">object invariants</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-OBJECT-program-point-50">OBJECT program point</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-observer-methods_002c-as-synonym-for-pure-methods-137">observer methods, as synonym for pure methods</a>: <a href="#Variables-in-Chicory-output">Variables in Chicory output</a></li>
<li><a href="#index-ObviousFilter-84">ObviousFilter</a>: <a href="#Invariant-filters">Invariant filters</a></li>
<li><a href="#index-on_002dthe_002dfly-execution_002c-for-C-programs-165">on-the-fly execution, for C programs</a>: <a href="#Online-execution">Online execution</a></li>
<li><a href="#index-online-execution_002c-for-C-programs-164">online execution, for C programs</a>: <a href="#Online-execution">Online execution</a></li>
<li><a href="#index-OnlyConstantVariablesFilter-85">OnlyConstantVariablesFilter</a>: <a href="#Invariant-filters">Invariant filters</a></li>
<li><a href="#index-g_t_0040code_007borig_0028_0029_007d-variable-_0028pre_002dstate-value_0029-75"><code>orig()</code> variable (pre-state value)</a>: <a href="#orig-variable-example">orig variable example</a></li>
<li><a href="#index-g_t_0040code_007borig_0028_0029_007d-variable-_0028pre_002dstate-value_0029-65"><code>orig()</code> variable (pre-state value)</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-out-of-memory-error-249">out of memory error</a>: <a href="#Out-of-memory">Out of memory</a></li>
<li><a href="#index-output-format_002c-Daikon-27">output format, Daikon</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-output-format_002c-DBC-29">output format, DBC</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-output-format_002c-ESC_002fJava-33">output format, ESC/Java</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-output-format_002c-for-invariants-25">output format, for invariants</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-output-format_002c-Java-35">output format, Java</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-output-format_002c-JML-37">output format, JML</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-output-format_002c-Jtest-DBC-31">output format, Jtest DBC</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-output-format_002c-Simplify-39">output format, Simplify</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-ParentFilter-86">ParentFilter</a>: <a href="#Invariant-filters">Invariant filters</a></li>
<li><a href="#index-Perl-front-end-189">Perl front end</a>: <a href="#dfepl">dfepl</a></li>
<li><a href="#index-permanent-generation-_0028in-HotSpot-JVM_0029-254">permanent generation (in HotSpot JVM)</a>: <a href="#Out-of-memory">Out of memory</a></li>
<li><a href="#index-pipe_002c-as-data-trace-file-166">pipe, as data trace file</a>: <a href="#Online-execution">Online execution</a></li>
<li><a href="#index-pointer-type-disambiguation-162">pointer type disambiguation</a>: <a href="#Pointer-type-disambiguation">Pointer type disambiguation</a></li>
<li><a href="#index-g_t_0040code_007bpost_0028_0029_007d-variable-_0028post_002dstate-value_0029-67"><code>post()</code> variable (post-state value)</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-post_002dstate-variables-68">post-state variables</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-postcondition-46">postcondition</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-pre_002dstate-variables-66">pre-state variables</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-precondition-43">precondition</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-printing-invariants-209">printing invariants</a>: <a href="#Printing-invariants">Printing invariants</a></li>
<li><a href="#index-PrintInvariants-program-210">PrintInvariants program</a>: <a href="#Printing-invariants">Printing invariants</a></li>
<li><a href="#index-private-methods-56">private methods</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-private-variables-134">private variables</a>: <a href="#Variables-in-Chicory-output">Variables in Chicory output</a></li>
<li><a href="#index-problems_002c-reporting-277">problems, reporting</a>: <a href="#Reporting-problems">Reporting problems</a></li>
<li><a href="#index-program-point-40">program point</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-program-point-hierarchy-48">program point hierarchy</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-pure-methods-136">pure methods</a>: <a href="#Variables-in-Chicory-output">Variables in Chicory output</a></li>
<li><a href="#index-PURIFY_005fDIR-environment-variable-187">PURIFY_DIR environment variable</a>: <a href="#Installing-Mangel_002dWurzel">Installing Mangel-Wurzel</a></li>
<li><a href="#index-PURIFY_005fDIR-environment-variable-185">PURIFY_DIR environment variable</a>: <a href="#Standard-compiler-options-for-Mangel">Standard compiler options for Mangel</a></li>
<li><a href="#index-Python-implementation-of-Daikon-281">Python implementation of Daikon</a>: <a href="#History">History</a></li>
<li><a href="#index-random-selection-for-splitters-122">random selection for splitters</a>: <a href="#Random-selection-for-splitters">Random selection for splitters</a></li>
<li><a href="#index-reporting-bugs-274">reporting bugs</a>: <a href="#Reporting-problems">Reporting problems</a></li>
<li><a href="#index-reporting-problems-276">reporting problems</a>: <a href="#Reporting-problems">Reporting problems</a></li>
<li><a href="#index-representation-invariants-54">representation invariants</a>: <a href="#Program-points">Program points</a></li>
<li><a href="#index-return-from-procedure_002c-warning-242">return from procedure, warning</a>: <a href="#No-return-from-procedure">No return from procedure</a></li>
<li><a href="#index-runcluster_002epl-program-117">runcluster.pl program</a>: <a href="#Cluster-analysis-for-splitters">Cluster analysis for splitters</a></li>
<li><a href="#index-runtime_002c-of-Daikon-263">runtime, of Daikon</a>: <a href="#Daikon-runs-slowly">Daikon runs slowly</a></li>
<li><a href="#index-runtime_002dcheck-instrumenter-227">runtime-check instrumenter</a>: <a href="#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a></li>
<li><a href="#index-runtimechecker-instrumenter-228">runtimechecker instrumenter</a>: <a href="#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a></li>
<li><a href="#index-samples-breakdown-output-11">samples breakdown output</a>: <a href="#Options-to-control-Daikon-output">Options to control Daikon output</a></li>
<li><a href="#index-sampling-of-program-point-executions-132">sampling of program point executions</a>: <a href="#Program-points-in-Chicory-output">Program points in Chicory output</a></li>
<li><a href="#index-Simplify-output-format-38">Simplify output format</a>: <a href="#Invariant-syntax">Invariant syntax</a></li>
<li><a href="#index-Simplify-theorem-prover_002c-configuring-96">Simplify theorem prover, configuring</a>: <a href="#Simplify-interface-configuration-options">Simplify interface configuration options</a></li>
<li><a href="#index-Simplify_002c-could-not-utilize-255">Simplify, could not utilize</a>: <a href="#Simplify-errors">Simplify errors</a></li>
<li><a href="#index-SimplifyFilter-87">SimplifyFilter</a>: <a href="#Invariant-filters">Invariant filters</a></li>
<li><a href="#index-slow-operation_002c-of-Daikon-262">slow operation, of Daikon</a>: <a href="#Daikon-runs-slowly">Daikon runs slowly</a></li>
<li><a href="#index-spinfo-file-110">spinfo file</a>: <a href="#Splitter-info-file">Splitter info file</a></li>
<li><a href="#index-splitter-info-file-108">splitter info file</a>: <a href="#Splitter-info-file">Splitter info file</a></li>
<li><a href="#index-splitting-98">splitting</a>: <a href="#Conditional-invariants">Conditional invariants</a></li>
<li><a href="#index-splitting-condition-99">splitting condition</a>: <a href="#Conditional-invariants">Conditional invariants</a></li>
<li><a href="#index-splitting-conditions_002c-cluster-analysis-115">splitting conditions, cluster analysis</a>: <a href="#Cluster-analysis-for-splitters">Cluster analysis for splitters</a></li>
<li><a href="#index-splitting-conditions_002c-random-selection-121">splitting conditions, random selection</a>: <a href="#Random-selection-for-splitters">Random selection for splitters</a></li>
<li><a href="#index-splitting-conditions_002c-static-analysis-111">splitting conditions, static analysis</a>: <a href="#Static-analysis-for-splitters">Static analysis for splitters</a></li>
<li><a href="#index-spreadsheet-files-197">spreadsheet files</a>: <a href="#convertcsv_002epl">convertcsv.pl</a></li>
<li><a href="#index-static-analysis-for-splitters-112">static analysis for splitters</a>: <a href="#Static-analysis-for-splitters">Static analysis for splitters</a></li>
<li><a href="#index-Static-fields-_0028global-variables_0029-in-Java-programs-146">Static fields (global variables) in Java programs</a>: <a href="#Static-fields-_0028global-variables_0029">Static fields (global variables)</a></li>
<li><a href="#index-tab_002dseparated-files-195">tab-separated files</a>: <a href="#convertcsv_002epl">convertcsv.pl</a></li>
<li><a href="#index-temporary-_0028local_0029-variables-73">temporary (local) variables</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-this_005finvocation_005fnonce-245">this_invocation_nonce</a>: <a href="#No-return-from-procedure">No return from procedure</a></li>
<li><a href="#index-too-much-output-from-Daikon-237">too much output from Daikon</a>: <a href="#Too-much-output">Too much output</a></li>
<li><a href="#index-trace-file-name-143">trace file name</a>: <a href="#Chicory-miscellaneous-options">Chicory miscellaneous options</a></li>
<li><a href="#index-trace_002dpurge_002dfns_002epl-script-268">trace-purge-fns.pl script</a>: <a href="#Reducing-program-points">Reducing program points</a></li>
<li><a href="#index-trace_002duntruncate-program-269">trace-untruncate program</a>: <a href="#Reducing-executions">Reducing executions</a></li>
<li><a href="#index-TraceSelect-tool-123">TraceSelect tool</a>: <a href="#Random-selection-for-splitters">Random selection for splitters</a></li>
<li><a href="#index-troubleshooting-234">troubleshooting</a>: <a href="#Troubleshooting">Troubleshooting</a></li>
<li><a href="#index-type-inference_002c-Nullable-225">type inference, Nullable</a>: <a href="#AnnotateNullable">AnnotateNullable</a></li>
<li><a href="#index-UnjustifiedFilter-88">UnjustifiedFilter</a>: <a href="#Invariant-filters">Invariant filters</a></li>
<li><a href="#index-unmatched-entries_002c-not-ignoring-15">unmatched entries, not ignoring</a>: <a href="#Options-to-control-invariant-detection">Options to control invariant detection</a></li>
<li><a href="#index-UnmodifiedVariableEqualityFilter-89">UnmodifiedVariableEqualityFilter</a>: <a href="#Invariant-filters">Invariant filters</a></li>
<li><a href="#index-UnsupportedClassVersionError-246">UnsupportedClassVersionError</a>: <a href="#Unsupported-class-version">Unsupported class version</a></li>
<li><a href="#index-useless-output-from-Daikon-238">useless output from Daikon</a>: <a href="#Too-much-output">Too much output</a></li>
<li><a href="#index-variables_002c-local-72">variables, local</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-variables_002c-omit-133">variables, omit</a>: <a href="#Variables-in-Chicory-output">Variables in Chicory output</a></li>
<li><a href="#index-variables_002c-private-135">variables, private</a>: <a href="#Variables-in-Chicory-output">Variables in Chicory output</a></li>
<li><a href="#index-variables_002c-temporary-_0028local_0029-74">variables, temporary (local)</a>: <a href="#Variable-names">Variable names</a></li>
<li><a href="#index-VerifyError_002c-when-running-Chicory-270">VerifyError, when running Chicory</a>: <a href="#VerifyError-constant-pool-index-error">VerifyError constant pool index error</a></li>
<li><a href="#index-warning-messages-235">warning messages</a>: <a href="#Troubleshooting">Troubleshooting</a></li>
<li><a href="#index-Windows-6">Windows</a>: <a href="#Running-Daikon-under-Windows">Running Daikon under Windows</a></li>
<li><a href="#index-WriteViolationFile-tool-229">WriteViolationFile tool</a>: <a href="#Accessing-violations">Accessing violations</a></li>
<li><a href="#index-wurzel-preprocessor-181">wurzel preprocessor</a>: <a href="#Using-Mangel_002dWurzel">Using Mangel-Wurzel</a></li>
<li><a href="#index-xm-cluster-analysis-120">xm cluster analysis</a>: <a href="#Cluster-analysis-for-splitters">Cluster analysis for splitters</a></li>
   </ul></body></html>

